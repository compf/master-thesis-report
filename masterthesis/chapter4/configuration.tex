\section{Configuration}\label{sec:config}
An important aspect for the usability of the tool is the possibility to configure the tool for the user's need. 

Since the goal of the tool is to allow the combination of multiple services and other tools in order to find and refactor data clumps, the user must be able to define which handler deals with which step  as outlined in section \ref{sec:pipeline}.

The configuration is provided by a \ac{JSON} file whose location needs to be provided to the tool via a command line argument. It might be argued that providing the configuration directly via the command line is better suited than a separate configuration file because they do not require the creations of files and are easier for users who start the tool just once. Nevertheless, configuration files are persistent and especially \ac{JSON} can be more easily structured so that they are easier to understand. As a result, only \ac{JSON} files will be used  for the configuration. 


Listing \ref{lst:config} shows an example configuration file:
  \begin{figure} [htbp!]
			\lstinputlisting
			[caption={ Example configuration file},
			label={lst:config},
			captionpos=b, basicstyle=\footnotesize, tabsize=2, showstringspaces=false,  numbers=left]
			{figures/chapter4/config.json}
		\end{figure}


In the beginning, the programming language is defined (l.~1). 

Then, the user can define objects. An object can be used by a handler to perform sub-steps, but declaring an object in \ac{JSON} does not necessarily mean that it is used. 

Here, one object is declared. The \textit{RandomProbabilityFilter} decides with a given probability whether a data clump or file is to be kept or excluded. 


Then, the pipeline is defined. It consists of two handlers in this example.

The first handler deals with file filtering. It receives as an argument the name of the filter object previously declared. 

The second step (l.~ 10-26), deals with the detection of data clumps. Here a handler is used that allows detection and refactoring of data clumps via ChatGPT. This specific handler requires sub-handlers that perform intermediate task. For instance, the \textit{SimpleInstructionHandler} loads an instruction from a file path. The \textit{PairOfFileContent} handler submits pairs of file contents to ChatGPT.

It should be noted that the order of the handlers in the configuration  does not matter because the execution order is constant and in most cases, each step requires the context of a previous step so that parallel execution or vice-versa execution of steps is not possible. Only in the case of usage finding and name finding would a parallel execution make sense because none of these steps is dependent on the other.  However, this exception is not implemented.

Not all relevant objects are part of the pipeline. Some are outside of the pipeline and can be referenced by all handlers. Here, the large language model \ac{API} is initialized with ChatGPT(l.~ 28).

Each object that appears in the \ac{JSON} is instantiated using dependency injection. This means that the objects initially are registered at a central location but not fully instantiated until they are really needed. The general approach is as follows:
\begin{enumerate}
    \item The main program loads the \ac{JSON} and iterates over all objects
    \item Each object has a category (e.~g. \textit{LanguageModelInterface} (see l.~ 28)) and a name (e.~g. ChatGPTInterface). The name and its category might be identical if only one instance of the respective class is needed. 
    \item The name of the object and it parameters are registered at the central dependency manager under the category given
    \item If a handler or other object needs another object of a specific category, it can ask the central manager. If the respective object has  yet not been created, it will be created. Otherwise, the already instantiated object will be returned. 
\end{enumerate}
With this approach, a looser coupling can be achieved. Each handler has access to the configuration it needs and does not have to deal with the creation of objects. 