@article{abbesEmpiricalStudyImpact2011,
  title = {An {{Empirical Study}} of the {{Impact}} of {{Two Antipatterns}}, {{Blob}} and {{Spaghetti Code}}, on {{Program Comprehension}}},
  author = {Abbes, Marwen and Khomh, F. and Guéhéneuc, Yann-Gaël and Antoniol, G.},
  date = {2011},
  journaltitle = {2011 15th European Conference on Software Maintenance and Reengineering},
  volume = {null},
  pages = {181--190},
  doi = {10.1109/CSMR.2011.24},
  url = {https://www.semanticscholar.org/paper/b49d83fac32ed427949662f03eb29f27c259808a},
  abstract = {Antipatterns are "poor" solutions to recurring design problems which are conjectured in the literature to make object-oriented systems harder to maintain. However, little quantitative evidence exists to support this conjecture. We performed an empirical study to investigate whether the occurrence of antipatterns does indeed affect the understandability of systems by developers during comprehension and maintenance tasks. We designed and conducted three experiments, with 24 subjects each, to collect data on the performance of developers on basic tasks related to program comprehension and assessed the impact of two antipatterns and of their combinations: Blob and Spaghetti Code. We measured the developers’ performance with: (1) the NASA task load index for their effort, (2) the time that they spent performing their tasks, and, (3) their percentages of correct answers. Collected data show that the occurrence of one antipattern does not significantly decrease developers’ performance while the combination of two antipatterns impedes significantly developers. We conclude that developers can cope with one antipattern but that combinations of antipatterns should be avoided possibly through detection and refactorings.}
}

@article{abdellatifMSRBotUsingBots2019,
  title = {{{MSRBot}}: {{Using}} Bots to Answer Questions from Software Repositories},
  author = {Abdellatif, Ahmad and Shihab, Emad},
  date = {2019},
  journaltitle = {Empirical Software Engineering},
  volume = {25},
  pages = {1834--1863},
  doi = {10.1007/s10664-019-09788-5},
  url = {https://www.semanticscholar.org/paper/5f2620d870b11d8217978151cee1e3a2c8da7484},
  abstract = {S2 TL;DR: This work has the potential to transform the MSR field by significantly lowering the barrier to entry, making the extraction of useful information from software repositories as easy as chatting with a bot.}
}

@article{abdellatifMSRBotUsingBots2019a,
  title = {{{MSRBot}}: {{Using}} Bots to Answer Questions from Software Repositories},
  author = {Abdellatif, Ahmad and Shihab, Emad},
  date = {2019},
  journaltitle = {Empirical Software Engineering},
  volume = {25},
  pages = {1834--1863},
  doi = {10.1007/s10664-019-09788-5},
  url = {https://www.semanticscholar.org/paper/5f2620d870b11d8217978151cee1e3a2c8da7484},
  abstract = {S2 TL;DR: This work has the potential to transform the MSR field by significantly lowering the barrier to entry, making the extraction of useful information from software repositories as easy as chatting with a bot.}
}

@article{arnaoudovaAdaptationRefactoringStrategies2008,
  title = {Adaptation of {{Refactoring Strategies}} to {{Multiple Axes}} of {{Modularity}}: {{Characteristics}} and {{Criteria}}},
  author = {Arnaoudova, V. and Constantinides, Constantinos A.},
  date = {2008},
  journaltitle = {2008 Sixth International Conference on Software Engineering Research, Management and Applications},
  volume = {null},
  pages = {105--114},
  doi = {10.1109/SERA.2008.38},
  url = {https://www.semanticscholar.org/paper/e263439d64ea95075af5a2f98b0ae09c8ebfbe22},
  abstract = {In object-oriented programming, the adoption of modules as mixins provides a second axis of modularity. Furthermore, support for aspect-oriented programming introduces a third such axis. In this paper we define criteria under which a feature should be placed in a given unit of modularity and investigate the degree to which the presence of multiple dimensions of modularity affects existing refactoring strategies. We reason about the dilemmas involved and we provide guidelines for applying existing refactoring strategies in order to support the above criteria. We adopt Ruby and Aquarium as example technologies in order to provide an environment with classes, modules and aspects.}
}

@article{arnaoudovaAdaptationRefactoringStrategies2008a,
  title = {Adaptation of {{Refactoring Strategies}} to {{Multiple Axes}} of {{Modularity}}: {{Characteristics}} and {{Criteria}}},
  author = {Arnaoudova, V. and Constantinides, Constantinos A.},
  date = {2008},
  journaltitle = {2008 Sixth International Conference on Software Engineering Research, Management and Applications},
  volume = {null},
  pages = {105--114},
  doi = {10.1109/SERA.2008.38},
  url = {https://www.semanticscholar.org/paper/e263439d64ea95075af5a2f98b0ae09c8ebfbe22},
  abstract = {In object-oriented programming, the adoption of modules as mixins provides a second axis of modularity. Furthermore, support for aspect-oriented programming introduces a third such axis. In this paper we define criteria under which a feature should be placed in a given unit of modularity and investigate the degree to which the presence of multiple dimensions of modularity affects existing refactoring strategies. We reason about the dilemmas involved and we provide guidelines for applying existing refactoring strategies in order to support the above criteria. We adopt Ruby and Aquarium as example technologies in order to provide an environment with classes, modules and aspects.}
}

@article{bavotaAreTestSmells2015,
  title = {Are Test Smells Really Harmful? {{An}} Empirical Study},
  author = {Bavota, G. and Qusef, A. and Oliveto, R. and Lucia, A. D. and Binkley, D.},
  date = {2015},
  journaltitle = {Empirical Software Engineering},
  volume = {20},
  pages = {1052--1094},
  doi = {10.1007/s10664-014-9313-0},
  url = {https://www.semanticscholar.org/paper/3cf34e993f11a5a2492469f14c224854355ced80},
  abstract = {S2 TL;DR: Two studies aimed at providing empirical data on the prevalence and impact of bad test code smells are presented and provide evidence that test smells have a strong negative impact on program comprehension and maintenance.}
}

@article{bavotaAreTestSmells2015a,
  title = {Are Test Smells Really Harmful? {{An}} Empirical Study},
  author = {Bavota, G. and Qusef, A. and Oliveto, R. and Lucia, A. D. and Binkley, D.},
  date = {2015},
  journaltitle = {Empirical Software Engineering},
  volume = {20},
  pages = {1052--1094},
  doi = {10.1007/s10664-014-9313-0},
  url = {https://www.semanticscholar.org/paper/3cf34e993f11a5a2492469f14c224854355ced80},
  abstract = {S2 TL;DR: Two studies aimed at providing empirical data on the prevalence and impact of bad test code smells are presented and provide evidence that test smells have a strong negative impact on program comprehension and maintenance.}
}

@article{bibianoCharacterizationDetectionImpact2020,
  title = {On the {{Characterization}}, {{Detection}} and {{Impact}} of {{Batch Refactoring}} in {{Practice}}},
  author = {Bibiano, Ana Carla and Garcia, Alessandro F.},
  date = {2020},
  doi = {10.5753/CBSOFT_ESTENDIDO.2020.14626},
  url = {https://www.semanticscholar.org/paper/cdc149f3af9166cea77da7e82b8a7a4b3147bab1},
  abstract = {Up to 60\% of the refactorings in software projects are constituted of a set of interrelated transformations, the so-called batches (or composite refactoring), rather than single transformations applied in isolation. However, a systematic characterization of batch characterization is missing, which hampers the elaboration of proper tooling support and empirical studies of how (batch) refactoring is applied in practice. This paper summarizes the research performed under the context of a Master’s dissertation, which aimed at taming the aforementioned problems. To the best of our knowledge, our research is the first work published that provides a conceptual foundation, detection support and an large impact analysis of batch refactoring on code maintainability. To this end, we performed two complementary empirical studies as well as designed a first heuristic aimed at explicitly detecting batch refactorings. Our first study consisted of a literature review that synthesizes the otherwise scattered, partial conceptualization of batch refactoring mentioned in 29 studies with different purposes. We identified and defined seven batch characteristics such as the scope and typology of batches, plus seven types of batch effect on software maintainability, including code smell removal. All batches’ characteristics and possible impacts were systematized in a conceptual framework, which assists, for instance, the proper design of batch refactoring studies and batch detection heuristics. We defined a new heuristic for batch detection, which made it possible to conduct a large study involving 4,607 batches discovered in 57 open and closed software projects. Amongst various findings, we reveal that most batches in practice occur entirely within one commit (93\%), affect multiple methods (90\%). Surprisingly, batches mostly end up introducing (51\%) or not removing (38\%) code smells. These findings contradict previous investigations limited to the impact analysis of each transformation in isolation. Our findings also enabled us to reveal beneficial or harmful patterns of batches that respectively induces the introduction or removal of certain code smells. These patterns: (i) were not previously documented even in Fowler’s refactoring catalog, and (ii) provide concrete guidance for both researchers, tool designers, and practitioners.}
}

@article{bibianoCharacterizationDetectionImpact2020a,
  title = {On the {{Characterization}}, {{Detection}} and {{Impact}} of {{Batch Refactoring}} in {{Practice}}},
  author = {Bibiano, Ana Carla and Garcia, Alessandro F.},
  date = {2020},
  doi = {10.5753/CBSOFT_ESTENDIDO.2020.14626},
  url = {https://www.semanticscholar.org/paper/cdc149f3af9166cea77da7e82b8a7a4b3147bab1},
  abstract = {Up to 60\% of the refactorings in software projects are constituted of a set of interrelated transformations, the so-called batches (or composite refactoring), rather than single transformations applied in isolation. However, a systematic characterization of batch characterization is missing, which hampers the elaboration of proper tooling support and empirical studies of how (batch) refactoring is applied in practice. This paper summarizes the research performed under the context of a Master’s dissertation, which aimed at taming the aforementioned problems. To the best of our knowledge, our research is the first work published that provides a conceptual foundation, detection support and an large impact analysis of batch refactoring on code maintainability. To this end, we performed two complementary empirical studies as well as designed a first heuristic aimed at explicitly detecting batch refactorings. Our first study consisted of a literature review that synthesizes the otherwise scattered, partial conceptualization of batch refactoring mentioned in 29 studies with different purposes. We identified and defined seven batch characteristics such as the scope and typology of batches, plus seven types of batch effect on software maintainability, including code smell removal. All batches’ characteristics and possible impacts were systematized in a conceptual framework, which assists, for instance, the proper design of batch refactoring studies and batch detection heuristics. We defined a new heuristic for batch detection, which made it possible to conduct a large study involving 4,607 batches discovered in 57 open and closed software projects. Amongst various findings, we reveal that most batches in practice occur entirely within one commit (93\%), affect multiple methods (90\%). Surprisingly, batches mostly end up introducing (51\%) or not removing (38\%) code smells. These findings contradict previous investigations limited to the impact analysis of each transformation in isolation. Our findings also enabled us to reveal beneficial or harmful patterns of batches that respectively induces the introduction or removal of certain code smells. These patterns: (i) were not previously documented even in Fowler’s refactoring catalog, and (ii) provide concrete guidance for both researchers, tool designers, and practitioners.}
}

@article{botelhoManyObjectiveEstimationDistributed2018,
  title = {A {{Many-Objective Estimation Distributed Algorithm Applied}} to {{Search Based Software Refactoring}}},
  author = {Botelho, Glauber and Bezerra, L. and Britto, André and Silva, Leila},
  date = {2018},
  journaltitle = {2018 IEEE Congress on Evolutionary Computation (CEC)},
  volume = {null},
  pages = {1--8},
  doi = {10.1109/CEC.2018.8477896},
  url = {https://www.semanticscholar.org/paper/17c60f27bf54da62e8d3525a3e2d76fcc82ee451},
  abstract = {Refactoring is a modification in the internal structure of software, in order to improve quality, understandability and maintainability, without changing its observable behavior. Search Based Software Refactoring (SBSR) deals with automatic software refactoring processes using optimization algorithms. In this context, here we investigate the problem of finding a sequence of refactorings that provides code improvement, according to software quality attributes, expressed by a combination of software metrics. There are multiple criteria to define the quality of a solution, therefore this problem is defined as a Many-Objective Combinatorial Optimization Problem. There is a lack of works that focus on Many-Objective Discrete Problems in SBSR. In this direction, this work proposes a Many-Objective Estimation Distributed Algorithm to find a sequence of refactorings on an object-oriented software. The algorithm explores archiving methods and probabilistic models. A set of experiments is performed, with the aim of investigating which is the best algorithm configuration, regarding the probabilistic model and selection procedure.}
}

@article{botelhoManyObjectiveEstimationDistributed2018a,
  title = {A {{Many-Objective Estimation Distributed Algorithm Applied}} to {{Search Based Software Refactoring}}},
  author = {Botelho, Glauber and Bezerra, L. and Britto, André and Silva, Leila},
  date = {2018},
  journaltitle = {2018 IEEE Congress on Evolutionary Computation (CEC)},
  volume = {null},
  pages = {1--8},
  doi = {10.1109/CEC.2018.8477896},
  url = {https://www.semanticscholar.org/paper/17c60f27bf54da62e8d3525a3e2d76fcc82ee451},
  abstract = {Refactoring is a modification in the internal structure of software, in order to improve quality, understandability and maintainability, without changing its observable behavior. Search Based Software Refactoring (SBSR) deals with automatic software refactoring processes using optimization algorithms. In this context, here we investigate the problem of finding a sequence of refactorings that provides code improvement, according to software quality attributes, expressed by a combination of software metrics. There are multiple criteria to define the quality of a solution, therefore this problem is defined as a Many-Objective Combinatorial Optimization Problem. There is a lack of works that focus on Many-Objective Discrete Problems in SBSR. In this direction, this work proposes a Many-Objective Estimation Distributed Algorithm to find a sequence of refactorings on an object-oriented software. The algorithm explores archiving methods and probabilistic models. A set of experiments is performed, with the aim of investigating which is the best algorithm configuration, regarding the probabilistic model and selection procedure.}
}

@article{bowesInconsistentMeasurementMessage2013,
  title = {The Inconsistent Measurement of {{Message Chains}}},
  author = {Bowes, David and Randall, D. and Hall, T.},
  date = {2013},
  journaltitle = {2013 4th International Workshop on Emerging Trends in Software Metrics (WETSoM)},
  volume = {null},
  pages = {62--68},
  doi = {10.1109/WETSoM.2013.6619338},
  url = {https://www.semanticscholar.org/paper/70249e737e7c1a68d36a42fbbd7f2dbee089d48e},
  abstract = {Fowler and Beck defined 22 Code Bad Smells. These smells are useful indicators of code that may need to be refactored. A range of tools have been developed that measure smells in Java code. We aim to compare the results of using two smell measurement tools (DECOR which is embedded in the Ptidej tool and Stench Blossom) on the same Java code (ArgoUML). This comparison identifies the code each tool identifies as containing Message Chains. We evaluate the results from these two tools using human judgment on the smells that the code contains. We look in detail at how and why the results differ. Our results show that each tool identified very different code as containing Message Chains. Stench Blossom identified very many more code instances of Message Chains than DECOR. We found three reasons why these discrepancies occurred. First there are significant differences in the definitions of Message Chains used by each tool. Second, the tools use very different measurement strategies. Third, the thresholds embedded in the tools vary. This measurement inconsistency is a problem to practitioners as they may be applying refactoring ineffectively. This inconsistency is also a problem for researchers as it undermines the reliability of making cross study comparisons and prevents mature knowledge the impact of smells being developed.}
}

@article{bowesInconsistentMeasurementMessage2013a,
  title = {The Inconsistent Measurement of {{Message Chains}}},
  author = {Bowes, David and Randall, D. and Hall, T.},
  date = {2013},
  journaltitle = {2013 4th International Workshop on Emerging Trends in Software Metrics (WETSoM)},
  volume = {null},
  pages = {62--68},
  doi = {10.1109/WETSoM.2013.6619338},
  url = {https://www.semanticscholar.org/paper/70249e737e7c1a68d36a42fbbd7f2dbee089d48e},
  abstract = {Fowler and Beck defined 22 Code Bad Smells. These smells are useful indicators of code that may need to be refactored. A range of tools have been developed that measure smells in Java code. We aim to compare the results of using two smell measurement tools (DECOR which is embedded in the Ptidej tool and Stench Blossom) on the same Java code (ArgoUML). This comparison identifies the code each tool identifies as containing Message Chains. We evaluate the results from these two tools using human judgment on the smells that the code contains. We look in detail at how and why the results differ. Our results show that each tool identified very different code as containing Message Chains. Stench Blossom identified very many more code instances of Message Chains than DECOR. We found three reasons why these discrepancies occurred. First there are significant differences in the definitions of Message Chains used by each tool. Second, the tools use very different measurement strategies. Third, the thresholds embedded in the tools vary. This measurement inconsistency is a problem to practitioners as they may be applying refactoring ineffectively. This inconsistency is also a problem for researchers as it undermines the reliability of making cross study comparisons and prevents mature knowledge the impact of smells being developed.}
}

@article{brownSorryBotherYou2019,
  title = {Sorry to {{Bother You}}: {{Designing Bots}} for {{Effective Recommendations}}},
  author = {Brown, Chris and Parnin, Chris},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {54--58},
  doi = {10.1109/BotSE.2019.00021},
  url = {https://www.semanticscholar.org/paper/be451315c182c5f5f78f8b4ac2f2bb9e3843d7ce},
  abstract = {Bots have been proposed as a way to encourage developer actions and support software development activities. Many bots make recommendations to users, however humans may find these recommendations ineffective or problematic. In this paper, we argue that while bots can help automate many tasks, ultimately bots still need to find ways to interact with humans and handle all of the associated social and cognitive problems entailed. To illustrate this problem, we performed a small study where we generated 52 pull requests making tool recommendation to developers. As a result, we only convinced two developers to accept the pull request, while receiving several forms of feedback on why the pull request was ineffective. We summarize this feedback and suggest design principles for bot recommendations, including how psychology frameworks, such as nudge theory, can be used to improve human-bot interactions.}
}

@article{brownSorryBotherYou2019a,
  title = {Sorry to {{Bother You}}: {{Designing Bots}} for {{Effective Recommendations}}},
  author = {Brown, Chris and Parnin, Chris},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {54--58},
  doi = {10.1109/BotSE.2019.00021},
  url = {https://www.semanticscholar.org/paper/be451315c182c5f5f78f8b4ac2f2bb9e3843d7ce},
  abstract = {Bots have been proposed as a way to encourage developer actions and support software development activities. Many bots make recommendations to users, however humans may find these recommendations ineffective or problematic. In this paper, we argue that while bots can help automate many tasks, ultimately bots still need to find ways to interact with humans and handle all of the associated social and cognitive problems entailed. To illustrate this problem, we performed a small study where we generated 52 pull requests making tool recommendation to developers. As a result, we only convinced two developers to accept the pull request, while receiving several forms of feedback on why the pull request was ineffective. We summarize this feedback and suggest design principles for bot recommendations, including how psychology frameworks, such as nudge theory, can be used to improve human-bot interactions.}
}

@article{carvalhoC3PRBotFixing2020,
  title = {C-{{3PR}}: {{A Bot}} for {{Fixing Static Analysis Violations}} via {{Pull Requests}}},
  author = {Carvalho, Antonio and Luz, W. and Marcilio, Diego and Bonifácio, R. and Pinto, G. and Canedo, E. D.},
  date = {2020},
  journaltitle = {2020 IEEE 27th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  volume = {null},
  pages = {161--171},
  doi = {10.1109/SANER48275.2020.9054842},
  url = {https://www.semanticscholar.org/paper/4ef0b456377aafb68884e643779dffb36b8e7cc1},
  abstract = {Static analysis tools are frequently used to detect common programming mistakes or bad practices. Yet, the existing literature reports that these tools are still underused in the industry, which is partly due to (1) the frequent high number of false positives generated, (2) the lack of automated repairing solutions, and (3) the possible mismatches between tools and workflows of development teams. In this study we explored the question: “How could a bot-based approach allow seamless integration of static analysis tools into developers' workflows?” To this end we introduce C-3PR, an event-based bot infrastructure that automatically proposes fixes to static analysis violations through pull requests (PRs). We have been using C-3PR in an industrial setting for a period of eight months. To evaluate C-3PR usefulness, we monitored its operation in response to 2179 commits to the code base of the tracked projects. The bot autonomously executed 201346 analyses, yielding 610 pull requests. Among them, 346 (57\%) were merged into the projects' code bases. We observed that, on average, these PRs are evaluated faster than general-purpose PRs (2.58 and 5.78 business days, respectively). Accepted transformations take even shorter time (1.56 days). Among the reasons for rejection, bugs in C-3PR and in the tools it uses are the most common ones. PRs that require the resolution of a merge conflict are almost always rejected as well. We also conducted a focus group to assess how C-3PR affected the development workflow. We observed that developers perceived C-3PR as efficient, reliable, and useful. For instance, the participants mentioned that, given the chance, they would keep using C-3PR. Our findings bring new evidence that a bot-based infrastructure could mitigate some challenges that hinder the wide adoption of static analysis tools.}
}

@article{carvalhoC3PRBotFixing2020a,
  title = {C-{{3PR}}: {{A Bot}} for {{Fixing Static Analysis Violations}} via {{Pull Requests}}},
  author = {Carvalho, Antonio and Luz, W. and Marcilio, Diego and Bonifácio, R. and Pinto, G. and Canedo, E. D.},
  date = {2020},
  journaltitle = {2020 IEEE 27th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  volume = {null},
  pages = {161--171},
  doi = {10.1109/SANER48275.2020.9054842},
  url = {https://www.semanticscholar.org/paper/4ef0b456377aafb68884e643779dffb36b8e7cc1},
  abstract = {Static analysis tools are frequently used to detect common programming mistakes or bad practices. Yet, the existing literature reports that these tools are still underused in the industry, which is partly due to (1) the frequent high number of false positives generated, (2) the lack of automated repairing solutions, and (3) the possible mismatches between tools and workflows of development teams. In this study we explored the question: “How could a bot-based approach allow seamless integration of static analysis tools into developers' workflows?” To this end we introduce C-3PR, an event-based bot infrastructure that automatically proposes fixes to static analysis violations through pull requests (PRs). We have been using C-3PR in an industrial setting for a period of eight months. To evaluate C-3PR usefulness, we monitored its operation in response to 2179 commits to the code base of the tracked projects. The bot autonomously executed 201346 analyses, yielding 610 pull requests. Among them, 346 (57\%) were merged into the projects' code bases. We observed that, on average, these PRs are evaluated faster than general-purpose PRs (2.58 and 5.78 business days, respectively). Accepted transformations take even shorter time (1.56 days). Among the reasons for rejection, bugs in C-3PR and in the tools it uses are the most common ones. PRs that require the resolution of a merge conflict are almost always rejected as well. We also conducted a focus group to assess how C-3PR affected the development workflow. We observed that developers perceived C-3PR as efficient, reliable, and useful. For instance, the participants mentioned that, given the chance, they would keep using C-3PR. Our findings bring new evidence that a bot-based infrastructure could mitigate some challenges that hinder the wide adoption of static analysis tools.}
}

@article{chenDetectingCodeSmells2016,
  title = {Detecting {{Code Smells}} in {{Python Programs}}},
  author = {Chen, Zhifei and Chen, Lin and Ma, Wanwangying and Xu, Baowen},
  date = {2016},
  journaltitle = {2016 International Conference on Software Analysis, Testing and Evolution (SATE)},
  volume = {null},
  pages = {18--23},
  doi = {10.1109/SATE.2016.10},
  url = {https://www.semanticscholar.org/paper/4d9b2f1939c1e697b1cef3fb4cc90ccb7172b7d1},
  abstract = {As a traditional dynamic language, Python is increasingly used in various software engineering tasks. However, due to its flexibility and dynamism, Python is a particularly challenging language to write code in and maintain. Consequently, Python programs contain code smells which indicate potential comprehension and maintenance problems. With the aim of supporting refactoring strategies to enhance maintainability, this paper describes how to detect code smells in Python programs. We introduce 11 Python smells and describe the detection strategy. We also implement a smell detection tool named Pysmell and use it to identify code smells in five real world Python systems. The results show that Pysmell can detect 285 code smell instances in total with the average precision of 97.7\%. It reveals that Large Class and Large Method are most prevalent. Our experiment also implies Python programs may be suffering code smells further.}
}

@article{chenDetectingCodeSmells2016a,
  title = {Detecting {{Code Smells}} in {{Python Programs}}},
  author = {Chen, Zhifei and Chen, Lin and Ma, Wanwangying and Xu, Baowen},
  date = {2016},
  journaltitle = {2016 International Conference on Software Analysis, Testing and Evolution (SATE)},
  volume = {null},
  pages = {18--23},
  doi = {10.1109/SATE.2016.10},
  url = {https://www.semanticscholar.org/paper/4d9b2f1939c1e697b1cef3fb4cc90ccb7172b7d1},
  abstract = {As a traditional dynamic language, Python is increasingly used in various software engineering tasks. However, due to its flexibility and dynamism, Python is a particularly challenging language to write code in and maintain. Consequently, Python programs contain code smells which indicate potential comprehension and maintenance problems. With the aim of supporting refactoring strategies to enhance maintainability, this paper describes how to detect code smells in Python programs. We introduce 11 Python smells and describe the detection strategy. We also implement a smell detection tool named Pysmell and use it to identify code smells in five real world Python systems. The results show that Pysmell can detect 285 code smell instances in total with the average precision of 97.7\%. It reveals that Large Class and Large Method are most prevalent. Our experiment also implies Python programs may be suffering code smells further.}
}

@article{chenDetectingCodeSmells2016b,
  title = {Detecting {{Code Smells}} in {{Python Programs}}},
  author = {Chen, Zhifei and Chen, Lin and Ma, Wanwangying and Xu, Baowen},
  date = {2016},
  journaltitle = {2016 International Conference on Software Analysis, Testing and Evolution (SATE)},
  volume = {null},
  pages = {18--23},
  doi = {10.1109/SATE.2016.10},
  url = {https://www.semanticscholar.org/paper/4d9b2f1939c1e697b1cef3fb4cc90ccb7172b7d1},
  abstract = {As a traditional dynamic language, Python is increasingly used in various software engineering tasks. However, due to its flexibility and dynamism, Python is a particularly challenging language to write code in and maintain. Consequently, Python programs contain code smells which indicate potential comprehension and maintenance problems. With the aim of supporting refactoring strategies to enhance maintainability, this paper describes how to detect code smells in Python programs. We introduce 11 Python smells and describe the detection strategy. We also implement a smell detection tool named Pysmell and use it to identify code smells in five real world Python systems. The results show that Pysmell can detect 285 code smell instances in total with the average precision of 97.7\%. It reveals that Large Class and Large Method are most prevalent. Our experiment also implies Python programs may be suffering code smells further.}
}

@article{chenUnderstandingMetricbasedDetectable2018,
  title = {Understanding Metric-Based Detectable Smells in {{Python}} Software: {{A}} Comparative Study},
  author = {Chen, Zhifei and Chen, Lin and Ma, Wanwangying and Zhou, Xiaoyu and Zhou, Yuming and Xu, Baowen},
  date = {2018},
  journaltitle = {Inf. Softw. Technol.},
  volume = {94},
  pages = {14--29},
  doi = {10.1016/J.INFSOF.2017.09.011},
  url = {https://www.semanticscholar.org/paper/f707407d6635aab658f3c6e67e67cf526be6b7f9},
  abstract = {S2 TL;DR: The findings reveal the key features of Python smells and also provide a guideline for the choice of detection strategy in detecting and analyzing Python smells.}
}

@article{chisalita-cretuEvolutionaryApproachStrategybased2014,
  title = {Evolutionary {{Approach}} for the {{Strategy-based Refactoring Selection}}},
  author = {Chisalita-Cretu, Camelia},
  date = {2014},
  url = {https://www.semanticscholar.org/paper/c5a98f7b3ea3d0646082e298a55f1df6cf1ac0ee},
  abstract = {In order to improve the internal structure of object-oriented software, refactoring has proved to be a feasible technique. Scheduling a refactoring process for a complex software system is a difficult task to do. Refactorings may be organized and prioritized based on goals established by the project management leadership, that shapes a refactoring strategy. The paper presents a multi-objective approach to the Strategy-based Refactoring Set Selection Problem (SRSSP) by treating the cost constraint and the refactoring impact as objectives of a weighted-sum fitness function. The first results of the proposed weighted objective genetic algorithm on a experimental didactic case study are presented and discussed.}
}

@article{chisalita-cretuEvolutionaryApproachStrategybased2014a,
  title = {Evolutionary {{Approach}} for the {{Strategy-based Refactoring Selection}}},
  author = {Chisalita-Cretu, Camelia},
  date = {2014},
  url = {https://www.semanticscholar.org/paper/c5a98f7b3ea3d0646082e298a55f1df6cf1ac0ee},
  abstract = {In order to improve the internal structure of object-oriented software, refactoring has proved to be a feasible technique. Scheduling a refactoring process for a complex software system is a difficult task to do. Refactorings may be organized and prioritized based on goals established by the project management leadership, that shapes a refactoring strategy. The paper presents a multi-objective approach to the Strategy-based Refactoring Set Selection Problem (SRSSP) by treating the cost constraint and the refactoring impact as objectives of a weighted-sum fitness function. The first results of the proposed weighted objective genetic algorithm on a experimental didactic case study are presented and discussed.}
}

@article{chisalita-cretuFirstResultsEvolutionary2014,
  title = {First {{Results}} on the {{Evolutionary Solution}} for the {{Strategy-}} Based {{Refactoring Set Selection Problem}}},
  author = {Chisalita-Cretu, Camelia},
  date = {2014},
  url = {https://www.semanticscholar.org/paper/1557dedba321bf38c15e4441c4d26f0012ed5ff2},
  abstract = {In order to improve the internal structure of object-oriented software, refactoring has proved to be a feasible technique. Scheduling a refactoring process for a complex software system is a difficult task to do. Refactorings may be organized and prioritized based on goals established by the project management leadership, that shapes a refactoring strategy. The paper presents a multi-objective approach to the Strategy-based Refactoring Set Selection Problem (SRSSP) by treating the cost constraint and the refactoring impact as objectives of a weighted-sum fitness function. The first results of the proposed weighted objective genetic algorithm on a experimental didactic case study are presented and discussed. Keywords— genetic algorithm, multi-objective optimization, refactoring, object-oriented programming, software engineering.}
}

@article{chisalita-cretuFirstResultsEvolutionary2014a,
  title = {First {{Results}} on the {{Evolutionary Solution}} for the {{Strategy-}} Based {{Refactoring Set Selection Problem}}},
  author = {Chisalita-Cretu, Camelia},
  date = {2014},
  url = {https://www.semanticscholar.org/paper/1557dedba321bf38c15e4441c4d26f0012ed5ff2},
  abstract = {In order to improve the internal structure of object-oriented software, refactoring has proved to be a feasible technique. Scheduling a refactoring process for a complex software system is a difficult task to do. Refactorings may be organized and prioritized based on goals established by the project management leadership, that shapes a refactoring strategy. The paper presents a multi-objective approach to the Strategy-based Refactoring Set Selection Problem (SRSSP) by treating the cost constraint and the refactoring impact as objectives of a weighted-sum fitness function. The first results of the proposed weighted objective genetic algorithm on a experimental didactic case study are presented and discussed. Keywords— genetic algorithm, multi-objective optimization, refactoring, object-oriented programming, software engineering.}
}

@article{chisalita-cretuMultiObjectiveRefactoringSet2011,
  title = {The {{Multi-Objective Refactoring Set Selection Problem}} - {{A Solution Representation Analysis}}},
  author = {Chisalita-Cretu, Camelia},
  date = {2011},
  doi = {10.5772/15975},
  url = {https://www.semanticscholar.org/paper/ff2de1d3395e17a34c8a0bbfd2d7dbcc4750bee2},
  abstract = {Software systems continually change as they evolve to reflect new requirements, but their internal structure tends to decay. Refactoring is a commonly accepted technique to improve the structure of object oriented software. Its aim is to reverse the decaying process in software quality by applying a series of small and behaviour-preserving transformations, each improving a certain aspect of the system (Fowler, 1999). The Multi-Objective Refactoring Set Selection Problem (MORSSP) is the identification problem of the set of refactorings that may be applied to the software entities, such that some specified constraints are kept and several objectives optimized. This work is organized as follows: The motivation and a possible working scenario for the proposed refactoring selection problem is presented by Section 2. Section 3 reminds the existing work related to the studied domain. The General Multi-Objective Refactoring Selection Problem is formally stated by Section 4. Section 5 defines the Multi-Objective Refactoring Set Selection Problem as a two conflicting objective problem. The case study used within the research is shortly reminded by Section 6. The evolutionary approach with a proposed weighted objective genetic algorithm and the different solution representations studied are addressed by Section 7. A proposed refactoring strategy together with the input data for the advanced genetic algorithms are presented by Section 8. The results of the pratical experiments for the entity based and refactoring based solution representations for the multi-objective approach are summarized and analyzed by Section 9. Section 10 lists the conclusions and future research direction of the presented work.}
}

@article{chisalita-cretuMultiObjectiveRefactoringSet2011a,
  title = {The {{Multi-Objective Refactoring Set Selection Problem}} - {{A Solution Representation Analysis}}},
  author = {Chisalita-Cretu, Camelia},
  date = {2011},
  doi = {10.5772/15975},
  url = {https://www.semanticscholar.org/paper/ff2de1d3395e17a34c8a0bbfd2d7dbcc4750bee2},
  abstract = {Software systems continually change as they evolve to reflect new requirements, but their internal structure tends to decay. Refactoring is a commonly accepted technique to improve the structure of object oriented software. Its aim is to reverse the decaying process in software quality by applying a series of small and behaviour-preserving transformations, each improving a certain aspect of the system (Fowler, 1999). The Multi-Objective Refactoring Set Selection Problem (MORSSP) is the identification problem of the set of refactorings that may be applied to the software entities, such that some specified constraints are kept and several objectives optimized. This work is organized as follows: The motivation and a possible working scenario for the proposed refactoring selection problem is presented by Section 2. Section 3 reminds the existing work related to the studied domain. The General Multi-Objective Refactoring Selection Problem is formally stated by Section 4. Section 5 defines the Multi-Objective Refactoring Set Selection Problem as a two conflicting objective problem. The case study used within the research is shortly reminded by Section 6. The evolutionary approach with a proposed weighted objective genetic algorithm and the different solution representations studied are addressed by Section 7. A proposed refactoring strategy together with the input data for the advanced genetic algorithms are presented by Section 8. The results of the pratical experiments for the entity based and refactoring based solution representations for the multi-objective approach are summarized and analyzed by Section 9. Section 10 lists the conclusions and future research direction of the presented work.}
}

@article{chisualitEntityRefactoringSet2009,
  title = {The {{Entity Refactoring Set Selection Problem}} - {{Practical Experiments}} for an {{Evolutionary Approach}}},
  author = {Chisùalit, Camelia},
  date = {2009},
  url = {https://www.semanticscholar.org/paper/f08639bb9b41b347aff52cf19a9ea9af711f2101},
  abstract = {Refactoring is a commonly accepted technique to improve the structure of object oriented software. The paper presents a multi-objective approach to the Entity Refactoring Set Selection Problem (ERSSP) by treating the cost constraint as an objective and combining it with the effect objective. The results of the proposed weighted objective genetic algorithm on a experimental didactic case study are presented and compared with other previous results.}
}

@article{chisualitEntityRefactoringSet2009a,
  title = {The {{Entity Refactoring Set Selection Problem}} - {{Practical Experiments}} for an {{Evolutionary Approach}}},
  author = {Chisùalit, Camelia},
  date = {2009},
  url = {https://www.semanticscholar.org/paper/f08639bb9b41b347aff52cf19a9ea9af711f2101},
  abstract = {Refactoring is a commonly accepted technique to improve the structure of object oriented software. The paper presents a multi-objective approach to the Entity Refactoring Set Selection Problem (ERSSP) by treating the cost constraint as an objective and combining it with the effect objective. The results of the proposed weighted objective genetic algorithm on a experimental didactic case study are presented and compared with other previous results.}
}

@article{cinneideExperimentalSearchbasedApproach2017,
  title = {An Experimental Search-Based Approach to Cohesion Metric Evaluation},
  author = {Cinnéide, M. O. and Moghadam, Iman Hemati and Harman, M. and Counsell, S. and Tratt, L.},
  date = {2017},
  journaltitle = {Empirical Software Engineering},
  volume = {22},
  pages = {292--329},
  doi = {10.1007/s10664-016-9427-7},
  url = {https://www.semanticscholar.org/paper/30825ca8896be1503a778e0ddde8392bad3ae9b0},
  abstract = {S2 TL;DR: This work proposes a novel experimental technique, based on search-based refactoring, to ‘animate’ metrics and observes their behaviour in a practical setting to promote metrics to the level of active, opinionated objects that can be compared experimentally to uncover where they conflict, and to understand better the underlying cause of the conflict.}
}

@article{cinneideExperimentalSearchbasedApproach2017a,
  title = {An Experimental Search-Based Approach to Cohesion Metric Evaluation},
  author = {Cinnéide, M. O. and Moghadam, Iman Hemati and Harman, M. and Counsell, S. and Tratt, L.},
  date = {2017},
  journaltitle = {Empirical Software Engineering},
  volume = {22},
  pages = {292--329},
  doi = {10.1007/s10664-016-9427-7},
  url = {https://www.semanticscholar.org/paper/30825ca8896be1503a778e0ddde8392bad3ae9b0},
  abstract = {S2 TL;DR: This work proposes a novel experimental technique, based on search-based refactoring, to ‘animate’ metrics and observes their behaviour in a practical setting to promote metrics to the level of active, opinionated objects that can be compared experimentally to uncover where they conflict, and to understand better the underlying cause of the conflict.}
}

@article{congEfficientFrameworkMultidimensional2012,
  title = {An {{Efficient Framework}} for {{Multi-dimensional Tuning}} of {{High Performance Computing Applications}}},
  author = {Cong, Guojing and Wen, H. and Chung, I. and Klepacki, D. and Murata, H. and Negishi, Yasushi},
  date = {2012},
  journaltitle = {2012 IEEE 26th International Parallel and Distributed Processing Symposium},
  volume = {null},
  pages = {1376--1387},
  doi = {10.1109/IPDPS.2012.124},
  url = {https://www.semanticscholar.org/paper/7d119c066a4e88af26518edfdd97639f6793b4cf},
  abstract = {Deploying an application onto a target platform for high performance oftentimes demands manual tuning by experts. As machine architecture gets increasingly complex, tuning becomes even more challenging and calls for systematic approaches. In our earlier work we presented a prototype that combines efficiently expert knowledge, static analysis, and runtime observation for bottleneck detection, and employs refactoring and compiler feedback for mitigation. In this study, we develop a software tool that facilitates \textbackslash emphfast searching of bottlenecks and effective mitigation of problems from major dimensions of computing (e.g., computation, communication, and I/O). The impact of our approach is demonstrated by the tuning of the LBMHD code and a Poisson solver code, representing traditional scientific codes, and a graph analysis code in UPC, representing emerging programming paradigms. In the experiments, our framework detects with a single run of the application intricate bottlenecks of memory access, I/O, and communication. Moreover, the automated solution implementation yields significant overall performance improvement on the target platforms. The improvement for LBMHD is up to 45\%, and the speedup for the UPC code is up to 5. These results suggest that our approach is a concrete step towards systematic tuning of high performance computing applications.}
}

@article{congEfficientFrameworkMultidimensional2012a,
  title = {An {{Efficient Framework}} for {{Multi-dimensional Tuning}} of {{High Performance Computing Applications}}},
  author = {Cong, Guojing and Wen, H. and Chung, I. and Klepacki, D. and Murata, H. and Negishi, Yasushi},
  date = {2012},
  journaltitle = {2012 IEEE 26th International Parallel and Distributed Processing Symposium},
  volume = {null},
  pages = {1376--1387},
  doi = {10.1109/IPDPS.2012.124},
  url = {https://www.semanticscholar.org/paper/7d119c066a4e88af26518edfdd97639f6793b4cf},
  abstract = {Deploying an application onto a target platform for high performance oftentimes demands manual tuning by experts. As machine architecture gets increasingly complex, tuning becomes even more challenging and calls for systematic approaches. In our earlier work we presented a prototype that combines efficiently expert knowledge, static analysis, and runtime observation for bottleneck detection, and employs refactoring and compiler feedback for mitigation. In this study, we develop a software tool that facilitates \textbackslash emphfast searching of bottlenecks and effective mitigation of problems from major dimensions of computing (e.g., computation, communication, and I/O). The impact of our approach is demonstrated by the tuning of the LBMHD code and a Poisson solver code, representing traditional scientific codes, and a graph analysis code in UPC, representing emerging programming paradigms. In the experiments, our framework detects with a single run of the application intricate bottlenecks of memory access, I/O, and communication. Moreover, the automated solution implementation yields significant overall performance improvement on the target platforms. The improvement for LBMHD is up to 45\%, and the speedup for the UPC code is up to 5. These results suggest that our approach is a concrete step towards systematic tuning of high performance computing applications.}
}

@article{counsellAreRefactoringsAttached2014,
  title = {Are {{Some Refactorings Attached}} to {{Fault-Prone Classes}} and {{Others}} to {{Fault-Free Classes}}?},
  author = {Counsell, S. and Swift, S. and Murgia, Alessandro and Tonelli, R. and Marchesi, M. and Concas, G.},
  date = {2014},
  doi = {10.1007/978-3-319-14358-3_12},
  url = {https://www.semanticscholar.org/paper/d6239417d7061e56a37c547c7a6dde7029e36d33},
  abstract = {S2 TL;DR: Results showed that refactorings applied to highly fault-prone classes differed significantly from those applied to fault-free classes, in particular related to the ‘rename method’ refactoring.}
}

@article{counsellAreRefactoringsAttached2014a,
  title = {Are {{Some Refactorings Attached}} to {{Fault-Prone Classes}} and {{Others}} to {{Fault-Free Classes}}?},
  author = {Counsell, S. and Swift, S. and Murgia, Alessandro and Tonelli, R. and Marchesi, M. and Concas, G.},
  date = {2014},
  doi = {10.1007/978-3-319-14358-3_12},
  url = {https://www.semanticscholar.org/paper/d6239417d7061e56a37c547c7a6dde7029e36d33},
  abstract = {S2 TL;DR: Results showed that refactorings applied to highly fault-prone classes differed significantly from those applied to fault-free classes, in particular related to the ‘rename method’ refactoring.}
}

@article{counsellMetaanalysisApproachRefactoring2007,
  title = {A {{Meta-analysis Approach}} to {{Refactoring}} and {{XP}}},
  author = {Counsell, S. and Hierons, R. and Loizou, G.},
  date = {2007},
  journaltitle = {2007 IEEE/ACS International Conference on Computer Systems and Applications},
  volume = {null},
  pages = {67--75},
  doi = {10.1109/AICCSA.2007.370866},
  url = {https://www.semanticscholar.org/paper/fe988451c47b52b8cf1e72de99ca976f01f7c69d},
  abstract = {The mechanics of seventy-two different Java refactorings are described fully in Fowler's text. In the same text, Fowler describes seven categories of refactoring, into which each of the seventy-two refactorings can be placed. A current research problem in the refactoring and XP community is assessing the likely time and testing effort for each refactoring, since any single refactoring may use any number of other refactorings as part of its mechanics and, in turn, can be used by many other refactorings. In this paper, we draw on a dependency analysis carried out as part of our research in which we identify the 'Use' and 'Used By' relationships of refactorings in all seven categories. We offer reasons why refactorings in the 'Dealing with Generalisation' category seem to embrace two distinct refactoring sub-categories and how refactorings in the 'Moving Features between Objects' category also exhibit specific characteristics. In a wider sense, our meta-analysis provides a developer with concrete guidelines on which refactorings, due to their explicit dependencies, will prove problematic from an effort and testing perspective.}
}

@article{counsellNeedFollowChains2008,
  title = {Is the Need to Follow Chains a Possible Deterrent to Certain Refactorings and an Inducement to Others?},
  author = {Counsell, S.},
  date = {2008},
  journaltitle = {2008 Second International Conference on Research Challenges in Information Science},
  volume = {null},
  pages = {111--122},
  doi = {10.1109/RCIS.2008.4632099},
  url = {https://www.semanticscholar.org/paper/8ae1f24f5d4e9e9e58e6e819b664b31af991572c},
  abstract = {A current and difficult challenge in the software engineering arena is assessment of code smells and subsequent re-engineering decisions. The mechanics of seventy-two individual, object-oriented refactorings are specified in the seminal text by Fowler, providing the steps that need to be undertaken to complete each. While it is relatively easy to identify dasiarelatedpsila refactorings, i.e., those that each refactoring itself directly uses as part of those mechanics, what is not so clear is the chain of required refactorings that may emerge due to these indirect (and composite) relationships. In this paper, we investigate the characteristics of fourteen of the seventy-two refactorings, identifying, for each, its related refactorings and the implications this may have for the overall time and effort required to carry out each. We supported our analysis with data from a previous empirical analysis. The key result was that refactorings inducing long chains tended to be utilized less by developers than refactorings with short chains, suggesting that complexity given by long chains may be a real consideration prior to refactoring; empirically, long chains were found to be composed of sets of smaller, inter-related refactorings. On a general note, understanding the composition of refactorings is recognized as an emerging yet under-researched area but has significant implications for the amount of effort that a developer might have to invest in any single dasiachangepsila to a system involving refactoring.}
}

@article{counsellTestTaxonomyApplied2007,
  title = {A {{Test Taxonomy Applied}} to the {{Mechanics}} of {{Java Refactorings}}},
  author = {Counsell, S. and Swift, S. and Hierons, R.},
  date = {2007},
  doi = {10.1007/978-1-4020-8741-7_88},
  url = {https://www.semanticscholar.org/paper/6988e5700cdd504a31edf1552b8244fe6d2c4fe6},
  abstract = {S2 TL;DR: The automated production of all interactions between the mechanics of seventy-two refactorings proposed by Fowler in the form of chains is described, suggesting a far deeper complexity to refactoring inter-relationships than first envisaged.}
}

@article{derezinskaStructureDrivenProcessAutomated2017,
  title = {A {{Structure-Driven Process}} of {{Automated Refactoring}} to {{Design Patterns}}},
  author = {Derezińska, A.},
  date = {2017},
  doi = {10.1007/978-3-319-67229-8_4},
  url = {https://www.semanticscholar.org/paper/696c1a1df450499cf91486e0c79bf51632fca12a},
  abstract = {S2 TL;DR: This paper presents a process that automates this kind of refactoring based on a structural code analysis aimed at design pattern relevance and consists of three main phases: code analysis, determination of aRefactoring range, and realization of code restructuring.}
}

@article{derezinskaStructureDrivenProcessAutomated2017a,
  title = {A {{Structure-Driven Process}} of {{Automated Refactoring}} to {{Design Patterns}}},
  author = {Derezińska, A.},
  date = {2017},
  doi = {10.1007/978-3-319-67229-8_4},
  url = {https://www.semanticscholar.org/paper/696c1a1df450499cf91486e0c79bf51632fca12a},
  abstract = {S2 TL;DR: This paper presents a process that automates this kind of refactoring based on a structural code analysis aimed at design pattern relevance and consists of three main phases: code analysis, determination of aRefactoring range, and realization of code restructuring.}
}

@article{deyDetectingCharacterizingBots2020,
  title = {Detecting and {{Characterizing Bots}} That {{Commit Code}}},
  author = {Dey, Tapajit and Mousavi, Sara and Ponce, Eduardo and Fry, Tanner and Vasilescu, Bogdan and Filippova, Anna and Mockus, A.},
  date = {2020},
  journaltitle = {2020 IEEE/ACM 17th International Conference on Mining Software Repositories (MSR)},
  volume = {null},
  pages = {209--219},
  doi = {10.1145/3379597.3387478},
  url = {https://www.semanticscholar.org/paper/a743e4b5cafbe988a02be3f981e2724963ee4ef2},
  abstract = {Background: Some developer activity traditionally performed manually, such as making code commits, opening, managing, or closing issues is increasingly subject to automation in many OSS projects. Specifically, such activity is often performed by tools that react to events or run at specific times. We refer to such automation tools as bots and, in many software mining scenarios related to developer productivity or code quality, it is desirable to identify bots in order to separate their actions from actions of individuals. Aim: Find an automated way of identifying bots and code committed by these bots, and to characterize the types of bots based on their activity patterns. Method and Result: We propose BIMAN, a systematic approach to detect bots using author names, commit messages, files modified by the commit, and projects associated with the commits. For our test data, the value for AUC-ROC was 0.9. We also characterized these bots based on the time patterns of their code commits and the types of files modified, and found that they primarily work with documentation files and web pages, and these files are most prevalent in HTML and JavaScript ecosystems. We have compiled a shareable dataset containing detailed information about 461 bots we found (all of which have more than 1000 commits) and 13,762,430 commits they created.}
}

@article{deyDetectingCharacterizingBots2020a,
  title = {Detecting and {{Characterizing Bots}} That {{Commit Code}}},
  author = {Dey, Tapajit and Mousavi, Sara and Ponce, Eduardo and Fry, Tanner and Vasilescu, Bogdan and Filippova, Anna and Mockus, A.},
  date = {2020},
  journaltitle = {2020 IEEE/ACM 17th International Conference on Mining Software Repositories (MSR)},
  volume = {null},
  pages = {209--219},
  doi = {10.1145/3379597.3387478},
  url = {https://www.semanticscholar.org/paper/a743e4b5cafbe988a02be3f981e2724963ee4ef2},
  abstract = {Background: Some developer activity traditionally performed manually, such as making code commits, opening, managing, or closing issues is increasingly subject to automation in many OSS projects. Specifically, such activity is often performed by tools that react to events or run at specific times. We refer to such automation tools as bots and, in many software mining scenarios related to developer productivity or code quality, it is desirable to identify bots in order to separate their actions from actions of individuals. Aim: Find an automated way of identifying bots and code committed by these bots, and to characterize the types of bots based on their activity patterns. Method and Result: We propose BIMAN, a systematic approach to detect bots using author names, commit messages, files modified by the commit, and projects associated with the commits. For our test data, the value for AUC-ROC was 0.9. We also characterized these bots based on the time patterns of their code commits and the types of files modified, and found that they primarily work with documentation files and web pages, and these files are most prevalent in HTML and JavaScript ecosystems. We have compiled a shareable dataset containing detailed information about 461 bots we found (all of which have more than 1000 commits) and 13,762,430 commits they created.}
}

@article{disneySweetenYourJavaScript2014,
  title = {Sweeten Your {{JavaScript}}: Hygienic Macros for {{ES5}}},
  author = {Disney, Tim and Faubion, Nathan and Herman, David and Flanagan, C.},
  date = {2014},
  journaltitle = {Proceedings of the 10th ACM Symposium on Dynamic languages},
  volume = {null},
  pages = {null},
  doi = {10.1145/2661088.2661097},
  url = {https://www.semanticscholar.org/paper/11ae5efd293c2815f3af7be3e7270da40b869eae},
  abstract = {Lisp and Scheme have demonstrated the power of macros to enable programmers to evolve and craft languages. In languages with more complex syntax, macros have had less success. In part, this has been due to the difficulty in building expressive hygienic macro systems for such languages. JavaScript in particular presents unique challenges for macro systems due to ambiguities in the lexing stage that force the JavaScript lexer and parser to be intertwined. In this paper we present a novel solution to the lexing ambiguity of JavaScript that enables us to cleanly separate the JavaScript lexer and parser by recording enough history during lexing to resolve ambiguities. We give an algorithm for this solution along with a proof that it does in fact correctly resolve ambiguities in the language. Though the algorithm and proof we present is specific to JavaScript, the general technique can be applied to other languages with ambiguous grammars. With lexer and parser separated, we then implement an expressive hygienic macro system for JavaScript called sweet.js.}
}

@article{disneySweetenYourJavaScript2014a,
  title = {Sweeten Your {{JavaScript}}: Hygienic Macros for {{ES5}}},
  author = {Disney, Tim and Faubion, Nathan and Herman, David and Flanagan, C.},
  date = {2014},
  journaltitle = {Proceedings of the 10th ACM Symposium on Dynamic languages},
  volume = {null},
  pages = {null},
  doi = {10.1145/2661088.2661097},
  url = {https://www.semanticscholar.org/paper/11ae5efd293c2815f3af7be3e7270da40b869eae},
  abstract = {Lisp and Scheme have demonstrated the power of macros to enable programmers to evolve and craft languages. In languages with more complex syntax, macros have had less success. In part, this has been due to the difficulty in building expressive hygienic macro systems for such languages. JavaScript in particular presents unique challenges for macro systems due to ambiguities in the lexing stage that force the JavaScript lexer and parser to be intertwined. In this paper we present a novel solution to the lexing ambiguity of JavaScript that enables us to cleanly separate the JavaScript lexer and parser by recording enough history during lexing to resolve ambiguities. We give an algorithm for this solution along with a proof that it does in fact correctly resolve ambiguities in the language. Though the algorithm and proof we present is specific to JavaScript, the general technique can be applied to other languages with ambiguous grammars. With lexer and parser separated, we then implement an expressive hygienic macro system for JavaScript called sweet.js.}
}

@article{dongSelfcollaborationCodeGeneration2023,
  title = {Self-Collaboration {{Code Generation}} via {{ChatGPT}}},
  author = {Dong, Yihong and Jiang, Xue and Jin, Zhi and Li, Ge},
  date = {2023},
  journaltitle = {ArXiv},
  volume = {abs/2304.07590},
  url = {https://api.semanticscholar.org/CorpusID:258179537}
}

@article{dongSelfcollaborationCodeGeneration2023a,
  title = {Self-Collaboration {{Code Generation}} via {{ChatGPT}}},
  author = {Dong, Yihong and Jiang, Xue and Jin, Zhi and Li, Ge},
  date = {2023},
  journaltitle = {ArXiv},
  volume = {abs/2304.07590},
  url = {https://api.semanticscholar.org/CorpusID:258179537}
}

@article{doraIdentifyingRefactoringOpportunity2013,
  title = {Identifying {{Refactoring Opportunity}} in an {{Application}}: {{A Metric Based Approach}}},
  author = {Dora, Syamala Kumari and Kanhar, Debananda},
  date = {2013},
  doi = {10.1007/978-81-322-0740-5_14},
  url = {https://www.semanticscholar.org/paper/0dbe3ed8489e7020697cedb63f21a6a72e7187ab},
  abstract = {S2 TL;DR: A set of program restructuring operations (refactorings) that support the design, evolution and reuse of java application, including Long parameter list and Shotgun surgery most complex refactorings are defined.}
}

@article{doraIdentifyingRefactoringOpportunity2013a,
  title = {Identifying {{Refactoring Opportunity}} in an {{Application}}: {{A Metric Based Approach}}},
  author = {Dora, Syamala Kumari and Kanhar, Debananda},
  date = {2013},
  doi = {10.1007/978-81-322-0740-5_14},
  url = {https://www.semanticscholar.org/paper/0dbe3ed8489e7020697cedb63f21a6a72e7187ab},
  abstract = {S2 TL;DR: A set of program restructuring operations (refactorings) that support the design, evolution and reuse of java application, including Long parameter list and Shotgun surgery most complex refactorings are defined.}
}

@article{erlenhovCurrentFutureBots2019,
  title = {Current and {{Future Bots}} in {{Software Development}}},
  author = {Erlenhov, Linda and Neto, F. D. O. and Scandariato, R. and Leitner, P.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {7--11},
  doi = {10.1109/BotSE.2019.00009},
  url = {https://www.semanticscholar.org/paper/765734968508759ba69562a46d1c5746cf369e48},
  abstract = {Bots that support software development ("DevBots") are seen as a promising approach to deal with the ever-increasing complexity of modern software engineering and development. Existing DevBots are already able to relieve developers from routine tasks such as building project images or keeping dependencies up-to-date. However, advances in machine learning and artificial intelligence hold the promise of future, significantly more advanced, DevBots. In this paper, we introduce the terminology of contemporary and ideal DevBots. Contemporary DevBots represent the current state of practice, which we characterise using a facet-based taxonomy. We exemplify this taxonomy using 11 existing, industrial-strength bots. We further provide a vision and definition of future (ideal) DevBots, which are not only autonomous, but also adaptive, as well as technically and socially competent. These properties may allow ideal DevBots to act more akin to artificial team mates than simple development tools.}
}

@article{erlenhovCurrentFutureBots2019a,
  title = {Current and {{Future Bots}} in {{Software Development}}},
  author = {Erlenhov, Linda and Neto, F. D. O. and Scandariato, R. and Leitner, P.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {7--11},
  doi = {10.1109/BotSE.2019.00009},
  url = {https://www.semanticscholar.org/paper/765734968508759ba69562a46d1c5746cf369e48},
  abstract = {Bots that support software development ("DevBots") are seen as a promising approach to deal with the ever-increasing complexity of modern software engineering and development. Existing DevBots are already able to relieve developers from routine tasks such as building project images or keeping dependencies up-to-date. However, advances in machine learning and artificial intelligence hold the promise of future, significantly more advanced, DevBots. In this paper, we introduce the terminology of contemporary and ideal DevBots. Contemporary DevBots represent the current state of practice, which we characterise using a facet-based taxonomy. We exemplify this taxonomy using 11 existing, industrial-strength bots. We further provide a vision and definition of future (ideal) DevBots, which are not only autonomous, but also adaptive, as well as technically and socially competent. These properties may allow ideal DevBots to act more akin to artificial team mates than simple development tools.}
}

@article{erlenhovEmpiricalStudyBots2020,
  title = {An Empirical Study of Bots in Software Development: Characteristics and Challenges from a Practitioner’s Perspective},
  author = {Erlenhov, Linda and Neto, F. D. O. and Leitner, P.},
  date = {2020},
  journaltitle = {Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/3368089.3409680},
  url = {https://www.semanticscholar.org/paper/a39c4f449df5ad757c9a348d80700959efa96485},
  abstract = {Software engineering bots – automated tools that handle tedious tasks – are increasingly used by industrial and open source projects to improve developer productivity. Current research in this area is held back by a lack of consensus of what software engineering bots (DevBots) actually are, what characteristics distinguish them from other tools, and what benefits and challenges are associated with DevBot usage. In this paper we report on a mixed-method empirical study of DevBot usage in industrial practice. We report on findings from interviewing 21 and surveying a total of 111 developers. We identify three different personas among DevBot users (focusing on autonomy, chat interfaces, and “smartness”), each with different definitions of what a DevBot is, why developers use them, and what they struggle with.We conclude that future DevBot research should situate their work within our framework, to clearly identify what type of bot the work targets, and what advantages practitioners can expect. Further, we find that there currently is a lack of general purpose “smart” bots that go beyond simple automation tools or chat interfaces. This is problematic, as we have seen that such bots, if available, can have a transformative effect on the projects that use them.}
}

@article{erlenhovEmpiricalStudyBots2020a,
  title = {An Empirical Study of Bots in Software Development: Characteristics and Challenges from a Practitioner’s Perspective},
  author = {Erlenhov, Linda and Neto, F. D. O. and Leitner, P.},
  date = {2020},
  journaltitle = {Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/3368089.3409680},
  url = {https://www.semanticscholar.org/paper/a39c4f449df5ad757c9a348d80700959efa96485},
  abstract = {Software engineering bots – automated tools that handle tedious tasks – are increasingly used by industrial and open source projects to improve developer productivity. Current research in this area is held back by a lack of consensus of what software engineering bots (DevBots) actually are, what characteristics distinguish them from other tools, and what benefits and challenges are associated with DevBot usage. In this paper we report on a mixed-method empirical study of DevBot usage in industrial practice. We report on findings from interviewing 21 and surveying a total of 111 developers. We identify three different personas among DevBot users (focusing on autonomy, chat interfaces, and “smartness”), each with different definitions of what a DevBot is, why developers use them, and what they struggle with.We conclude that future DevBot research should situate their work within our framework, to clearly identify what type of bot the work targets, and what advantages practitioners can expect. Further, we find that there currently is a lack of general purpose “smart” bots that go beyond simple automation tools or chat interfaces. This is problematic, as we have seen that such bots, if available, can have a transformative effect on the projects that use them.}
}

@article{esImplementingPerformantScheme2017,
  title = {Implementing a Performant Scheme Interpreter for the Web in Asm.Js},
  author = {Es, Noah Van and Stiévenart, Quentin and Nicolay, Jens and D'Hondt, T. and Roover, Coen De},
  date = {2017},
  journaltitle = {Comput. Lang. Syst. Struct.},
  volume = {49},
  pages = {62--81},
  doi = {10.1016/j.cl.2017.02.002},
  url = {https://www.semanticscholar.org/paper/8da9b471b4c8bd87c3719674b59463cc6f873fea},
  abstract = {S2 TL;DR: This paper presents the implementation of an efficient interpreter for a Scheme-like language using manually written asm.js code, and proposes a macro system to solve the challenges it encounter.}
}

@article{esImplementingPerformantScheme2017a,
  title = {Implementing a Performant Scheme Interpreter for the Web in Asm.Js},
  author = {Es, Noah Van and Stiévenart, Quentin and Nicolay, Jens and D'Hondt, T. and Roover, Coen De},
  date = {2017},
  journaltitle = {Comput. Lang. Syst. Struct.},
  volume = {49},
  pages = {62--81},
  doi = {10.1016/j.cl.2017.02.002},
  url = {https://www.semanticscholar.org/paper/8da9b471b4c8bd87c3719674b59463cc6f873fea},
  abstract = {S2 TL;DR: This paper presents the implementation of an efficient interpreter for a Scheme-like language using manually written asm.js code, and proposes a macro system to solve the challenges it encounter.}
}

@article{fontanaAutomaticDetectionBad2012,
  title = {Automatic Detection of Bad Smells in Code: {{An}} Experimental Assessment},
  author = {Fontana, F. and Braione, Pietro and Zanoni, M.},
  date = {2012},
  journaltitle = {J. Object Technol.},
  volume = {11},
  pages = {5: 1-38},
  doi = {10.5381/JOT.2012.11.2.A5},
  url = {https://www.semanticscholar.org/paper/5b9f1e1c092a9683a767f86a1169a08e8e3e6a09},
  abstract = {Code smells are structural characteristics of software that may indicate a code or design problem that makes software hard to evolve and maintain, and may trigger refactoring of code. Recent research is active in defining automatic detection tools to help humans in finding smells when code size becomes unmanageable for manual review. Since the definitions of code smells are informal and subjective, assessing how effective code smell detection tools are is both important and hard to achieve. This paper reviews the current panorama of the tools for automatic code smell detection. It defines research questions about the consistency of their responses, their ability to expose the regions of code most affected by structural decay, and the relevance of their responses with respect to future software evolution. It gives answers to them by analyzing the output of four representative code smell detectors applied to six different versions of GanttProject, an open source system written in Java. The results of these experiments cast light on what current code smell detection tools are able to do and what the relevant areas for further improvement are.}
}

@article{fontanaComparingExperimentingMachine2016,
  title = {Comparing and Experimenting Machine Learning Techniques for Code Smell Detection},
  author = {Fontana, F. and Mäntylä, M. and Zanoni, M. and Marino, A.},
  date = {2016},
  journaltitle = {Empirical Software Engineering},
  volume = {21},
  pages = {1143--1191},
  doi = {10.1007/s10664-015-9378-4},
  url = {https://www.semanticscholar.org/paper/1aa955560242f32983cacb6c7f1ea9d9b36aa96a},
  abstract = {S2 TL;DR: The largest experiment of applying machine learning algorithms to code smells to the best of the authors' knowledge concludes that the application of machine learning to the detection of these code smells can provide high accuracy ({$>$}96 \%), and only a hundred training examples are needed to reach at least 95 \% accuracy.}
}

@article{fontanaImpactRefactoringQuality2011,
  title = {Impact of Refactoring on Quality Code Evaluation},
  author = {Fontana, F. and Spinelli, Stefano},
  date = {2011},
  doi = {10.1145/1984732.1984741},
  url = {https://www.semanticscholar.org/paper/62a512ec29121691ac4a4191c63a83b72fcc0714},
  abstract = {Code smells are characteristics of the software that may indicate a code or design problem that can make software hard to understand, to evolve and maintain. Detecting code smells in the code and consequently applying the right refactoring steps, when necessary, is very important for improving the quality of the code. In this paper, according to well known metrics proposed to evaluate the code and design quality of a system, we analyze the impact of refactoring, applied to remove code smells, on the quality evaluation of the system.}
}

@article{gaoCrashavoidingProgramRepair2019,
  title = {Crash-Avoiding Program Repair},
  author = {Gao, Xiang and Mechtaev, Sergey and Roychoudhury, Abhik},
  date = {2019},
  journaltitle = {Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  volume = {null},
  pages = {null},
  doi = {10.1145/3293882.3330558},
  url = {https://www.semanticscholar.org/paper/c723c60a6fee94ca2b557ef77ad1660efc7d2b24},
  abstract = {Existing program repair systems modify a buggy program so that the modified program passes given tests. The repaired program may not satisfy even the most basic notion of correctness, namely crash-freedom. In other words, repair tools might generate patches which over-fit the test data driving the repair, and the automatically repaired programs may even introduce crashes or vulnerabilities. We propose an integrated approach for detecting and discarding crashing patches. Our approach fuses test and patch generation into a single process, in which patches are generated with the objective of passing existing tests, and new tests are generated with the objective of filtering out over-fitted patches by distinguishing candidate patches in terms of behavior. We use crash-freedom as the oracle to discard patch candidates which crash on the new tests. In its core, our approach defines a grey-box fuzzing strategy that gives higher priority to new tests that separate patches behaving equivalently on existing tests. This test generation strategy identifies semantic differences between patch candidates, and reduces over-fitting in program repair. We evaluated our approach on real-world vulnerabilities and open-source subjects from the Google OSS-Fuzz infrastructure. We found that our tool Fix2Fit (implementing patch space directed test generation), produces crash-avoiding patches. While we do not give formal guarantees about crash-freedom, cross-validation with fuzzing tools and their sanitizers provides greater confidence about the crash-freedom of our suggested patches.}
}

@article{gaoCrashavoidingProgramRepair2019a,
  title = {Crash-Avoiding Program Repair},
  author = {Gao, Xiang and Mechtaev, Sergey and Roychoudhury, Abhik},
  date = {2019},
  journaltitle = {Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  volume = {null},
  pages = {null},
  doi = {10.1145/3293882.3330558},
  url = {https://www.semanticscholar.org/paper/c723c60a6fee94ca2b557ef77ad1660efc7d2b24},
  abstract = {Existing program repair systems modify a buggy program so that the modified program passes given tests. The repaired program may not satisfy even the most basic notion of correctness, namely crash-freedom. In other words, repair tools might generate patches which over-fit the test data driving the repair, and the automatically repaired programs may even introduce crashes or vulnerabilities. We propose an integrated approach for detecting and discarding crashing patches. Our approach fuses test and patch generation into a single process, in which patches are generated with the objective of passing existing tests, and new tests are generated with the objective of filtering out over-fitted patches by distinguishing candidate patches in terms of behavior. We use crash-freedom as the oracle to discard patch candidates which crash on the new tests. In its core, our approach defines a grey-box fuzzing strategy that gives higher priority to new tests that separate patches behaving equivalently on existing tests. This test generation strategy identifies semantic differences between patch candidates, and reduces over-fitting in program repair. We evaluated our approach on real-world vulnerabilities and open-source subjects from the Google OSS-Fuzz infrastructure. We found that our tool Fix2Fit (implementing patch space directed test generation), produces crash-avoiding patches. While we do not give formal guarantees about crash-freedom, cross-validation with fuzzing tools and their sanitizers provides greater confidence about the crash-freedom of our suggested patches.}
}

@article{ghannemModelRefactoringExample2018,
  title = {Model Refactoring by Example: {{A}} Multi‐objective Search Based Software Engineering Approach},
  author = {Ghannem, Adnane and Kessentini, M. and Hamdi, M. and El-Boussaidi, Ghizlane},
  date = {2018},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {30},
  pages = {null},
  doi = {10.1002/smr.1916},
  url = {https://www.semanticscholar.org/paper/ebdd4960e79988c85d7d6d59d900b0078a40ece8},
  abstract = {Declarative rules are frequently used in model refactoring in order to detect refactoring opportunities and to apply the appropriate ones. However, a large number of rules is required to obtain a complete specification of refactoring opportunities. Companies usually have accumulated examples of refactorings from past maintenance experiences. Based on these observations, we consider the model refactoring problem as a multi objective problem by suggesting refactoring sequences that aim to maximize both structural and textual similarity between a given model (the model to be refactored) and a set of poorly designed models in the base of examples (models that have undergone some refactorings) and minimize the structural similarity between a given model and a set of well‐designed models in the base of examples (models that do not need any refactoring). To this end, we use the Non‐dominated Sorting Genetic Algorithm (NSGA‐II) to find a set of representative Pareto optimal solutions that present the best trade‐off between structural and textual similarities of models. The validation results, based on 8 real world models taken from open‐source projects, confirm the effectiveness of our approach, yielding refactoring recommendations with an average correctness of over 80\%. In addition, our approach outperforms 5 of the state‐of‐the‐art refactoring approaches.}
}

@article{ghannemModelRefactoringExample2018a,
  title = {Model Refactoring by Example: {{A}} Multi‐objective Search Based Software Engineering Approach},
  author = {Ghannem, Adnane and Kessentini, M. and Hamdi, M. and El-Boussaidi, Ghizlane},
  date = {2018},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {30},
  pages = {null},
  doi = {10.1002/smr.1916},
  url = {https://www.semanticscholar.org/paper/ebdd4960e79988c85d7d6d59d900b0078a40ece8},
  abstract = {Declarative rules are frequently used in model refactoring in order to detect refactoring opportunities and to apply the appropriate ones. However, a large number of rules is required to obtain a complete specification of refactoring opportunities. Companies usually have accumulated examples of refactorings from past maintenance experiences. Based on these observations, we consider the model refactoring problem as a multi objective problem by suggesting refactoring sequences that aim to maximize both structural and textual similarity between a given model (the model to be refactored) and a set of poorly designed models in the base of examples (models that have undergone some refactorings) and minimize the structural similarity between a given model and a set of well‐designed models in the base of examples (models that do not need any refactoring). To this end, we use the Non‐dominated Sorting Genetic Algorithm (NSGA‐II) to find a set of representative Pareto optimal solutions that present the best trade‐off between structural and textual similarities of models. The validation results, based on 8 real world models taken from open‐source projects, confirm the effectiveness of our approach, yielding refactoring recommendations with an average correctness of over 80\%. In addition, our approach outperforms 5 of the state‐of‐the‐art refactoring approaches.}
}

@article{ghannemModelRefactoringUsing2014,
  title = {Model Refactoring Using Examples: A Search‐based Approach},
  author = {Ghannem, Adnane and El-Boussaidi, Ghizlane and Kessentini, M.},
  date = {2014},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {26},
  pages = {null},
  doi = {10.1002/smr.1644},
  url = {https://www.semanticscholar.org/paper/9b49b917a0a10d21ecffac0103b935f2263002f3},
  abstract = {One of the important challenges in model‐driven engineering is how to improve the quality of the models' design in order to help designers understand them. Refactoring represents an efficient technique to improve the quality of a design while preserving its behavior. Most of existing work on model refactoring relies on declarative rules to detect refactoring opportunities and to apply the appropriate refactorings. However, a complete specification of refactoring opportunities requires a huge number of rules. In this paper, we consider the refactoring mechanism as a combinatorial optimization problem where the goal is to find good refactoring suggestions starting from a small set of refactoring examples applied to similar contexts. Our approach, named model refactoring by example, takes as input an initial model to refactor, a set of structural metrics calculated on both initial model and models in the base of examples, and a base of refactoring examples extracted from different software systems and generates as output a sequence of refactorings. A solution is defined as a combination of refactoring operations that should maximize as much as possible the structural similarity based on metrics between the initial model and the models in the base of examples. A heuristic method is used to explore the space of possible refactoring solutions. To this end, we used and adapted a genetic algorithm as a global heuristic search. The validation results on different systems of real‐world models taken from open‐source projects confirm the effectiveness of our approach. Copyright © 2014 John Wiley \& Sons, Ltd.}
}

@article{ghannemModelRefactoringUsing2014a,
  title = {Model Refactoring Using Examples: A Search‐based Approach},
  author = {Ghannem, Adnane and El-Boussaidi, Ghizlane and Kessentini, M.},
  date = {2014},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {26},
  pages = {null},
  doi = {10.1002/smr.1644},
  url = {https://www.semanticscholar.org/paper/9b49b917a0a10d21ecffac0103b935f2263002f3},
  abstract = {One of the important challenges in model‐driven engineering is how to improve the quality of the models' design in order to help designers understand them. Refactoring represents an efficient technique to improve the quality of a design while preserving its behavior. Most of existing work on model refactoring relies on declarative rules to detect refactoring opportunities and to apply the appropriate refactorings. However, a complete specification of refactoring opportunities requires a huge number of rules. In this paper, we consider the refactoring mechanism as a combinatorial optimization problem where the goal is to find good refactoring suggestions starting from a small set of refactoring examples applied to similar contexts. Our approach, named model refactoring by example, takes as input an initial model to refactor, a set of structural metrics calculated on both initial model and models in the base of examples, and a base of refactoring examples extracted from different software systems and generates as output a sequence of refactorings. A solution is defined as a combination of refactoring operations that should maximize as much as possible the structural similarity based on metrics between the initial model and the models in the base of examples. A heuristic method is used to explore the space of possible refactoring solutions. To this end, we used and adapted a genetic algorithm as a global heuristic search. The validation results on different systems of real‐world models taken from open‐source projects confirm the effectiveness of our approach. Copyright © 2014 John Wiley \& Sons, Ltd.}
}

@article{ghannemUseDesignDefect2016,
  title = {On the Use of Design Defect Examples to Detect Model Refactoring Opportunities},
  author = {Ghannem, Adnane and El-Boussaidi, Ghizlane and Kessentini, M.},
  date = {2016},
  journaltitle = {Software Quality Journal},
  volume = {24},
  pages = {947--965},
  doi = {10.1007/s11219-015-9271-9},
  url = {https://www.semanticscholar.org/paper/834c006070cc693cfc207552dd370231384a7ec7},
  abstract = {S2 TL;DR: This paper proposes in this paper to identify design defects using a genetic algorithm based on the similarity/distance between the system under study and a set of defect examples without the need to define detection rules.}
}

@article{ghannemUseDesignDefect2016a,
  title = {On the Use of Design Defect Examples to Detect Model Refactoring Opportunities},
  author = {Ghannem, Adnane and El-Boussaidi, Ghizlane and Kessentini, M.},
  date = {2016},
  journaltitle = {Software Quality Journal},
  volume = {24},
  pages = {947--965},
  doi = {10.1007/s11219-015-9271-9},
  url = {https://www.semanticscholar.org/paper/834c006070cc693cfc207552dd370231384a7ec7},
  abstract = {S2 TL;DR: This paper proposes in this paper to identify design defects using a genetic algorithm based on the similarity/distance between the system under study and a set of defect examples without the need to define detection rules.}
}

@article{golzadehGroundtruthDatasetClassification2020,
  title = {A Ground-Truth Dataset and Classification Model for Detecting Bots in {{GitHub}} Issue and {{PR}} Comments},
  author = {Golzadeh, M. and Decan, Alexandre and Legay, Damien and Mens, T.},
  date = {2020},
  journaltitle = {J. Syst. Softw.},
  volume = {175},
  pages = {110911},
  doi = {10.1016/j.jss.2021.110911},
  url = {https://www.semanticscholar.org/paper/111da19e8911ba04cdd38fec42587c8b8c976287},
  abstract = {S2 TL;DR: This paper proposes an automated classification model based on the random forest classifier, taking as main features the number of empty and non-empty comments of each account, the numbers of comment patterns, and the inequality between comments within comment patterns.}
}

@article{golzadehGroundtruthDatasetClassification2020a,
  title = {A Ground-Truth Dataset and Classification Model for Detecting Bots in {{GitHub}} Issue and {{PR}} Comments},
  author = {Golzadeh, M. and Decan, Alexandre and Legay, Damien and Mens, T.},
  date = {2020},
  journaltitle = {J. Syst. Softw.},
  volume = {175},
  pages = {110911},
  doi = {10.1016/j.jss.2021.110911},
  url = {https://www.semanticscholar.org/paper/111da19e8911ba04cdd38fec42587c8b8c976287},
  abstract = {S2 TL;DR: This paper proposes an automated classification model based on the random forest classifier, taking as main features the number of empty and non-empty comments of each account, the numbers of comment patterns, and the inequality between comments within comment patterns.}
}

@article{gomezExperimentsProactiveDeclarative2009,
  title = {Experiments with Pro-Active Declarative Meta-Programming},
  author = {Gómez, Verónica Uquillas and Kellens, Andy and Gybels, K. and D'Hondt, T.},
  date = {2009},
  doi = {10.1145/1735935.1735947},
  url = {https://www.semanticscholar.org/paper/060c5faf123861e0f6576e2219e815aa2c37a8f4},
  abstract = {Program querying has become a valuable asset in the programmer's toolbox. Using dedicated querying languages, developers can reason about their source code in order to find errors, refactoring opportunities and so on. Within Smalltalk, the SOUL language has been proposed as one such language that offers a declarative and expressive means to query the source code of object-oriented programs. Ever since its inception, SOUL has been used as the underlying technique for a number of academic software engineering tools. Despite its success, one of the problems of SOUL is that, due to its backward chained implementation, it is less suited as a basis for such pro-active software tools. Using SOUL, a developer has to launch the queries over the system manually, rather than automatically receiving feedback whenever the underlying source code is changed. In this paper we present PARACHUT, an alternative logic query language that is based on forward chaining and temporal logic and that allows developers to express queries over the change history of the system. Furthermore, PARACHUT's data-driven nature makes it possible to provide instant feedback to developers when the source code is changed, thus providing better support for pro-active software tools.}
}

@article{gomezExperimentsProactiveDeclarative2009a,
  title = {Experiments with Pro-Active Declarative Meta-Programming},
  author = {Gómez, Verónica Uquillas and Kellens, Andy and Gybels, K. and D'Hondt, T.},
  date = {2009},
  doi = {10.1145/1735935.1735947},
  url = {https://www.semanticscholar.org/paper/060c5faf123861e0f6576e2219e815aa2c37a8f4},
  abstract = {Program querying has become a valuable asset in the programmer's toolbox. Using dedicated querying languages, developers can reason about their source code in order to find errors, refactoring opportunities and so on. Within Smalltalk, the SOUL language has been proposed as one such language that offers a declarative and expressive means to query the source code of object-oriented programs. Ever since its inception, SOUL has been used as the underlying technique for a number of academic software engineering tools. Despite its success, one of the problems of SOUL is that, due to its backward chained implementation, it is less suited as a basis for such pro-active software tools. Using SOUL, a developer has to launch the queries over the system manually, rather than automatically receiving feedback whenever the underlying source code is changed. In this paper we present PARACHUT, an alternative logic query language that is based on forward chaining and temporal logic and that allows developers to express queries over the change history of the system. Furthermore, PARACHUT's data-driven nature makes it possible to provide instant feedback to developers when the source code is changed, thus providing better support for pro-active software tools.}
}

@article{guptaSystematicLiteratureReview2017,
  title = {A {{Systematic Literature Review}}: {{Code Bad Smells}} in {{Java Source Code}}},
  author = {Gupta, Aakanshi and Suri, Bharti and Misra, S.},
  date = {2017},
  doi = {10.1007/978-3-319-62404-4_49},
  url = {https://www.semanticscholar.org/paper/b0232b47186aa4fc50cc1d4698f9451764daa660},
  abstract = {S2 TL;DR: This SLR identified that code clone (code smell) receives most research attention and a significant correlation between detection techniques and correlation between the detection techniques, in addition to finding the name of the code smells that need more attention in detection approaches.}
}

@article{hallCodeSmellsHave2014,
  title = {Some {{Code Smells Have}} a {{Significant}} but {{Small Effect}} on {{Faults}}},
  author = {Hall, T. and Zhang, Min and Bowes, David and Sun, Yi},
  date = {2014},
  journaltitle = {ACM Trans. Softw. Eng. Methodol.},
  volume = {23},
  pages = {33:1-33:39},
  doi = {10.1145/2629648},
  url = {https://www.semanticscholar.org/paper/f02f802b044aaf07d0e408bb91cab690d37dafc0},
  abstract = {We investigate the relationship between faults and five of Fowler et al.'s least-studied smells in code: Data Clumps, Switch Statements, Speculative Generality, Message Chains, and Middle Man. We developed a tool to detect these five smells in three open-source systems: Eclipse, ArgoUML, and Apache Commons. We collected fault data from the change and fault repositories of each system. We built Negative Binomial regression models to analyse the relationships between smells and faults and report the McFadden effect size of those relationships. Our results suggest that Switch Statements had no effect on faults in any of the three systems; Message Chains increased faults in two systems; Message Chains which occurred in larger files reduced faults; Data Clumps reduced faults in Apache and Eclipse but increased faults in ArgoUML; Middle Man reduced faults only in ArgoUML, and Speculative Generality reduced faults only in Eclipse. File size alone affects faults in some systems but not in all systems. Where smells did significantly affect faults, the size of that effect was small (always under 10 percent). Our findings suggest that some smells do indicate fault-prone code in some circumstances but that the effect that these smells have on faults is small. Our findings also show that smells have different effects on different systems. We conclude that arbitrary refactoring is unlikely to significantly reduce fault-proneness and in some cases may increase fault-proneness.}
}

@article{hamzaCodeSmellEradication2008,
  title = {Code Smell Eradication and Associated Refactoring},
  author = {Hamza, H. and Counsell, S. and Hall, T. and Loizou, G.},
  date = {2008},
  url = {https://www.semanticscholar.org/paper/ceced9a119d6f44c4e208e5738318398df83b74b},
  abstract = {A refactoring may use many other refactorings to implement its mechanics and the dependencies thus produced form a nested ‘chain’ of other refactorings. In this paper, we propose an approach which provides a coarse guide to effort required in eradicating code ‘smells’. The approach is based on the quantitative analysis of the dependencies between two sets of code smells, namely, those of Kerievsky and Fowler. A bespoke tool was developed to extract the required dependency information. Results suggest that some code smells require a considerably larger effort to remedy than others, suggesting that, where possible, developers should avoid eradicating these smells in favour of other code smells which can be eliminated relatively easily. A clear difference in the composition between the smells of Kerievsky and those of Fowler was also observed. Key-Words: Refactoring, chain dependencies, code smells, Fowler, Kerievsky.}
}

@article{haqueCausesImpactsDetection2018,
  title = {Causes, Impacts, and Detection Approaches of Code Smell: A Survey},
  author = {Haque, Md Shariful and Carver, Jeffery and Atkison, T.},
  date = {2018},
  journaltitle = {Proceedings of the ACMSE 2018 Conference},
  volume = {null},
  pages = {null},
  doi = {10.1145/3190645.3190697},
  url = {https://www.semanticscholar.org/paper/d92672fc1adbb5ca36bc68641e060f3cfaae7a4a},
  abstract = {Code smells are anomalies often generated in design, implementation or maintenance phase of software development life cycle. Researchers established several catalogues characterizing the smells. Fowler and Beck developed the most popular catalogue of 22 smells covering varieties of development issues. This literature presents an overview of the existing research conducted on these 22 smells. Our motivation is to represent these smells with an easier interpretation for the software developers, determine the causes that generate these issues in applications and their impact from different aspects of software maintenance. This paper also highlights previous and recent research on smell detection with an effort to categorize the approaches based on the underlying concept.}
}

@article{hinds-charlesLongitudeAnalysisBitcoin2018,
  title = {A {{Longitude Analysis}} on {{Bitcoin Issue Repository}}},
  author = {Hinds-Charles, Chelsea and Adames, Jenelee and Yang, Ye and Shen, YuSong and Wang, Yong},
  date = {2018},
  journaltitle = {2018 1st IEEE International Conference on Hot Information-Centric Networking (HotICN)},
  volume = {null},
  pages = {212--217},
  doi = {10.1109/HOTICN.2018.8605996},
  url = {https://www.semanticscholar.org/paper/5d1554ff24adbb4236965d26c8c88e70550647df},
  abstract = {As one of the most successful Blockchain systems, Bitcoin evolved over the past 8 years. The collaborative contribution of its online software development community gradually shaped the functionality and performance of Bitcoin. To date, most discussions around Bitcoin are from technologies underlying the product, as well as market applications. There are very few studies on the development and evolution processes of the Bitcoin software. It is important to investigate on such developmental issues, in order to better understand the development methodologies and lessons learnt from such a spearheaded Blockchain system. This paper serves this purpose by examining the issues data extracted from the Bitcoin GitHub repository from 2011 to 2018. It reports the trends of the major development issues from a longitude perspective. The main results include: 1) the average lifespan of an issue in Bitcoin issue repository is approximately 57 days; and 2) the Top-7 issue types including refactoring, tests, doc, RPC.REST.ZMQ, GUI, bugs, and wallet, accounting for 64.3\% of all issues; 3) topic modeling techniques are beneficial in mining popularity and evolution of key issue topics and most problematic architecture components. Using data analysis and visualization techniques, this paper suggests the insights for significant development decisions such as better managing issue repository and strategic allocating of bug resolution effort.}
}

@article{hinds-charlesLongitudeAnalysisBitcoin2018a,
  title = {A {{Longitude Analysis}} on {{Bitcoin Issue Repository}}},
  author = {Hinds-Charles, Chelsea and Adames, Jenelee and Yang, Ye and Shen, YuSong and Wang, Yong},
  date = {2018},
  journaltitle = {2018 1st IEEE International Conference on Hot Information-Centric Networking (HotICN)},
  volume = {null},
  pages = {212--217},
  doi = {10.1109/HOTICN.2018.8605996},
  url = {https://www.semanticscholar.org/paper/5d1554ff24adbb4236965d26c8c88e70550647df},
  abstract = {As one of the most successful Blockchain systems, Bitcoin evolved over the past 8 years. The collaborative contribution of its online software development community gradually shaped the functionality and performance of Bitcoin. To date, most discussions around Bitcoin are from technologies underlying the product, as well as market applications. There are very few studies on the development and evolution processes of the Bitcoin software. It is important to investigate on such developmental issues, in order to better understand the development methodologies and lessons learnt from such a spearheaded Blockchain system. This paper serves this purpose by examining the issues data extracted from the Bitcoin GitHub repository from 2011 to 2018. It reports the trends of the major development issues from a longitude perspective. The main results include: 1) the average lifespan of an issue in Bitcoin issue repository is approximately 57 days; and 2) the Top-7 issue types including refactoring, tests, doc, RPC.REST.ZMQ, GUI, bugs, and wallet, accounting for 64.3\% of all issues; 3) topic modeling techniques are beneficial in mining popularity and evolution of key issue topics and most problematic architecture components. Using data analysis and visualization techniques, this paper suggests the insights for significant development decisions such as better managing issue repository and strategic allocating of bug resolution effort.}
}

@article{houSoftwareRefactoringScheme2020,
  title = {Software {{Refactoring Scheme Based}} on {{NSGA-II Algorithm}}},
  author = {Hou, Defei and Yin, Yongfeng and Su, Qingran and Liu, Lijun},
  date = {2020},
  journaltitle = {2020 7th International Conference on Dependable Systems and Their Applications (DSA)},
  volume = {null},
  pages = {447--452},
  doi = {10.1109/DSA51864.2020.00076},
  url = {https://www.semanticscholar.org/paper/af627527d9c2b8e13ab239170d66fc3f67258fe4},
  abstract = {As an important software maintenance measure, the key of software refactoring is to improve the unreasonable part of code module, namely code smell. There are many refactoring points with different priorities and severity in the reconstruction activities of large-scale software system. How to determine a suitable reconstruction scheme is an important problem to be solved. In view of the above problems, a multi-objective software reconstruction scheme model is established, which aims at eliminating the number of code smell, the severity of code smell and its importance. Meanwhile, the number of reading code and the difficulty degree are used as the auxiliary decision indicators. NSGA-II algorithm is used to solve the optimal solution set, and the software system JHotDraw is used to verify. Two kinds of scheme sets with higher robustness are obtained considering the fluctuation of severity and importance. Two trade-offs are obtained from the two schemes set. Then, the reconstruction activities are sorted according to the reconstruction cost, which can further improve the purpose, robustness and effectiveness of the code reconstruction activities.}
}

@article{houSoftwareRefactoringScheme2020a,
  title = {Software {{Refactoring Scheme Based}} on {{NSGA-II Algorithm}}},
  author = {Hou, Defei and Yin, Yongfeng and Su, Qingran and Liu, Lijun},
  date = {2020},
  journaltitle = {2020 7th International Conference on Dependable Systems and Their Applications (DSA)},
  volume = {null},
  pages = {447--452},
  doi = {10.1109/DSA51864.2020.00076},
  url = {https://www.semanticscholar.org/paper/af627527d9c2b8e13ab239170d66fc3f67258fe4},
  abstract = {As an important software maintenance measure, the key of software refactoring is to improve the unreasonable part of code module, namely code smell. There are many refactoring points with different priorities and severity in the reconstruction activities of large-scale software system. How to determine a suitable reconstruction scheme is an important problem to be solved. In view of the above problems, a multi-objective software reconstruction scheme model is established, which aims at eliminating the number of code smell, the severity of code smell and its importance. Meanwhile, the number of reading code and the difficulty degree are used as the auxiliary decision indicators. NSGA-II algorithm is used to solve the optimal solution set, and the software system JHotDraw is used to verify. Two kinds of scheme sets with higher robustness are obtained considering the fluctuation of severity and importance. Two trade-offs are obtained from the two schemes set. Then, the reconstruction activities are sorted according to the reconstruction cost, which can further improve the purpose, robustness and effectiveness of the code reconstruction activities.}
}

@article{hsiehIdentificationRefactoringException2017,
  title = {Identification and {{Refactoring}} of {{Exception Handling Code Smells}} in {{JavaScript}}},
  author = {Hsieh, Chin-Yun and My, Canh Le and Ho, Kim Thoa and Cheng, Yu Chin},
  date = {2017},
  journaltitle = {Journal of Internet Technology},
  volume = {18},
  pages = {1461--1471},
  url = {https://www.semanticscholar.org/paper/a51fd1e93d69f8e2718dcfa424db6c55020dd031},
  abstract = {Avoid making bad smells is very important in writing exception handling code for dealing with unexpected runtime errors. The task however is challenging and demands proficient programming skills and experience. This is particularly true in developing JavaScript applications because JavaScript is very rich in features as being dynamic, interpreted and object-oriented with first-class functions. What further complicates the situation is the use of event-driven and non-blocking I/O model in Node.js, which is a runtime environment written in server-side JavaScript. Extended from our previous work on exception handling code smells in Java, this study aims at identifying exception handling code smells that can occur in a JavaScript application at either the client side or the server side. The impact to software quality that each smell has is demonstrated with examples. Refactorings corresponding to the identified smells are proposed; their effects to the application, including the robustness level achieved and other benefits gained, are illustrated. The work is intended to serve as a guide in helping JavaScript developers avoid or discover exception handling code smells.}
}

@article{hsiehIdentificationRefactoringException2017a,
  title = {Identification and {{Refactoring}} of {{Exception Handling Code Smells}} in {{JavaScript}}},
  author = {Hsieh, Chin-Yun and My, Canh Le and Ho, Kim Thoa and Cheng, Yu Chin},
  date = {2017},
  journaltitle = {Journal of Internet Technology},
  volume = {18},
  pages = {1461--1471},
  url = {https://www.semanticscholar.org/paper/a51fd1e93d69f8e2718dcfa424db6c55020dd031},
  abstract = {Avoid making bad smells is very important in writing exception handling code for dealing with unexpected runtime errors. The task however is challenging and demands proficient programming skills and experience. This is particularly true in developing JavaScript applications because JavaScript is very rich in features as being dynamic, interpreted and object-oriented with first-class functions. What further complicates the situation is the use of event-driven and non-blocking I/O model in Node.js, which is a runtime environment written in server-side JavaScript. Extended from our previous work on exception handling code smells in Java, this study aims at identifying exception handling code smells that can occur in a JavaScript application at either the client side or the server side. The impact to software quality that each smell has is demonstrated with examples. Refactorings corresponding to the identified smells are proposed; their effects to the application, including the robustness level achieved and other benefits gained, are illustrated. The work is intended to serve as a guide in helping JavaScript developers avoid or discover exception handling code smells.}
}

@article{kebirAutomaticRefactoringComponentbased2016,
  title = {Automatic {{Refactoring}} of {{Component-based Software}} by {{Detecting}} and {{Eliminating Bad Smells}} - {{A Search-based Approach}}},
  author = {Kebir, S. and Borne, I. and Meslati, D.},
  date = {2016},
  doi = {10.5220/0005891602100215},
  url = {https://www.semanticscholar.org/paper/26ac401511e4448a1a6781e0e6c05619677b38d7},
  abstract = {Refactoring has been proposed as a de factobehavior-preserving mean to eliminate bad smells. However manually determining and performing useful refactorings is a though challenge because seemingly useful refactorings can improve some aspect of a software while making another aspect worse. Therefore it has been proposed to view object-oriented automated refactoring as a search-based technique. Nevertheless the review of the literature shows that automated refactoring of component-based software has not been investigated yet. Recently a catalogue of component-relevant bad smells has been proposed in the literature but there is a lack of component-relevant refactorings. In this paper we propose detection rules for component-relevant bad smells as well as a catalogue of component-relevant refactorings. Then we rely on these two elements to propose a search-based approach for automated refactoring of component-based software systems by detecting and eliminating bad smells. Finally, we experiment our approach on a medium-sized component-based software and we assess the efficieny and accuracy of our approach.}
}

@article{kebirAutomaticRefactoringComponentbased2016a,
  title = {Automatic {{Refactoring}} of {{Component-based Software}} by {{Detecting}} and {{Eliminating Bad Smells}} - {{A Search-based Approach}}},
  author = {Kebir, S. and Borne, I. and Meslati, D.},
  date = {2016},
  doi = {10.5220/0005891602100215},
  url = {https://www.semanticscholar.org/paper/26ac401511e4448a1a6781e0e6c05619677b38d7},
  abstract = {Refactoring has been proposed as a de factobehavior-preserving mean to eliminate bad smells. However manually determining and performing useful refactorings is a though challenge because seemingly useful refactorings can improve some aspect of a software while making another aspect worse. Therefore it has been proposed to view object-oriented automated refactoring as a search-based technique. Nevertheless the review of the literature shows that automated refactoring of component-based software has not been investigated yet. Recently a catalogue of component-relevant bad smells has been proposed in the literature but there is a lack of component-relevant refactorings. In this paper we propose detection rules for component-relevant bad smells as well as a catalogue of component-relevant refactorings. Then we rely on these two elements to propose a search-based approach for automated refactoring of component-based software systems by detecting and eliminating bad smells. Finally, we experiment our approach on a medium-sized component-based software and we assess the efficieny and accuracy of our approach.}
}

@article{kebirGeneticAlgorithmAutomated2016,
  title = {A {{Genetic Algorithm}} for {{Automated Refactoring}} of {{Component-Based Software}}},
  author = {Kebir, S. and Borne, I. and Meslati, D.},
  date = {2016},
  journaltitle = {EAI Endorsed Trans. Creative Technol.},
  volume = {3},
  pages = {e2},
  doi = {10.4108/eai.3-12-2015.2262353},
  url = {https://www.semanticscholar.org/paper/2079a71658ea01344325cfa9fb6d98b77cec476d},
  abstract = {Nowadays a software undergoes modifications done by different people to quickly fulfill new requirements, but its underlying design is not adjusted properly after each update. This leads to the emergence of bad smells. Refactoring provides a de facto behavior-preserving means to eliminate these anomalies. However, manually determining and performing useful refactorings is known as an NP-Complete problem as stated by Harman et al. because seemingly useful refactorings can improve some aspect of a software while making another aspect worse. Therefore it has been proposed to view object-oriented automated refactoring as a search based technique. However the review of the litterature shows that automated refactoring of component-based software has not been investigated yet. Recently a catalogue of component-relevant bad smells has been proposed in the literature but there is a lack of component-relevant refactorings. In this paper we propose a catalogue of component-relevant refactoring as well as detections rules for component-relevant bad smells. Then we rely on these two ingredients to propose a genetic algorithm for automated refactoring of component-based software systems.}
}

@article{kebirGeneticAlgorithmAutomated2016a,
  title = {A {{Genetic Algorithm}} for {{Automated Refactoring}} of {{Component-Based Software}}},
  author = {Kebir, S. and Borne, I. and Meslati, D.},
  date = {2016},
  journaltitle = {EAI Endorsed Trans. Creative Technol.},
  volume = {3},
  pages = {e2},
  doi = {10.4108/eai.3-12-2015.2262353},
  url = {https://www.semanticscholar.org/paper/2079a71658ea01344325cfa9fb6d98b77cec476d},
  abstract = {Nowadays a software undergoes modifications done by different people to quickly fulfill new requirements, but its underlying design is not adjusted properly after each update. This leads to the emergence of bad smells. Refactoring provides a de facto behavior-preserving means to eliminate these anomalies. However, manually determining and performing useful refactorings is known as an NP-Complete problem as stated by Harman et al. because seemingly useful refactorings can improve some aspect of a software while making another aspect worse. Therefore it has been proposed to view object-oriented automated refactoring as a search based technique. However the review of the litterature shows that automated refactoring of component-based software has not been investigated yet. Recently a catalogue of component-relevant bad smells has been proposed in the literature but there is a lack of component-relevant refactorings. In this paper we propose a catalogue of component-relevant refactoring as well as detections rules for component-relevant bad smells. Then we rely on these two ingredients to propose a genetic algorithm for automated refactoring of component-based software systems.}
}

@article{kebirGeneticAlgorithmbasedApproach2017,
  title = {A Genetic Algorithm-Based Approach for Automated Refactoring of Component-Based Software},
  author = {Kebir, S. and Borne, I. and Meslati, D.},
  date = {2017},
  journaltitle = {Inf. Softw. Technol.},
  volume = {88},
  pages = {17--36},
  doi = {10.1016/J.INFSOF.2017.03.009},
  url = {https://www.semanticscholar.org/paper/ab03e0c87fd15966c05888272fab32ef346004d2},
  abstract = {S2 TL;DR: This approach is the first to focus on component-based refactoring, whereas the state-of-the-art approaches focus only on object-oriented refactors, and outperforms random search and local search in terms of efficiency and accuracy.}
}

@article{kebirGeneticAlgorithmbasedApproach2017a,
  title = {A Genetic Algorithm-Based Approach for Automated Refactoring of Component-Based Software},
  author = {Kebir, S. and Borne, I. and Meslati, D.},
  date = {2017},
  journaltitle = {Inf. Softw. Technol.},
  volume = {88},
  pages = {17--36},
  doi = {10.1016/J.INFSOF.2017.03.009},
  url = {https://www.semanticscholar.org/paper/ab03e0c87fd15966c05888272fab32ef346004d2},
  abstract = {S2 TL;DR: This approach is the first to focus on component-based refactoring, whereas the state-of-the-art approaches focus only on object-oriented refactors, and outperforms random search and local search in terms of efficiency and accuracy.}
}

@article{kessentiniDetectingRefactoringsMultiple2017,
  title = {Detecting {{Refactorings}} among {{Multiple Web Service Releases}}: {{A Heuristic-Based Approach}}},
  author = {Kessentini, M. and Wang, Hanzhang},
  date = {2017},
  journaltitle = {2017 IEEE International Conference on Web Services (ICWS)},
  volume = {null},
  pages = {365--372},
  doi = {10.1109/ICWS.2017.121},
  url = {https://www.semanticscholar.org/paper/a6ad479bfa2ec6b48f3e601de919578e2ecba9d4},
  abstract = {A Web service interface is considered as a contract between Web service providers and their subscribers. The subscribers do not have access to the source code of the services but only to the interface containing a set of operations. However, the interface may change over time to meet new requirements. These changes affect the implementation of the subscribers' software. Thus, these clients need to understand the changes introduced to the previous releases of the Web services to co-evolve their own implementation to support the new release. Current studies are limited to the detection of only atomic changes (e.g. add and delete) and not able to detect complex/composite refactorings (merge operations, extract operation, etc.). In this paper, we propose to consider structural and textual similarities, based on a genetic algorithm, when analyzing the evolution of Web services to detect complex changes applied between multiple releases. The validation of our detection technique, on more than 110 releases of 6 real-world Web services, shows an average precision and recall respectively higher than 86\% and 89\%.}
}

@article{kessentiniDetectingRefactoringsMultiple2017a,
  title = {Detecting {{Refactorings}} among {{Multiple Web Service Releases}}: {{A Heuristic-Based Approach}}},
  author = {Kessentini, M. and Wang, Hanzhang},
  date = {2017},
  journaltitle = {2017 IEEE International Conference on Web Services (ICWS)},
  volume = {null},
  pages = {365--372},
  doi = {10.1109/ICWS.2017.121},
  url = {https://www.semanticscholar.org/paper/a6ad479bfa2ec6b48f3e601de919578e2ecba9d4},
  abstract = {A Web service interface is considered as a contract between Web service providers and their subscribers. The subscribers do not have access to the source code of the services but only to the interface containing a set of operations. However, the interface may change over time to meet new requirements. These changes affect the implementation of the subscribers' software. Thus, these clients need to understand the changes introduced to the previous releases of the Web services to co-evolve their own implementation to support the new release. Current studies are limited to the detection of only atomic changes (e.g. add and delete) and not able to detect complex/composite refactorings (merge operations, extract operation, etc.). In this paper, we propose to consider structural and textual similarities, based on a genetic algorithm, when analyzing the evolution of Web services to detect complex changes applied between multiple releases. The validation of our detection technique, on more than 110 releases of 6 real-world Web services, shows an average precision and recall respectively higher than 86\% and 89\%.}
}

@article{khanCloningPopularServer2018,
  title = {Cloning in {{Popular Server Side Technologies}} Using {{Agile Development}}: {{An Empirical Study}}},
  author = {Khan, Aisha and Basit, H. and Sarwar, S. M. and Yousaf, M.},
  date = {2018},
  journaltitle = {Pakistan Journal of Engineering and Applied Sciences},
  pages = {null},
  url = {https://www.semanticscholar.org/paper/321fa7cbbfa208234466a848cb9a07ed95bb63d9},
  abstract = {Several types of clones exist in software systems due to the copy-paste activity, developer limitations, language restrictions, and software development lifecycle. This work studies the issues of cloning in server side technologies for web applications. We studied 11 different reasonable size (average over 22K LOC) web development projects coded in C\#, Java, Ruby-on-Rails (ROR), and PHP based on the same set of requirements. We identified and analyzed simple and structural clones present in these systems in order to compare the different technologies in terms of number of clones, clone size, clone coverage, reasons behind creation of clones, and the ratio of refactorable and non-refactorable clones. Our study focused only on the base languages of these server side technologies. Our analyses show that C\# has the highest number of clones and ROR has the lowest. C\# also has the highest and ROR has the lowest percentages of refactorable clones. PHP has the highest clone coverage and ROR has the lowest. Average clone size for all projects ranges from 49.8 to 77.2 tokens. In terms of clone size, there are no significant differences across projects in the same technology. The project size, project architecture, and developer approach dictate the percentage of clones present in a software project. The use of frameworks and design patterns helps control generation of clones.}
}

@article{khanCloningPopularServer2018a,
  title = {Cloning in {{Popular Server Side Technologies}} Using {{Agile Development}}: {{An Empirical Study}}},
  author = {Khan, Aisha and Basit, H. and Sarwar, S. M. and Yousaf, M.},
  date = {2018},
  journaltitle = {Pakistan Journal of Engineering and Applied Sciences},
  pages = {null},
  url = {https://www.semanticscholar.org/paper/321fa7cbbfa208234466a848cb9a07ed95bb63d9},
  abstract = {Several types of clones exist in software systems due to the copy-paste activity, developer limitations, language restrictions, and software development lifecycle. This work studies the issues of cloning in server side technologies for web applications. We studied 11 different reasonable size (average over 22K LOC) web development projects coded in C\#, Java, Ruby-on-Rails (ROR), and PHP based on the same set of requirements. We identified and analyzed simple and structural clones present in these systems in order to compare the different technologies in terms of number of clones, clone size, clone coverage, reasons behind creation of clones, and the ratio of refactorable and non-refactorable clones. Our study focused only on the base languages of these server side technologies. Our analyses show that C\# has the highest number of clones and ROR has the lowest. C\# also has the highest and ROR has the lowest percentages of refactorable clones. PHP has the highest clone coverage and ROR has the lowest. Average clone size for all projects ranges from 49.8 to 77.2 tokens. In terms of clone size, there are no significant differences across projects in the same technology. The project size, project architecture, and developer approach dictate the percentage of clones present in a software project. The use of frameworks and design patterns helps control generation of clones.}
}

@article{khatchadourianEnumerationRefactoringTool2010,
  title = {Enumeration Refactoring: A Tool for Automatically Converting {{Java}} Constants to Enumerated Types},
  author = {Khatchadourian, Raffi and Muskalla, Benjamin},
  date = {2010},
  journaltitle = {Proceedings of the 25th IEEE/ACM International Conference on Automated Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/1858996.1859036},
  url = {https://www.semanticscholar.org/paper/03c075e5fcc0aa5595b9e571dc4ede42dcafa057},
  abstract = {Java 5 introduces several new features that offer significant improvements over older Java technology. We consider the new enum construct, which provides language support for enumerated types. Before Java 5, programmers needed to employ various patterns to compensate for the absence of enumerated types in Java. Unfortunately, these compensation patterns lack several highly desirable properties of the enum construct, most notably, type-safety. We demonstrate an automated refactoring tool called Convert Constants to Enum for transforming legacy Java code to use the new enumeration construct. An interprocedural type inferencing algorithm that tracks the flow of enumerated values drives the approach, and the tool is implemented as a seamless extension to existing refactoring support in Eclipse. The resulting code is semantically equivalent to the original, increasingly type-safe, easier to comprehend, less complex, and supports separate compilation.}
}

@article{khatchadourianEnumerationRefactoringTool2010a,
  title = {Enumeration Refactoring: A Tool for Automatically Converting {{Java}} Constants to Enumerated Types},
  author = {Khatchadourian, Raffi and Muskalla, Benjamin},
  date = {2010},
  journaltitle = {Proceedings of the 25th IEEE/ACM International Conference on Automated Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/1858996.1859036},
  url = {https://www.semanticscholar.org/paper/03c075e5fcc0aa5595b9e571dc4ede42dcafa057},
  abstract = {Java 5 introduces several new features that offer significant improvements over older Java technology. We consider the new enum construct, which provides language support for enumerated types. Before Java 5, programmers needed to employ various patterns to compensate for the absence of enumerated types in Java. Unfortunately, these compensation patterns lack several highly desirable properties of the enum construct, most notably, type-safety. We demonstrate an automated refactoring tool called Convert Constants to Enum for transforming legacy Java code to use the new enumeration construct. An interprocedural type inferencing algorithm that tracks the flow of enumerated values drives the approach, and the tool is implemented as a seamless extension to existing refactoring support in Eclipse. The resulting code is semantically equivalent to the original, increasingly type-safe, easier to comprehend, less complex, and supports separate compilation.}
}

@article{khomhBayesianApproachDetection2009,
  title = {A {{Bayesian Approach}} for the {{Detection}} of {{Code}} and {{Design Smells}}},
  author = {Khomh, F. and Vaucher, S. and Guéhéneuc, Yann-Gaël and Sahraoui, H.},
  date = {2009},
  journaltitle = {2009 Ninth International Conference on Quality Software},
  volume = {null},
  pages = {305--314},
  doi = {10.1109/QSIC.2009.47},
  url = {https://www.semanticscholar.org/paper/bb169faef99a3d690135036b5fbdc1dc92a22007},
  abstract = {The presence of code and design smells can have a severe impact on the quality of a program. Consequently, their detection and correction have drawn the attention of both researchers and practitioners who have proposed various approaches to detect code and design smells in programs. However, none of these approaches handle the inherent uncertainty of the detection process. We propose a Bayesian approach to manage this uncertainty. First, we present a systematic process to convert existing state-of-the-art detection rules into a probabilistic model. We illustrate this process by generating a model to detect occurrences of the Blob antipattern. Second, we present results of the validation of the model: we built this model on two open-source programs, GanttProject v1.10.2 and Xerces v2.7.0, and measured its accuracy. Third, we compare our model with another approach to show that it returns the same candidate classes while ordering them to minimise the quality analysts' effort. Finally, we show that when past detection results are available, our model can be calibrated using machine learning techniques to offer an improved, context-specific detection.}
}

@article{khomhExploratoryStudyImpact2009,
  title = {An {{Exploratory Study}} of the {{Impact}} of {{Code Smells}} on {{Software Change-proneness}}},
  author = {Khomh, F. and Penta, M. D. and Guéhéneuc, Yann-Gaël},
  date = {2009},
  journaltitle = {2009 16th Working Conference on Reverse Engineering},
  volume = {null},
  pages = {75--84},
  doi = {10.1109/WCRE.2009.28},
  url = {https://www.semanticscholar.org/paper/907080bd29b16c5f94bd38e205ed2e1c5770bbb2},
  abstract = {Code smells are poor implementation choices, thought to make object-oriented systems hard to maintain. In this study, we investigate if classes with code smells are more change-prone than classes without smells. Specifically, we test the general hypothesis: classes with code smells are not more change prone than other classes. We detect 29 code smells in 9 releases of Azureus and in 13 releases of Eclipse, and study the relation between classes with these code smells and class change-proneness. We show that, in almost all releases of Azureus and Eclipse, classes with code smells are more change-prone than others, and that specific smells are more correlated than others to change-proneness. These results justify a posteriori previous work on the specification and detection of code smells and could help focusing quality assurance and testing activities.}
}

@article{khomhExploratoryStudyImpact2012,
  title = {An Exploratory Study of the Impact of Antipatterns on Class Change- and Fault-Proneness},
  author = {Khomh, F. and Penta, M. D. and Guéhéneuc, Yann-Gaël and Antoniol, G.},
  date = {2012},
  journaltitle = {Empirical Software Engineering},
  volume = {17},
  pages = {243--275},
  doi = {10.1007/s10664-011-9171-y},
  url = {https://www.semanticscholar.org/paper/261eb5329e09e5864920b55388e24b93d65ef460},
  abstract = {S2 TL;DR: It is shown that, in almost all releases of the four systems, classes participating in antipatterns are more change-and fault-prone than others and size alone cannot explain the higher odds of classes with antip atterns to underwent a (fault-fixing) change than other classes.}
}

@article{kinsmanHowSoftwareDevelopers2021,
  title = {How {{Do Software Developers Use GitHub Actions}} to {{Automate Their Workflows}}?},
  author = {Kinsman, Timothy and Wessel, M. and Gerosa, M. and Treude, Christoph},
  date = {2021},
  journaltitle = {2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR)},
  volume = {null},
  pages = {420--431},
  doi = {10.1109/MSR52588.2021.00054},
  url = {https://www.semanticscholar.org/paper/397e83b5075fde4be1f2c84735b637ab4515d039},
  abstract = {Automated tools are frequently used in social coding repositories to perform repetitive activities that are part of the distributed software development process. Recently, GitHub introduced GitHub Actions, a feature providing automated work-flows for repository maintainers. Although several Actions have been built and used by practitioners, relatively little has been done to evaluate them. Understanding and anticipating the effects of adopting such kind of technology is important for planning and management. Our research is the first to investigate how developers use Actions and how several activity indicators change after their adoption. Our results indicate that, although only a small subset of repositories adopted GitHub Actions to date, there is a positive perception of the technology. Our findings also indicate that the adoption of GitHub Actions increases the number of monthly rejected pull requests and decreases the monthly number of commits on merged pull requests. These results are especially relevant for practitioners to understand and prevent undesirable effects on their projects.}
}

@article{kinsmanHowSoftwareDevelopers2021a,
  title = {How {{Do Software Developers Use GitHub Actions}} to {{Automate Their Workflows}}?},
  author = {Kinsman, Timothy and Wessel, M. and Gerosa, M. and Treude, Christoph},
  date = {2021},
  journaltitle = {2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR)},
  volume = {null},
  pages = {420--431},
  doi = {10.1109/MSR52588.2021.00054},
  url = {https://www.semanticscholar.org/paper/397e83b5075fde4be1f2c84735b637ab4515d039},
  abstract = {Automated tools are frequently used in social coding repositories to perform repetitive activities that are part of the distributed software development process. Recently, GitHub introduced GitHub Actions, a feature providing automated work-flows for repository maintainers. Although several Actions have been built and used by practitioners, relatively little has been done to evaluate them. Understanding and anticipating the effects of adopting such kind of technology is important for planning and management. Our research is the first to investigate how developers use Actions and how several activity indicators change after their adoption. Our results indicate that, although only a small subset of repositories adopted GitHub Actions to date, there is a positive perception of the technology. Our findings also indicate that the adoption of GitHub Actions increases the number of monthly rejected pull requests and decreases the monthly number of commits on merged pull requests. These results are especially relevant for practitioners to understand and prevent undesirable effects on their projects.}
}

@article{kocEmpiricalStudySearchBased2011,
  title = {An {{Empirical Study About Search-Based Refactoring Using Alternative Multiple}} and {{Population-Based Search Techniques}}},
  author = {Koç, Ekin and Ersoy, Nur and Andac, Ali and Camlidere, Zelal Seda and Cereci, I. and Kiliç, H.},
  date = {2011},
  doi = {10.1007/978-1-4471-2155-8_7},
  url = {https://www.semanticscholar.org/paper/a806563200cd7161749829f2af742a3e3eae9eed},
  abstract = {S2 TL;DR: An empirical comparative study to see the performances of alternative search algorithms under a quality model defined by an aggregated software fitness metric showed that multiple steepest descent and population-based artificial bee colony algorithms are two most suitable approaches for the efficient solution of the search based refactoring problem.}
}

@article{kocEmpiricalStudySearchBased2011a,
  title = {An {{Empirical Study About Search-Based Refactoring Using Alternative Multiple}} and {{Population-Based Search Techniques}}},
  author = {Koç, Ekin and Ersoy, Nur and Andac, Ali and Camlidere, Zelal Seda and Cereci, I. and Kiliç, H.},
  date = {2011},
  doi = {10.1007/978-1-4471-2155-8_7},
  url = {https://www.semanticscholar.org/paper/a806563200cd7161749829f2af742a3e3eae9eed},
  abstract = {S2 TL;DR: An empirical comparative study to see the performances of alternative search algorithms under a quality model defined by an aggregated software fitness metric showed that multiple steepest descent and population-based artificial bee colony algorithms are two most suitable approaches for the efficient solution of the search based refactoring problem.}
}

@article{kocWebServiceAutomatedSoftware2012,
  title = {A {{Web-Service}} for {{Automated Software Refactoring Using Artificial Bee Colony Optimization}}},
  author = {Koç, Ekin and Ersoy, Nur and Camlidere, Zelal Seda and Kiliç, H.},
  date = {2012},
  doi = {10.1007/978-3-642-30976-2_38},
  url = {https://www.semanticscholar.org/paper/8dd57fd2584cd707336c69ca7c2c97769679db48},
  abstract = {S2 TL;DR: This study designed and implemented a web-service that uses discrete version of Artificial Bee Colony (ABC) optimization approach in order to enhance bytecode compiled Java programming language codes, automatically.}
}

@article{kocWebServiceAutomatedSoftware2012a,
  title = {A {{Web-Service}} for {{Automated Software Refactoring Using Artificial Bee Colony Optimization}}},
  author = {Koç, Ekin and Ersoy, Nur and Camlidere, Zelal Seda and Kiliç, H.},
  date = {2012},
  doi = {10.1007/978-3-642-30976-2_38},
  url = {https://www.semanticscholar.org/paper/8dd57fd2584cd707336c69ca7c2c97769679db48},
  abstract = {S2 TL;DR: This study designed and implemented a web-service that uses discrete version of Artificial Bee Colony (ABC) optimization approach in order to enhance bytecode compiled Java programming language codes, automatically.}
}

@article{kulkarniQualitativeApproachRefactoring2016,
  title = {A Qualitative Approach for Refactoring of Code Clone Opportunities Using Graph and Tree Methods},
  author = {Kulkarni, Chaitanya},
  date = {2016},
  journaltitle = {2016 International Conference on Information Technology (InCITe) - The Next Generation IT Summit on the Theme - Internet of Things: Connect your Worlds},
  volume = {null},
  pages = {154--159},
  doi = {10.1109/INCITE.2016.7857608},
  url = {https://www.semanticscholar.org/paper/4b6de147b501b9938bbd1ed02b7b8e1c94f4b2da},
  abstract = {Reusing of code has been a very common practice in software development. This practice has been implemented to reduce programming time and efforts greatly. This copying and pasting behavior of programmers leads to cloning of codes and therefore has a very serious impact on the maintenance of the software systems. Many clone detection tool has been proposed to find out the copied code. However, refactoring of code is still a challenging part as most of the ongoing tools depend on detection of clone rather than the ability to make decision on refactorability. These tools do not guarantee whether such codes can be safely refactored or not. Our aim mainly lies on detecting the possibility of refactoring a code. To find out whether the code clone can be securely refactored or not, three methods are applied: Nesting Structure Mapping, Statement Mapping and Precondition Examination. In order to refactor the code, we apply some techniques like Pull-Up Method and Push-Down Method. In our approach, we have tried to find the refactorable code using the methods and also refactored the code so as to remove the problem of code cloning.}
}

@article{kulkarniQualitativeApproachRefactoring2016a,
  title = {A Qualitative Approach for Refactoring of Code Clone Opportunities Using Graph and Tree Methods},
  author = {Kulkarni, Chaitanya},
  date = {2016},
  journaltitle = {2016 International Conference on Information Technology (InCITe) - The Next Generation IT Summit on the Theme - Internet of Things: Connect your Worlds},
  volume = {null},
  pages = {154--159},
  doi = {10.1109/INCITE.2016.7857608},
  url = {https://www.semanticscholar.org/paper/4b6de147b501b9938bbd1ed02b7b8e1c94f4b2da},
  abstract = {Reusing of code has been a very common practice in software development. This practice has been implemented to reduce programming time and efforts greatly. This copying and pasting behavior of programmers leads to cloning of codes and therefore has a very serious impact on the maintenance of the software systems. Many clone detection tool has been proposed to find out the copied code. However, refactoring of code is still a challenging part as most of the ongoing tools depend on detection of clone rather than the ability to make decision on refactorability. These tools do not guarantee whether such codes can be safely refactored or not. Our aim mainly lies on detecting the possibility of refactoring a code. To find out whether the code clone can be securely refactored or not, three methods are applied: Nesting Structure Mapping, Statement Mapping and Precondition Examination. In order to refactor the code, we apply some techniques like Pull-Up Method and Push-Down Method. In our approach, we have tried to find the refactorable code using the methods and also refactored the code so as to remove the problem of code cloning.}
}

@article{kumarDemacrofier2012,
  title = {The Demacrofier},
  author = {Kumar, Aditya and Sutton, A. and Stroustrup, B.},
  date = {2012},
  journaltitle = {2012 28th IEEE International Conference on Software Maintenance (ICSM)},
  volume = {null},
  pages = {658--661},
  doi = {10.1109/ICSM.2012.6405347},
  url = {https://www.semanticscholar.org/paper/48db89589ab1d387b6522abd6bc21c4cc0704804},
  abstract = {C++ programs can be rejuvenated by replacing error-prone usage of the C Preprocessor macros with type safe C++11 declarations. We have developed a classification of macros that directly maps to corresponding C++11 expressions, statements, and declarations. We have built a set of tools that replaces macros with equivalent C++ declarations and iteratively introduces the refactorings into the software build.}
}

@article{kumarDemacrofier2012a,
  title = {The Demacrofier},
  author = {Kumar, Aditya and Sutton, A. and Stroustrup, B.},
  date = {2012},
  journaltitle = {2012 28th IEEE International Conference on Software Maintenance (ICSM)},
  volume = {null},
  pages = {658--661},
  doi = {10.1109/ICSM.2012.6405347},
  url = {https://www.semanticscholar.org/paper/48db89589ab1d387b6522abd6bc21c4cc0704804},
  abstract = {C++ programs can be rejuvenated by replacing error-prone usage of the C Preprocessor macros with type safe C++11 declarations. We have developed a classification of macros that directly maps to corresponding C++11 expressions, statements, and declarations. We have built a set of tools that replaces macros with equivalent C++ declarations and iteratively introduces the refactorings into the software build.}
}

@article{lebeufDefiningClassifyingSoftware2019,
  title = {Defining and {{Classifying Software Bots}}: {{A Faceted Taxonomy}}},
  author = {Lebeuf, Carlene and Zagalsky, A. and Foucault, Matthieu and Storey, M.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {1--6},
  doi = {10.1109/BotSE.2019.00008},
  url = {https://www.semanticscholar.org/paper/03de1bc42cc3984fa2acf9c3321c36d8e9a4c62f},
  abstract = {While bots have been around for many decades, recent technological advancements and the increasing adoption of language-based communication platforms have led to a surge of new software bots, which have become increasingly pervasive in our everyday lives. Although many novel bots are being designed and deployed, the terms used to describe them and their properties are vast, diverse, and often inconsistent. Even the concept of what is or is not a bot is unclear. This hinders our ability to study, understand, design, and classify bots. In this paper, we present a taxonomy of software bots, which focuses on the observable properties and behaviours of software bots, as well as the environments where bots are deployed and designed. We see this taxonomy as a focal point for a discussion in our community so that together we can deeply consider how to evaluate and understand existing bots, as well as how we may design more innovative and productive bots.}
}

@article{lebeufDefiningClassifyingSoftware2019a,
  title = {Defining and {{Classifying Software Bots}}: {{A Faceted Taxonomy}}},
  author = {Lebeuf, Carlene and Zagalsky, A. and Foucault, Matthieu and Storey, M.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {1--6},
  doi = {10.1109/BotSE.2019.00008},
  url = {https://www.semanticscholar.org/paper/03de1bc42cc3984fa2acf9c3321c36d8e9a4c62f},
  abstract = {While bots have been around for many decades, recent technological advancements and the increasing adoption of language-based communication platforms have led to a surge of new software bots, which have become increasingly pervasive in our everyday lives. Although many novel bots are being designed and deployed, the terms used to describe them and their properties are vast, diverse, and often inconsistent. Even the concept of what is or is not a bot is unclear. This hinders our ability to study, understand, design, and classify bots. In this paper, we present a taxonomy of software bots, which focuses on the observable properties and behaviours of software bots, as well as the environments where bots are deployed and designed. We see this taxonomy as a focal point for a discussion in our community so that together we can deeply consider how to evaluate and understand existing bots, as well as how we may design more innovative and productive bots.}
}

@article{lebeufSoftwareBots2017,
  title = {Software {{Bots}}},
  author = {Lebeuf, Carlene and Storey, M. and Zagalsky, A.},
  date = {2017},
  journaltitle = {IEEE Software},
  volume = {35},
  pages = {18--23},
  doi = {10.1109/ms.2017.4541027},
  url = {https://www.semanticscholar.org/paper/98eb83152df40549f5b39c9e245690ba65047114},
  abstract = {Although the development and widespread adoption of software bots has occurred in just a few years, bots have taken on many diverse tasks and roles. This article discusses current bot technology and presents a practical case study on how to use bots in software engineering.}
}

@article{lebeufSoftwareBots2017a,
  title = {Software {{Bots}}},
  author = {Lebeuf, Carlene and Storey, M. and Zagalsky, A.},
  date = {2017},
  journaltitle = {IEEE Software},
  volume = {35},
  pages = {18--23},
  doi = {10.1109/ms.2017.4541027},
  url = {https://www.semanticscholar.org/paper/98eb83152df40549f5b39c9e245690ba65047114},
  abstract = {Although the development and widespread adoption of software bots has occurred in just a few years, bots have taken on many diverse tasks and roles. This article discusses current bot technology and presents a practical case study on how to use bots in software engineering.}
}

@article{liEmpiricalStudyBad2007,
  title = {An Empirical Study of the Bad Smells and Class Error Probability in the Post-Release Object-Oriented System Evolution},
  author = {Li, Wei and Shatnawi, R.},
  date = {2007},
  journaltitle = {J. Syst. Softw.},
  volume = {80},
  pages = {1120--1128},
  doi = {10.1016/J.JSS.2006.10.018},
  url = {https://www.semanticscholar.org/paper/87d7cd04ad97008f87361d1a23750aedbe5c4395},
  abstract = {S2 TL;DR: It is shown that some bad smells were positively associated with the class error probability in the three error-severity levels in an industrial-strength open source system.}
}

@article{liuDetectionCodeSmell2017,
  title = {The Detection of Code Smell on Software Development: A Mapping Study},
  author = {Liu, Xinghua and Zhang, Cheng},
  date = {2017},
  doi = {10.2991/ICMMCT-17.2017.120},
  url = {https://www.semanticscholar.org/paper/0aa222adef2b168d76d99c5e808eced13ebdbfb1},
  abstract = {Context: Although Code Smell can't cause problems with execution of project code, Code Smell can cause some potential problems of maintainability and understandability on the software projects. Meanwhile, as for the research of code smell, current research results pay attention to only several specific Code Smells, and then don't have a comprehensive detection on Code Smell. Objective: To investigate what the objective of Code Smell study is, and to find what kinds of code smells could the detection tools of code smell detect. Methods: According to the Guidelines of Kithenham, we carry out a mapping study about 22 code smells, searching the relevant papers till 2015. Results: Through the process of mapping study, 286 papers are finally included and then classified into our data records. Conclusion: Referring to detection tools, firstly they only take notice of several specific Code Smells, because these code smells can be easily measured in term of quantification. Secondly, experiment systems of these papers are almost lab projects and industrial open source not the industrial closed source projects. Thirdly, the size of most detected lab projects are under 30 KLOC. In the future, we will focus efforts on detection of Code Smells that can't be easily detected, what's more, we will put our studies under a comprehensive environment, using three types of project: lab project, open source industrial project and closed source industrial project.}
}

@article{liuDetectionCodeSmell2017a,
  title = {The Detection of Code Smell on Software Development: A Mapping Study},
  author = {Liu, Xinghua and Zhang, Cheng},
  date = {2017},
  doi = {10.2991/ICMMCT-17.2017.120},
  url = {https://www.semanticscholar.org/paper/0aa222adef2b168d76d99c5e808eced13ebdbfb1},
  abstract = {Context: Although Code Smell can't cause problems with execution of project code, Code Smell can cause some potential problems of maintainability and understandability on the software projects. Meanwhile, as for the research of code smell, current research results pay attention to only several specific Code Smells, and then don't have a comprehensive detection on Code Smell. Objective: To investigate what the objective of Code Smell study is, and to find what kinds of code smells could the detection tools of code smell detect. Methods: According to the Guidelines of Kithenham, we carry out a mapping study about 22 code smells, searching the relevant papers till 2015. Results: Through the process of mapping study, 286 papers are finally included and then classified into our data records. Conclusion: Referring to detection tools, firstly they only take notice of several specific Code Smells, because these code smells can be easily measured in term of quantification. Secondly, experiment systems of these papers are almost lab projects and industrial open source not the industrial closed source projects. Thirdly, the size of most detected lab projects are under 30 KLOC. In the future, we will focus efforts on detection of Code Smells that can't be easily detected, what's more, we will put our studies under a comprehensive environment, using three types of project: lab project, open source industrial project and closed source industrial project.}
}

@article{liuIdentifyingPatchCorrectness2017,
  title = {Identifying {{Patch Correctness}} in {{Test-Based Program Repair}}},
  author = {Liu, Xinyuan and Zeng, Muhan and Xiong, Yingfei and Zhang, Lu and Huang, Gang},
  date = {2017},
  journaltitle = {2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)},
  volume = {null},
  pages = {789--799},
  doi = {10.1145/3180155.3180182},
  url = {https://www.semanticscholar.org/paper/2282bf60c3e086b8e3f43e891bb2de26a0664508},
  abstract = {Test-based automatic program repair has attracted a lot of attention in recent years However, the test suites in practice are often too weak to guarantee correctness and existing approaches often generate a large number of incorrect patches. To reduce the number of incorrect patches generated, we propose a novel approach that heuristically determines the correctness of the generated patches. The core idea is to exploit the behavior similarity of test case executions. The passing tests on original and patched programs are likely to behave similarly while the failing tests on original and patched programs are likely to behave differently. Also, if two tests exhibit similar runtime behavior, the two tests are likely to have the same test results. Based on these observations, we generate new test inputs to enhance the test suites and use their behavior similarity to determine patch correctness. Our approach is evaluated on a dataset consisting of 139 patches generated from existing program repair systems including jGenProg, Nopol, jKali, ACS, and HDRepair. Our approach successfully prevented 56.3\% of the incorrect patches to be generated, without blocking any correct patches.}
}

@article{liuIdentifyingPatchCorrectness2017a,
  title = {Identifying {{Patch Correctness}} in {{Test-Based Program Repair}}},
  author = {Liu, Xinyuan and Zeng, Muhan and Xiong, Yingfei and Zhang, Lu and Huang, Gang},
  date = {2017},
  journaltitle = {2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)},
  volume = {null},
  pages = {789--799},
  doi = {10.1145/3180155.3180182},
  url = {https://www.semanticscholar.org/paper/2282bf60c3e086b8e3f43e891bb2de26a0664508},
  abstract = {Test-based automatic program repair has attracted a lot of attention in recent years However, the test suites in practice are often too weak to guarantee correctness and existing approaches often generate a large number of incorrect patches. To reduce the number of incorrect patches generated, we propose a novel approach that heuristically determines the correctness of the generated patches. The core idea is to exploit the behavior similarity of test case executions. The passing tests on original and patched programs are likely to behave similarly while the failing tests on original and patched programs are likely to behave differently. Also, if two tests exhibit similar runtime behavior, the two tests are likely to have the same test results. Based on these observations, we generate new test inputs to enhance the test suites and use their behavior similarity to determine patch correctness. Our approach is evaluated on a dataset consisting of 139 patches generated from existing program repair systems including jGenProg, Nopol, jKali, ACS, and HDRepair. Our approach successfully prevented 56.3\% of the incorrect patches to be generated, without blocking any correct patches.}
}

@article{liuUnderstandingUserBotInteractions2020,
  title = {Understanding {{User-Bot Interactions}} for {{Small-Scale Automation}} in {{Open-Source Development}}},
  author = {Liu, Dongyu and Smith, Micah J. and Veeramachaneni, K.},
  date = {2020},
  journaltitle = {Extended Abstracts of the 2020 CHI Conference on Human Factors in Computing Systems},
  volume = {null},
  pages = {null},
  doi = {10.1145/3334480.3382998},
  url = {https://www.semanticscholar.org/paper/697651734f9f083333217a2c0f52350a65d0e9db},
  abstract = {Small-scale automation tools, or "bots," have been widely deployed in open-source software development to support manual project maintenance tasks. Though interactions between these bots and human developers can have significant effects on user experience, previous research has instead mostly focused on project outcomes. We reviewed existing small-scale bots in wide use on GitHub. After an in-depth qualitative and quantitative evaluation, we compiled several important design principles for human-bot interaction in this context. Following the requirements, we further propose a workflow to support bot developers.}
}

@article{liuUnderstandingUserBotInteractions2020a,
  title = {Understanding {{User-Bot Interactions}} for {{Small-Scale Automation}} in {{Open-Source Development}}},
  author = {Liu, Dongyu and Smith, Micah J. and Veeramachaneni, K.},
  date = {2020},
  journaltitle = {Extended Abstracts of the 2020 CHI Conference on Human Factors in Computing Systems},
  volume = {null},
  pages = {null},
  doi = {10.1145/3334480.3382998},
  url = {https://www.semanticscholar.org/paper/697651734f9f083333217a2c0f52350a65d0e9db},
  abstract = {Small-scale automation tools, or "bots," have been widely deployed in open-source software development to support manual project maintenance tasks. Though interactions between these bots and human developers can have significant effects on user experience, previous research has instead mostly focused on project outcomes. We reviewed existing small-scale bots in wide use on GitHub. After an in-depth qualitative and quantitative evaluation, we compiled several important design principles for human-bot interaction in this context. Following the requirements, we further propose a workflow to support bot developers.}
}

@article{liuYouCannotFix2018,
  title = {You {{Cannot Fix What You Cannot Find}}! {{An Investigation}} of {{Fault Localization Bias}} in {{Benchmarking Automated Program Repair Systems}}},
  author = {Liu, Kui and Koyuncu, Anil and Bissyandé, Tegawendé F. and Kim, Dongsun and Klein, Jacques and Traon, Yves Le},
  date = {2018},
  journaltitle = {2019 12th IEEE Conference on Software Testing, Validation and Verification (ICST)},
  volume = {null},
  pages = {102--113},
  doi = {10.1109/ICST.2019.00020},
  url = {https://www.semanticscholar.org/paper/b3c80050efb72248e80fe33b91b84aa123e176d9},
  abstract = {Properly benchmarking Automated Program Repair (APR) systems should contribute to the development and adoption of the research outputs by practitioners. To that end, the research community must ensure that it reaches significant milestones by reliably comparing state-of-the-art tools for a better understanding of their strengths and weaknesses. In this work, we identify and investigate a practical bias caused by the fault localization (FL) step in a repair pipeline. We propose to highlight the different fault localization configurations used in the literature, and their impact on APR systems when applied to the Defects4J benchmark. Then, we explore the performance variations that can be achieved by "tweaking" the FL step. Eventually, we expect to create a new momentum for (1) full disclosure of APR experimental procedures with respect to FL, (2) realistic expectations of repairing bugs in Defects4J, as well as (3) reliable performance comparison among the state-of-theart APR systems, and against the baseline performance results of our thoroughly assessed kPAR repair tool. Our main findings include: (a) only a subset of Defects4J bugs can be currently localized by commonly-used FL techniques; (b) current practice of comparing state-of-the-art APR systems (i.e., counting the number of fixed bugs) is potentially misleading due to the bias of FL configurations; and (c) APR authors do not properly qualify their performance achievement with respect to the different tuning parameters implemented in APR systems.}
}

@article{liuYouCannotFix2018a,
  title = {You {{Cannot Fix What You Cannot Find}}! {{An Investigation}} of {{Fault Localization Bias}} in {{Benchmarking Automated Program Repair Systems}}},
  author = {Liu, Kui and Koyuncu, Anil and Bissyandé, Tegawendé F. and Kim, Dongsun and Klein, Jacques and Traon, Yves Le},
  date = {2018},
  journaltitle = {2019 12th IEEE Conference on Software Testing, Validation and Verification (ICST)},
  volume = {null},
  pages = {102--113},
  doi = {10.1109/ICST.2019.00020},
  url = {https://www.semanticscholar.org/paper/b3c80050efb72248e80fe33b91b84aa123e176d9},
  abstract = {Properly benchmarking Automated Program Repair (APR) systems should contribute to the development and adoption of the research outputs by practitioners. To that end, the research community must ensure that it reaches significant milestones by reliably comparing state-of-the-art tools for a better understanding of their strengths and weaknesses. In this work, we identify and investigate a practical bias caused by the fault localization (FL) step in a repair pipeline. We propose to highlight the different fault localization configurations used in the literature, and their impact on APR systems when applied to the Defects4J benchmark. Then, we explore the performance variations that can be achieved by "tweaking" the FL step. Eventually, we expect to create a new momentum for (1) full disclosure of APR experimental procedures with respect to FL, (2) realistic expectations of repairing bugs in Defects4J, as well as (3) reliable performance comparison among the state-of-theart APR systems, and against the baseline performance results of our thoroughly assessed kPAR repair tool. Our main findings include: (a) only a subset of Defects4J bugs can be currently localized by commonly-used FL techniques; (b) current practice of comparing state-of-the-art APR systems (i.e., counting the number of fixed bugs) is potentially misleading due to the bias of FL configurations; and (c) APR authors do not properly qualify their performance achievement with respect to the different tuning parameters implemented in APR systems.}
}

@article{maClusteringMethodPruning2013,
  title = {A Clustering Method for Pruning False Positive of Clonde Code Detection},
  author = {Ma, Peijun and Bian, Yixin and Su, Xiaohong},
  date = {2013},
  journaltitle = {Proceedings 2013 International Conference on Mechatronic Sciences, Electric Engineering and Computer (MEC)},
  volume = {null},
  pages = {1917--1920},
  doi = {10.1109/MEC.2013.6885366},
  url = {https://www.semanticscholar.org/paper/7925027824c90a7b603944c6b05c84b77a36011d},
  abstract = {There are some false positives when detect syntax similar cloned code with clone code technology based on token. In this paper, we propose a novel algorithm to automatically prune false positives of clone code detection by performing clustering with different attribute and weights. First, closely related statements are grouped into a cluster by performing clustering. Second, compare the hash values of the statements in the two clusters to prune false positives. The experimental results show that our method can effectively prune clone code false positives caused by switching the orders of same structure statements. It not only improves the accuracy of cloned code detection and cloned code related defects detection but also contribute to the following study of cloned code refactorings.}
}

@article{maClusteringMethodPruning2013a,
  title = {A Clustering Method for Pruning False Positive of Clonde Code Detection},
  author = {Ma, Peijun and Bian, Yixin and Su, Xiaohong},
  date = {2013},
  journaltitle = {Proceedings 2013 International Conference on Mechatronic Sciences, Electric Engineering and Computer (MEC)},
  volume = {null},
  pages = {1917--1920},
  doi = {10.1109/MEC.2013.6885366},
  url = {https://www.semanticscholar.org/paper/7925027824c90a7b603944c6b05c84b77a36011d},
  abstract = {There are some false positives when detect syntax similar cloned code with clone code technology based on token. In this paper, we propose a novel algorithm to automatically prune false positives of clone code detection by performing clustering with different attribute and weights. First, closely related statements are grouped into a cluster by performing clustering. Second, compare the hash values of the statements in the two clusters to prune false positives. The experimental results show that our method can effectively prune clone code false positives caused by switching the orders of same structure statements. It not only improves the accuracy of cloned code detection and cloned code related defects detection but also contribute to the following study of cloned code refactorings.}
}

@article{marcosRefactoringBeefCattleFarm2011,
  title = {Refactoring of a {{Beef-Cattle Farm Simulator}}},
  author = {Marcos, C. and Vidal, S. and Abait, E. and Arroqui, M. and Sampaoli, S.},
  date = {2011},
  journaltitle = {IEEE Latin America Transactions},
  volume = {9},
  pages = {1099--1104},
  doi = {10.1109/TLA.2011.6129709},
  url = {https://www.semanticscholar.org/paper/7ec9b163c0d6a512374842d83fb4bd80c4095611},
  abstract = {Software systems are continuing changing because of new functionality has to be incorporated or the exiting one has to be changed. Systems have to be well evolved otherwise the will not be easily changed. Aspect orientation provides mechanisms to evolve and maintain systems by encapsulating systems crosscutting concerns in aspects. We have developed an object oriented grazed-based beef cattle simulator which has maintenance and evolution problems. For this reason, in order to take advantages of the aspect orientation we present in this work the migration of the simulator to the aspect orientation. The crosscutting concerns identified in the object-oriented system are presented and how these crosscutting concerns are transformed into aspect in the target aspect-oriented system.}
}

@article{marcosRefactoringBeefCattleFarm2011a,
  title = {Refactoring of a {{Beef-Cattle Farm Simulator}}},
  author = {Marcos, C. and Vidal, S. and Abait, E. and Arroqui, M. and Sampaoli, S.},
  date = {2011},
  journaltitle = {IEEE Latin America Transactions},
  volume = {9},
  pages = {1099--1104},
  doi = {10.1109/TLA.2011.6129709},
  url = {https://www.semanticscholar.org/paper/7ec9b163c0d6a512374842d83fb4bd80c4095611},
  abstract = {Software systems are continuing changing because of new functionality has to be incorporated or the exiting one has to be changed. Systems have to be well evolved otherwise the will not be easily changed. Aspect orientation provides mechanisms to evolve and maintain systems by encapsulating systems crosscutting concerns in aspects. We have developed an object oriented grazed-based beef cattle simulator which has maintenance and evolution problems. For this reason, in order to take advantages of the aspect orientation we present in this work the migration of the simulator to the aspect orientation. The crosscutting concerns identified in the object-oriented system are presented and how these crosscutting concerns are transformed into aspect in the target aspect-oriented system.}
}

@article{martinExplainableSoftwareBot2019,
  title = {Explainable {{Software Bot Contributions}}: {{Case Study}} of {{Automated Bug Fixes}}},
  author = {Martin, Monperrus},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {12--15},
  doi = {10.1109/BotSE.2019.00010},
  url = {https://www.semanticscholar.org/paper/69cd85d2a55445ff0940c9611fdf00eb02b30c69},
  abstract = {In a software project, esp. in open-source, a contribution is a valuable piece of work made to the project: writing code, reporting bugs, translating, improving documentation, creating graphics, etc. We are now at the beginning of an exciting era where software bots will make contributions that are of similar nature than those by humans. Dry contributions, with no explanation, are often ignored or rejected, because the contribution is not understandable per se, because they are not put into a larger context, because they are not grounded on idioms shared by the core community of developers. We have been operating a program repair bot called Repairnator for 2 years and noticed the problem of "dry patches": a patch that does not say which bug it fixes, or that does not explain the effects of the patch on the system. We envision program repair systems that produce an "explainable bug fix": an integrated package of at least 1) a patch, 2) its explanation in natural or controlled language, and 3) a highlight of the behavioral difference with examples. In this paper, we generalize and suggest that software bot contributions must explainable, that they must be put into the context of the global software development conversation.}
}

@article{martinExplainableSoftwareBot2019a,
  title = {Explainable {{Software Bot Contributions}}: {{Case Study}} of {{Automated Bug Fixes}}},
  author = {Martin, Monperrus},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {12--15},
  doi = {10.1109/BotSE.2019.00010},
  url = {https://www.semanticscholar.org/paper/69cd85d2a55445ff0940c9611fdf00eb02b30c69},
  abstract = {In a software project, esp. in open-source, a contribution is a valuable piece of work made to the project: writing code, reporting bugs, translating, improving documentation, creating graphics, etc. We are now at the beginning of an exciting era where software bots will make contributions that are of similar nature than those by humans. Dry contributions, with no explanation, are often ignored or rejected, because the contribution is not understandable per se, because they are not put into a larger context, because they are not grounded on idioms shared by the core community of developers. We have been operating a program repair bot called Repairnator for 2 years and noticed the problem of "dry patches": a patch that does not say which bug it fixes, or that does not explain the effects of the patch on the system. We envision program repair systems that produce an "explainable bug fix": an integrated package of at least 1) a patch, 2) its explanation in natural or controlled language, and 3) a highlight of the behavioral difference with examples. In this paper, we generalize and suggest that software bot contributions must explainable, that they must be put into the context of the global software development conversation.}
}

@article{martinezAstorExploringDesign2018,
  title = {Astor: {{Exploring}} the {{Design Space}} of {{Generate-and-Validate Program Repair}} beyond {{GenProg}}},
  author = {Martinez, Matias and Martin, Monperrus},
  date = {2018},
  journaltitle = {J. Syst. Softw.},
  volume = {151},
  pages = {65--80},
  doi = {10.1016/j.jss.2019.01.069},
  url = {https://www.semanticscholar.org/paper/dc09409c3e9c63d39c64162f540eefe6a5734caf},
  abstract = {S2 TL;DR: The goal is to facilitate the design, development and evaluation of repair approaches by providing a framework that contains components commonly present in approaches implementations thus new approaches can be built over them, and provides built-in implementations of existing repair approach.}
}

@article{martinezAstorExploringDesign2018a,
  title = {Astor: {{Exploring}} the {{Design Space}} of {{Generate-and-Validate Program Repair}} beyond {{GenProg}}},
  author = {Martinez, Matias and Martin, Monperrus},
  date = {2018},
  journaltitle = {J. Syst. Softw.},
  volume = {151},
  pages = {65--80},
  doi = {10.1016/j.jss.2019.01.069},
  url = {https://www.semanticscholar.org/paper/dc09409c3e9c63d39c64162f540eefe6a5734caf},
  abstract = {S2 TL;DR: The goal is to facilitate the design, development and evaluation of repair approaches by providing a framework that contains components commonly present in approaches implementations thus new approaches can be built over them, and provides built-in implementations of existing repair approach.}
}

@article{martinezOpenendedExplorationProgram2017,
  title = {Open-Ended {{Exploration}} of the {{Program Repair Search Space}} with {{Mined Templates}}: The {{Next}} 8935 {{Patches}} for {{Defects4J}}},
  author = {Martinez, Matias and Martin, Monperrus},
  date = {2017},
  journaltitle = {ArXiv},
  volume = {abs/1712.03854},
  pages = {null},
  url = {https://www.semanticscholar.org/paper/2398dc4913fc899dc3407e82bc9df8dc8f0aff61},
  abstract = {In this paper our goal is to perform an open-ended exploration of the program repair search space. Our idea is to collect the largest number of test-suite adequate patches, independently of whether they are fully correct or overfitting. For that, we design Cardumen, a repair approach based mined templates that has an ultra-large search space. We evaluate the capacity of Cardumen to discover test-suite adequate patches (aka plausible patches) over the 356 real bugs from Defects4J by Just et al. (2014). Cardumen finds 8935 patches over 77 bugs of Defects4J. This is the largest number of automatically synthesized patches ever reported, all patches being available in an open- science repository. Moreover, Cardumen identifies 8 unique patches, that are patches for Defects4J bugs that were never repaired in the whole history of program repair.}
}

@article{martinezOpenendedExplorationProgram2017a,
  title = {Open-Ended {{Exploration}} of the {{Program Repair Search Space}} with {{Mined Templates}}: The {{Next}} 8935 {{Patches}} for {{Defects4J}}},
  author = {Martinez, Matias and Martin, Monperrus},
  date = {2017},
  journaltitle = {ArXiv},
  volume = {abs/1712.03854},
  pages = {null},
  url = {https://www.semanticscholar.org/paper/2398dc4913fc899dc3407e82bc9df8dc8f0aff61},
  abstract = {In this paper our goal is to perform an open-ended exploration of the program repair search space. Our idea is to collect the largest number of test-suite adequate patches, independently of whether they are fully correct or overfitting. For that, we design Cardumen, a repair approach based mined templates that has an ultra-large search space. We evaluate the capacity of Cardumen to discover test-suite adequate patches (aka plausible patches) over the 356 real bugs from Defects4J by Just et al. (2014). Cardumen finds 8935 patches over 77 bugs of Defects4J. This is the largest number of automatically synthesized patches ever reported, all patches being available in an open- science repository. Moreover, Cardumen identifies 8 unique patches, that are patches for Defects4J bugs that were never repaired in the whole history of program repair.}
}

@article{martinezUltraLargeRepairSearch2017,
  title = {Ultra-{{Large Repair Search Space}} with {{Automatically Mined Templates}}: {{The Cardumen Mode}} of {{Astor}}},
  author = {Martinez, Matias and Martin, Monperrus},
  date = {2017},
  doi = {10.1007/978-3-319-99241-9_3},
  url = {https://www.semanticscholar.org/paper/f03aba6ceaeb8d6b78c6a5b76d13e01fd7147c8d},
  abstract = {S2 TL;DR: This paper evaluates the capacity of Cardumen to discover test-suite adequate patches (aka plausible patches) over the 356 real bugs from Defects4J and presents the Cardumen mode of Astor, a repair approach based mined templates that has an ultra-large search space.}
}

@article{martinezUltraLargeRepairSearch2017a,
  title = {Ultra-{{Large Repair Search Space}} with {{Automatically Mined Templates}}: {{The Cardumen Mode}} of {{Astor}}},
  author = {Martinez, Matias and Martin, Monperrus},
  date = {2017},
  doi = {10.1007/978-3-319-99241-9_3},
  url = {https://www.semanticscholar.org/paper/f03aba6ceaeb8d6b78c6a5b76d13e01fd7147c8d},
  abstract = {S2 TL;DR: This paper evaluates the capacity of Cardumen to discover test-suite adequate patches (aka plausible patches) over the 356 real bugs from Defects4J and presents the Cardumen mode of Astor, a repair approach based mined templates that has an ultra-large search space.}
}

@article{martinRepairnatorPatchesPrograms2019,
  title = {Repairnator Patches Programs Automatically},
  author = {Martin, Monperrus and Urli, Simon and Durieux, Thomas and Martinez, Matias and Baudry, B. and Seinturier, L.},
  date = {2019},
  journaltitle = {Ubiquity},
  volume = {2019},
  pages = {1--12},
  doi = {10.1145/3349589},
  url = {https://www.semanticscholar.org/paper/8b2de753e347c7ecc2c7774d73ad7a54f05e7608},
  abstract = {Repairnator is a bot. It constantly monitors software bugs discovered during continuous integration of open-source software and tries to fix them automatically. If it succeeds in synthesizing a valid patch, Repairnator proposes the patch to the human developers, disguised under a fake human identity. To date, Repairnator has been able to produce patches that were accepted by the human developers and permanently merged into the code base. This is a milestone for human-competitiveness in software engineering research on automatic program repair.}
}

@article{martinRepairnatorPatchesPrograms2019a,
  title = {Repairnator Patches Programs Automatically},
  author = {Martin, Monperrus and Urli, Simon and Durieux, Thomas and Martinez, Matias and Baudry, B. and Seinturier, L.},
  date = {2019},
  journaltitle = {Ubiquity},
  volume = {2019},
  pages = {1--12},
  doi = {10.1145/3349589},
  url = {https://www.semanticscholar.org/paper/8b2de753e347c7ecc2c7774d73ad7a54f05e7608},
  abstract = {Repairnator is a bot. It constantly monitors software bugs discovered during continuous integration of open-source software and tries to fix them automatically. If it succeeds in synthesizing a valid patch, Repairnator proposes the patch to the human developers, disguised under a fake human identity. To date, Repairnator has been able to produce patches that were accepted by the human developers and permanently merged into the code base. This is a milestone for human-competitiveness in software engineering research on automatic program repair.}
}

@inproceedings{mealyEvaluatingSoftwareRefactoring2006,
  title = {Evaluating Software Refactoring Tool Support},
  booktitle = {Australian {{Software Engineering Conference}} ({{ASWEC}}'06)},
  author = {Mealy, E. and Strooper, P.},
  date = {2006},
  pages = {10 pp.-340},
  doi = {10.1109/ASWEC.2006.26}
}

@inproceedings{mealyEvaluatingSoftwareRefactoring2006a,
  title = {Evaluating Software Refactoring Tool Support},
  booktitle = {Australian {{Software Engineering Conference}} ({{ASWEC}}'06)},
  author = {Mealy, E. and Strooper, P.},
  date = {2006},
  pages = {10 pp.-340},
  doi = {10.1109/ASWEC.2006.26}
}

@article{meananeatraRefactoringOpportunityIdentification2018,
  title = {Refactoring {{Opportunity Identification Methodology}} for {{Removing Long Method Smells}} and {{Improving Code Analyzability}}},
  author = {Meananeatra, Panita and Rongviriyapanish, S. and Apiwattanapong, Taweesup},
  date = {2018},
  journaltitle = {IEICE Trans. Inf. Syst.},
  volume = {101-D},
  pages = {1766--1779},
  doi = {10.1587/TRANSINF.2017KBP0026},
  url = {https://www.semanticscholar.org/paper/06083b7b568efbd0cbcbba804e86830e2f9e9a9b},
  abstract = {SUMMARY An important step for improving software analyzability is applying refactorings during the maintenance phase to remove bad smells, especially the long method bad smell. Long method bad smell occurs most frequently and is a root cause of other bad smells. However, no research has proposed an approach to repeating refactoring identification, sugges- tion, and application until all long method bad smells have been removed completely without reducing software analyzability. This paper proposes an e ff ective approach to identifying refactoring opportunities and suggesting an e ff ective refactoring set for complete removal of long method bad smell without reducing code analyzability. This approach, called the long method remover or LMR, uses refactoring enabling conditions based on program analysis and code metrics to identify four refactoring techniques and uses a technique embedded in JDeodorant to identify extract method. For e ff ective refactoring set suggestion, LMR uses two criteria: code analyzability level and the number of statements impacted by the refactorings. LMR also uses side e ff ect analysis to ensure behavior preservation. To evaluate LMR, we apply it to the core package of a real world java appli- cation. Our evaluation criteria are 1) the preservation of code functionality, 2) the removal rate of long method characteristics, and 3) the improvement on analyzability. The result showed that the methods that apply suggested refactoring sets can completely remove long method bad smell, still have behavior preservation, and have not decreased analyzability. It is concluded that LMR meets the objectives in almost all classes. We also discussed the issues we found during evaluation as lesson learned.}
}

@article{meananeatraRefactoringOpportunityIdentification2018a,
  title = {Refactoring {{Opportunity Identification Methodology}} for {{Removing Long Method Smells}} and {{Improving Code Analyzability}}},
  author = {Meananeatra, Panita and Rongviriyapanish, S. and Apiwattanapong, Taweesup},
  date = {2018},
  journaltitle = {IEICE Trans. Inf. Syst.},
  volume = {101-D},
  pages = {1766--1779},
  doi = {10.1587/TRANSINF.2017KBP0026},
  url = {https://www.semanticscholar.org/paper/06083b7b568efbd0cbcbba804e86830e2f9e9a9b},
  abstract = {SUMMARY An important step for improving software analyzability is applying refactorings during the maintenance phase to remove bad smells, especially the long method bad smell. Long method bad smell occurs most frequently and is a root cause of other bad smells. However, no research has proposed an approach to repeating refactoring identification, sugges- tion, and application until all long method bad smells have been removed completely without reducing software analyzability. This paper proposes an e ff ective approach to identifying refactoring opportunities and suggesting an e ff ective refactoring set for complete removal of long method bad smell without reducing code analyzability. This approach, called the long method remover or LMR, uses refactoring enabling conditions based on program analysis and code metrics to identify four refactoring techniques and uses a technique embedded in JDeodorant to identify extract method. For e ff ective refactoring set suggestion, LMR uses two criteria: code analyzability level and the number of statements impacted by the refactorings. LMR also uses side e ff ect analysis to ensure behavior preservation. To evaluate LMR, we apply it to the core package of a real world java appli- cation. Our evaluation criteria are 1) the preservation of code functionality, 2) the removal rate of long method characteristics, and 3) the improvement on analyzability. The result showed that the methods that apply suggested refactoring sets can completely remove long method bad smell, still have behavior preservation, and have not decreased analyzability. It is concluded that LMR meets the objectives in almost all classes. We also discussed the issues we found during evaluation as lesson learned.}
}

@article{mendesIdentifyingUtilityFunctions2016,
  title = {Identifying {{Utility Functions}} in {{Java}} and {{JavaScript}}},
  author = {Mendes, Tamara and Valente, M. T. and Hora, André C.},
  date = {2016},
  journaltitle = {2016 X Brazilian Symposium on Software Components, Architectures and Reuse (SBCARS)},
  volume = {null},
  pages = {121--130},
  doi = {10.1109/SBCARS.2016.16},
  url = {https://www.semanticscholar.org/paper/fff19b7eedf93225c910c067cce950dc15778385},
  abstract = {Utility functions provide generic services that can be reused in different types of systems. Theoretically, they must be implemented in specific modules. However, it is common to find such functions implemented with domain specific functions, decreasing their chances of reuse. In this paper, we propose a set of heuristics to identify utility functions. With such heuristics, recommendations can be provided to move the functions to appropriate modules. In a survey conducted with 33 developers, the proposed heuristics showed a precision of 66\% and 67\% when applied to Java and JavaScript systems, respectively.}
}

@article{mendesIdentifyingUtilityFunctions2016a,
  title = {Identifying {{Utility Functions}} in {{Java}} and {{JavaScript}}},
  author = {Mendes, Tamara and Valente, M. T. and Hora, André C.},
  date = {2016},
  journaltitle = {2016 X Brazilian Symposium on Software Components, Architectures and Reuse (SBCARS)},
  volume = {null},
  pages = {121--130},
  doi = {10.1109/SBCARS.2016.16},
  url = {https://www.semanticscholar.org/paper/fff19b7eedf93225c910c067cce950dc15778385},
  abstract = {Utility functions provide generic services that can be reused in different types of systems. Theoretically, they must be implemented in specific modules. However, it is common to find such functions implemented with domain specific functions, decreasing their chances of reuse. In this paper, we propose a set of heuristics to identify utility functions. With such heuristics, recommendations can be provided to move the functions to appropriate modules. In a survey conducted with 33 developers, the proposed heuristics showed a precision of 66\% and 67\% when applied to Java and JavaScript systems, respectively.}
}

@article{mirhosseiniCanAutomatedPull2017,
  title = {Can Automated Pull Requests Encourage Software Developers to Upgrade Out-of-Date Dependencies?},
  author = {Mirhosseini, Samim and Parnin, Chris},
  date = {2017},
  journaltitle = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  volume = {null},
  pages = {84--94},
  doi = {10.1109/ASE.2017.8115621},
  url = {https://www.semanticscholar.org/paper/14515004dd9c5e0fff89223066efde9f4b5044a0},
  abstract = {Developers neglect to update legacy software dependencies, resulting in buggy and insecure software. One explanation for this neglect is the difficulty of constantly checking for the availability of new software updates, verifying their safety, and addressing any migration efforts needed when upgrading a dependency. Emerging tools attempt to address this problem by introducing automated pull requests and project badges to inform the developer of stale dependencies. To understand whether these tools actually help developers, we analyzed 7,470 GitHub projects that used these notification mechanisms to identify any change in upgrade behavior. Our results find that, on average, projects that use pull request notifications upgraded 1.6× as often as projects that did not use any tools. Badge notifications were slightly less effective: users upgraded 1.4× more frequently. Unfortunately, although pull request notifications are useful, developers are often overwhelmed by notifications: only a third of pull requests were actually merged. Through a survey, 62 developers indicated that their most significant concerns are breaking changes, understanding the implications of changes, and migration effort. The implications of our work suggests ways in which notifications can be improved to better align with developers' expectations and the need for new mechanisms to reduce notification fatigue and improve confidence in automated pull requests.}
}

@article{mirhosseiniCanAutomatedPull2017a,
  title = {Can Automated Pull Requests Encourage Software Developers to Upgrade Out-of-Date Dependencies?},
  author = {Mirhosseini, Samim and Parnin, Chris},
  date = {2017},
  journaltitle = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  volume = {null},
  pages = {84--94},
  doi = {10.1109/ASE.2017.8115621},
  url = {https://www.semanticscholar.org/paper/14515004dd9c5e0fff89223066efde9f4b5044a0},
  abstract = {Developers neglect to update legacy software dependencies, resulting in buggy and insecure software. One explanation for this neglect is the difficulty of constantly checking for the availability of new software updates, verifying their safety, and addressing any migration efforts needed when upgrading a dependency. Emerging tools attempt to address this problem by introducing automated pull requests and project badges to inform the developer of stale dependencies. To understand whether these tools actually help developers, we analyzed 7,470 GitHub projects that used these notification mechanisms to identify any change in upgrade behavior. Our results find that, on average, projects that use pull request notifications upgraded 1.6× as often as projects that did not use any tools. Badge notifications were slightly less effective: users upgraded 1.4× more frequently. Unfortunately, although pull request notifications are useful, developers are often overwhelmed by notifications: only a third of pull requests were actually merged. Through a survey, 62 developers indicated that their most significant concerns are breaking changes, understanding the implications of changes, and migration effort. The implications of our work suggests ways in which notifications can be improved to better align with developers' expectations and the need for new mechanisms to reduce notification fatigue and improve confidence in automated pull requests.}
}

@article{mkaouerRobustMultiobjectiveApproach2017,
  title = {A Robust Multi-Objective Approach to Balance Severity and Importance of Refactoring Opportunities},
  author = {Mkaouer, Mohamed Wiem and Kessentini, M. and Cinnéide, M. O. and Hayashi, Shinpei and Deb, K.},
  date = {2017},
  journaltitle = {Empirical Software Engineering},
  volume = {22},
  pages = {894--927},
  doi = {10.1007/s10664-016-9426-8},
  url = {https://www.semanticscholar.org/paper/2e18365b26149eefa77aa6433acacb122cf5d3bb},
  abstract = {S2 TL;DR: This work introduced a multi-objective robust model, based on NSGA-II, for the software refactoring problem that tries to find the best trade-off between three objectives to maximize: quality improvements, severity and importance ofRefactoring opportunities to be fixed.}
}

@article{mkaouerRobustMultiobjectiveApproach2017a,
  title = {A Robust Multi-Objective Approach to Balance Severity and Importance of Refactoring Opportunities},
  author = {Mkaouer, Mohamed Wiem and Kessentini, M. and Cinnéide, M. O. and Hayashi, Shinpei and Deb, K.},
  date = {2017},
  journaltitle = {Empirical Software Engineering},
  volume = {22},
  pages = {894--927},
  doi = {10.1007/s10664-016-9426-8},
  url = {https://www.semanticscholar.org/paper/2e18365b26149eefa77aa6433acacb122cf5d3bb},
  abstract = {S2 TL;DR: This work introduced a multi-objective robust model, based on NSGA-II, for the software refactoring problem that tries to find the best trade-off between three objectives to maximize: quality improvements, severity and importance ofRefactoring opportunities to be fixed.}
}

@article{mohaDECORMethodSpecification2010,
  title = {{{DECOR}}: {{A Method}} for the {{Specification}} and {{Detection}} of {{Code}} and {{Design Smells}}},
  author = {Moha, Naouel and Guéhéneuc, Yann-Gaël and Duchien, L. and Meur, A. L.},
  date = {2010},
  journaltitle = {IEEE Transactions on Software Engineering},
  volume = {36},
  pages = {20--36},
  doi = {10.1109/TSE.2009.50},
  url = {https://www.semanticscholar.org/paper/f5ff5578727727a32deeaa990607818a14f74172},
  abstract = {Code and design smells are poor solutions to recurring implementation and design problems. They may hinder the evolution of a system by making it hard for software engineers to carry out changes. We propose three contributions to the research field related to code and design smells: (1) DECOR, a method that embodies and defines all the steps necessary for the specification and detection of code and design smells, (2) DETEX, a detection technique that instantiates this method, and (3) an empirical validation in terms of precision and recall of DETEX. The originality of DETEX stems from the ability for software engineers to specify smells at a high level of abstraction using a consistent vocabulary and domain-specific language for automatically generating detection algorithms. Using DETEX, we specify four well-known design smells: the antipatterns Blob, Functional Decomposition, Spaghetti Code, and Swiss Army Knife, and their 15 underlying code smells, and we automatically generate their detection algorithms. We apply and validate the detection algorithms in terms of precision and recall on XERCES v2.7.0, and discuss the precision of these algorithms on 11 open-source systems.}
}

@article{mohanMaximizingRefactoringCoverage2019,
  title = {Maximizing {{Refactoring Coverage}} in an {{Automated Maintenance Approach Using Multi-Objective Optimization}}},
  author = {Mohan, M. and Greer, D. and McMullan, P.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 3rd International Workshop on Refactoring (IWoR)},
  volume = {null},
  pages = {31--38},
  doi = {10.1109/IWoR.2019.00014},
  url = {https://www.semanticscholar.org/paper/3ea42e985c1bf8cd10d8b00b3f05067cd8fae18d},
  abstract = {This paper describes a multi-objective genetic algorithm used to automate software refactoring. The approach is validated using a set of open source Java programs with a purpose built tool, MultiRefactor. The tool uses a metric function to measure quality in a software system and tests a second objective to measure the amount of code coverage of the applied refactorings by analyzing the code elements they have been applied to. The multi-objective setup will refactor the input program to improve its quality using the quality objective, while also maximizing the code coverage of the refactorings applied to the software. An experiment has been constructed to measure the multi-objective approach against the alternative mono-objective approach that does not use an objective to measure refactoring coverage. The two approaches are tested on six different open source Java programs. The multi-objective approach is found to give significantly better refactoring coverage scores across all inputs in a similar time, while also generating improvements in the quality scores.}
}

@article{mohanMaximizingRefactoringCoverage2019a,
  title = {Maximizing {{Refactoring Coverage}} in an {{Automated Maintenance Approach Using Multi-Objective Optimization}}},
  author = {Mohan, M. and Greer, D. and McMullan, P.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 3rd International Workshop on Refactoring (IWoR)},
  volume = {null},
  pages = {31--38},
  doi = {10.1109/IWoR.2019.00014},
  url = {https://www.semanticscholar.org/paper/3ea42e985c1bf8cd10d8b00b3f05067cd8fae18d},
  abstract = {This paper describes a multi-objective genetic algorithm used to automate software refactoring. The approach is validated using a set of open source Java programs with a purpose built tool, MultiRefactor. The tool uses a metric function to measure quality in a software system and tests a second objective to measure the amount of code coverage of the applied refactorings by analyzing the code elements they have been applied to. The multi-objective setup will refactor the input program to improve its quality using the quality objective, while also maximizing the code coverage of the refactorings applied to the software. An experiment has been constructed to measure the multi-objective approach against the alternative mono-objective approach that does not use an objective to measure refactoring coverage. The two approaches are tested on six different open source Java programs. The multi-objective approach is found to give significantly better refactoring coverage scores across all inputs in a similar time, while also generating improvements in the quality scores.}
}

@article{mohanMultiRefactorAutomatedRefactoring2017,
  title = {{{MultiRefactor}}: {{Automated Refactoring To Improve Software Quality}}},
  author = {Mohan, M. and Greer, D.},
  date = {2017},
  doi = {10.1007/978-3-319-69926-4_46},
  url = {https://www.semanticscholar.org/paper/907b12f303c40d281118763f97eecbce564e7cd5},
  abstract = {S2 TL;DR: A new approach is proposed for automated software maintenance that generates suitable improvements in quality in less time, allowing for rapid maintenance cycles and also presents some research results from experimentation.}
}

@article{mohanMultiRefactorAutomatedRefactoring2017a,
  title = {{{MultiRefactor}}: {{Automated Refactoring To Improve Software Quality}}},
  author = {Mohan, M. and Greer, D.},
  date = {2017},
  doi = {10.1007/978-3-319-69926-4_46},
  url = {https://www.semanticscholar.org/paper/907b12f303c40d281118763f97eecbce564e7cd5},
  abstract = {S2 TL;DR: A new approach is proposed for automated software maintenance that generates suitable improvements in quality in less time, allowing for rapid maintenance cycles and also presents some research results from experimentation.}
}

@article{mohanSurveySearchbasedRefactoring2018,
  title = {A Survey of Search-Based Refactoring for Software Maintenance},
  author = {Mohan, M. and Greer, D.},
  date = {2018},
  journaltitle = {Journal of Software Engineering Research and Development},
  volume = {6},
  pages = {1--52},
  doi = {10.1186/s40411-018-0046-4},
  url = {https://www.semanticscholar.org/paper/927e6b52da64caf6effb71ff0e781db305aa292a},
  abstract = {S2 TL;DR: This survey is beneficial as an introduction for any researchers aiming to work in the area of Search-Based Software Engineering with respect to software maintenance to gain an understanding of the current landscape of the research and the insights gathered.}
}

@article{mohanSurveySearchbasedRefactoring2018a,
  title = {A Survey of Search-Based Refactoring for Software Maintenance},
  author = {Mohan, M. and Greer, D.},
  date = {2018},
  journaltitle = {Journal of Software Engineering Research and Development},
  volume = {6},
  pages = {1--52},
  doi = {10.1186/s40411-018-0046-4},
  url = {https://www.semanticscholar.org/paper/927e6b52da64caf6effb71ff0e781db305aa292a},
  abstract = {S2 TL;DR: This survey is beneficial as an introduction for any researchers aiming to work in the area of Search-Based Software Engineering with respect to software maintenance to gain an understanding of the current landscape of the research and the insights gathered.}
}

@article{mohanUsingManyobjectiveApproach2019,
  title = {Using a Many-Objective Approach to Investigate Automated Refactoring},
  author = {Mohan, M. and Greer, D.},
  date = {2019},
  journaltitle = {Inf. Softw. Technol.},
  volume = {112},
  pages = {83--101},
  doi = {10.1016/J.INFSOF.2019.04.009},
  url = {https://www.semanticscholar.org/paper/deb38bb40117ce5ae0dfee8ea377bcf68b938044},
  abstract = {S2 TL;DR: A many-objective approach is suitable and effective for optimising automated refactoring to improve quality and including other objectives does not unduly degrade the quality improvements, but is less effective for those objectives than if they were used in a mono-objectives approach.}
}

@article{mohanUsingManyobjectiveApproach2019a,
  title = {Using a Many-Objective Approach to Investigate Automated Refactoring},
  author = {Mohan, M. and Greer, D.},
  date = {2019},
  journaltitle = {Inf. Softw. Technol.},
  volume = {112},
  pages = {83--101},
  doi = {10.1016/J.INFSOF.2019.04.009},
  url = {https://www.semanticscholar.org/paper/deb38bb40117ce5ae0dfee8ea377bcf68b938044},
  abstract = {S2 TL;DR: A many-objective approach is suitable and effective for optimising automated refactoring to improve quality and including other objectives does not unduly degrade the quality improvements, but is less effective for those objectives than if they were used in a mono-objectives approach.}
}

@article{moralesFindingBestCompromise2016,
  title = {Finding the {{Best Compromise Between Design Quality}} and {{Testing Effort During Refactoring}}},
  author = {Morales, Rodrigo and Sabane, Aminata and Musavi, Pooya and Khomh, F. and Chicano, F. and Antoniol, G.},
  date = {2016},
  journaltitle = {2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
  volume = {1},
  pages = {24--35},
  doi = {10.1109/SANER.2016.23},
  url = {https://www.semanticscholar.org/paper/731e79f92f9b564c788c07a54e1805ab3418b3a9},
  abstract = {Anti-patterns are poor design choices that hinder code evolution, and understandability. Practitioners perform refactoring, that are semantic-preserving-code transformations, to correct anti-patterns and to improve design quality. However, manual refactoring is a consuming task and a heavy burden for developers who have to struggle to complete their coding tasks and maintain the design quality of the system at the same time. For that reason, researchers and practitioners have proposed several approaches to bring automated support to developers, with solutions that ranges from single anti-patterns correction, to multiobjective solutions. The latter approaches attempted to reduce refactoring effort, or to improve semantic similarity between classes and methods in addition to removing anti-patterns. To the best of our knowledge, none of the previous approaches have considered the impact of refactoring on another important aspect of software development, which is the testing effort. In this paper, we propose a novel search-based multiobjective approach for removing five well-known anti-patterns and minimizing testing effort. To assess the effectiveness of our proposed approach, we implement three different multiobjective metaheuristics (NSGA-II, SPEA2, MOCell) and apply them to a benchmark comprised of four open-source systems. Results show that MOCell is the metaheuristic that provides the best performance.}
}

@article{moralesFindingBestCompromise2016a,
  title = {Finding the {{Best Compromise Between Design Quality}} and {{Testing Effort During Refactoring}}},
  author = {Morales, Rodrigo and Sabane, Aminata and Musavi, Pooya and Khomh, F. and Chicano, F. and Antoniol, G.},
  date = {2016},
  journaltitle = {2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
  volume = {1},
  pages = {24--35},
  doi = {10.1109/SANER.2016.23},
  url = {https://www.semanticscholar.org/paper/731e79f92f9b564c788c07a54e1805ab3418b3a9},
  abstract = {Anti-patterns are poor design choices that hinder code evolution, and understandability. Practitioners perform refactoring, that are semantic-preserving-code transformations, to correct anti-patterns and to improve design quality. However, manual refactoring is a consuming task and a heavy burden for developers who have to struggle to complete their coding tasks and maintain the design quality of the system at the same time. For that reason, researchers and practitioners have proposed several approaches to bring automated support to developers, with solutions that ranges from single anti-patterns correction, to multiobjective solutions. The latter approaches attempted to reduce refactoring effort, or to improve semantic similarity between classes and methods in addition to removing anti-patterns. To the best of our knowledge, none of the previous approaches have considered the impact of refactoring on another important aspect of software development, which is the testing effort. In this paper, we propose a novel search-based multiobjective approach for removing five well-known anti-patterns and minimizing testing effort. To assess the effectiveness of our proposed approach, we implement three different multiobjective metaheuristics (NSGA-II, SPEA2, MOCell) and apply them to a benchmark comprised of four open-source systems. Results show that MOCell is the metaheuristic that provides the best performance.}
}

@article{moralesUseDevelopersContext2017,
  title = {On the Use of Developers' Context for Automatic Refactoring of Software Anti-Patterns},
  author = {Morales, Rodrigo and Soh, Z. and Khomh, F. and Antoniol, G. and Chicano, F.},
  date = {2017},
  journaltitle = {J. Syst. Softw.},
  volume = {128},
  pages = {236--251},
  doi = {10.1016/J.JSS.2016.05.042},
  url = {https://www.semanticscholar.org/paper/fc3f345f6e49fe3d544095c3962928edc2ec7ef8},
  abstract = {S2 TL;DR: An automated refactoring approach that leverages information about a developers task and metaheuristics techniques to compute the best sequence of refactorings that affects only entities in the developers context is proposed.}
}

@article{moralesUseDevelopersContext2017a,
  title = {On the Use of Developers' Context for Automatic Refactoring of Software Anti-Patterns},
  author = {Morales, Rodrigo and Soh, Z. and Khomh, F. and Antoniol, G. and Chicano, F.},
  date = {2017},
  journaltitle = {J. Syst. Softw.},
  volume = {128},
  pages = {236--251},
  doi = {10.1016/J.JSS.2016.05.042},
  url = {https://www.semanticscholar.org/paper/fc3f345f6e49fe3d544095c3962928edc2ec7ef8},
  abstract = {S2 TL;DR: An automated refactoring approach that leverages information about a developers task and metaheuristics techniques to compute the best sequence of refactorings that affects only entities in the developers context is proposed.}
}

@article{nader-palacioAssessingSingleobjectivePerformance2018,
  title = {Assessing Single-Objective Performance Convergence and Time Complexity for Refactoring Detection},
  author = {Nader-Palacio, David and Rodríguez-Cárdenas, Daniel and Gómez, Jonatan},
  date = {2018},
  journaltitle = {Proceedings of the Genetic and Evolutionary Computation Conference Companion},
  volume = {null},
  pages = {null},
  doi = {10.1145/3205651.3208294},
  url = {https://www.semanticscholar.org/paper/96e1a73c543016e4ef2c85fe3552bda6d0765998},
  abstract = {The automatic detection of refactoring recommendations has been tackled in prior optimization studies involving bad code smells, semantic coherence and importance of classes; however, such studies informally addressed formalisms to standardize and replicate refactoring models. We propose to assess the refactoring detection by means of performance convergence and time complexity. Since the reported approaches are difficult to reproduce, we employ an Artificial Refactoring Generation (ARGen) as a formal and naive computational solution for the Refactoring Detection Problem. ARGen is able to detect massive refactoring's sets in feasible areas of the search space. We used a refactoring formalization to adapt search techniques (Hill Climbing, Simulated Annealing and Hybrid Adaptive Evolutionary Algorithm) that assess the performance and complexity on three open software systems. Combinatorial techniques are limited in solving the Refactoring Detection Problem due to the relevance of developers' criteria (human factor) when designing reconstructions. Without performance convergence and time complexity analysis, a software empirical analysis that utilizes search techniques is incomplete.}
}

@article{nader-palacioAssessingSingleobjectivePerformance2018a,
  title = {Assessing Single-Objective Performance Convergence and Time Complexity for Refactoring Detection},
  author = {Nader-Palacio, David and Rodríguez-Cárdenas, Daniel and Gómez, Jonatan},
  date = {2018},
  journaltitle = {Proceedings of the Genetic and Evolutionary Computation Conference Companion},
  volume = {null},
  pages = {null},
  doi = {10.1145/3205651.3208294},
  url = {https://www.semanticscholar.org/paper/96e1a73c543016e4ef2c85fe3552bda6d0765998},
  abstract = {The automatic detection of refactoring recommendations has been tackled in prior optimization studies involving bad code smells, semantic coherence and importance of classes; however, such studies informally addressed formalisms to standardize and replicate refactoring models. We propose to assess the refactoring detection by means of performance convergence and time complexity. Since the reported approaches are difficult to reproduce, we employ an Artificial Refactoring Generation (ARGen) as a formal and naive computational solution for the Refactoring Detection Problem. ARGen is able to detect massive refactoring's sets in feasible areas of the search space. We used a refactoring formalization to adapt search techniques (Hill Climbing, Simulated Annealing and Hybrid Adaptive Evolutionary Algorithm) that assess the performance and complexity on three open software systems. Combinatorial techniques are limited in solving the Refactoring Detection Problem due to the relevance of developers' criteria (human factor) when designing reconstructions. Without performance convergence and time complexity analysis, a software empirical analysis that utilizes search techniques is incomplete.}
}

@article{olbrichAreAllCode2010,
  title = {Are All Code Smells Harmful? {{A}} Study of {{God Classes}} and {{Brain Classes}} in the Evolution of Three Open Source Systems},
  author = {Olbrich, Steffen M. and Cruzes, D. and Sjøberg, Dag I. K.},
  date = {2010},
  journaltitle = {2010 IEEE International Conference on Software Maintenance},
  volume = {null},
  pages = {1--10},
  doi = {10.1109/ICSM.2010.5609564},
  url = {https://www.semanticscholar.org/paper/171dbc23ef96bc6c418c9ecc1d1036a4b6f6da6e},
  abstract = {Code smells are particular patterns in object-oriented systems that are perceived to lead to difficulties in the maintenance of such systems. It is held that to improve maintainability, code smells should be eliminated by refactoring. It is claimed that classes that are involved in certain code smells are liable to be changed more frequently and have more defects than other classes in the code. We investigated the extent to which this claim is true for God Classes and Brain Classes, with and without normalizing the effects with respect to the class size. We analyzed historical data from 7 to 10 years of the development of three open-source software systems. The results show that God and Brain Classes were changed more frequently and contained more defects than other kinds of class. However, when we normalized the measured effects with respect to size, then God and Brain Classes were less subject to change and had fewer defects than other classes. Hence, under the assumption that God and Brain Classes contain on average as much functionality per line of code as other classes, the presence of God and Brain Classes is not necessarily harmful; in fact, such classes may be an efficient way of organizing code.}
}

@article{ouniaMultiObjectiveRefactoringApproach2015,
  title = {A {{Multi-Objective Refactoring Approach}} to {{Introduce Design Patterns}} and {{Fix Anti-Patterns}}},
  author = {Ounia, Ali and Kessentinib, Marouane and Sahraouic, Houari and Cinnéided, Mel Ó and Debe, K. and Inouea, Katsuro},
  date = {2015},
  url = {https://www.semanticscholar.org/paper/67ac5f4261c94fd46ccadf6eeabeea593981c966},
  abstract = {Refactoring is widely recognized as a crucial technique applied when evolving object-oriented software systems. Refactoring has promised, if applied well, to improve software readability, maintainability and extendibility. In general, to improve software quality, most of existing studies focus on the correction of anti-patterns or enhancing specific quality metrics. However, this may not be sufficient to make the source code easier to understand and modify. The introduction of design patterns that represent good design practices represents an efficient way improve the quality of systems; but very few works consider the use of refactoring to introduce design patterns. We propose, in this paper, an automated multiobjective refactoring recommendation approach to (1) improve design quality (as defined by software quality metrics), (2) fix anti-patterns, and (3) introduce design patterns. To evaluate our approach, we conducted a quantitative and qualitative evaluation using a benchmark composed of four open source systems. The statistical analysis of the results confirms the efficiency of our proposal compared to the state-of-the-art of refactoring approaches.}
}

@article{ouniaMultiObjectiveRefactoringApproach2015a,
  title = {A {{Multi-Objective Refactoring Approach}} to {{Introduce Design Patterns}} and {{Fix Anti-Patterns}}},
  author = {Ounia, Ali and Kessentinib, Marouane and Sahraouic, Houari and Cinnéided, Mel Ó and Debe, K. and Inouea, Katsuro},
  date = {2015},
  url = {https://www.semanticscholar.org/paper/67ac5f4261c94fd46ccadf6eeabeea593981c966},
  abstract = {Refactoring is widely recognized as a crucial technique applied when evolving object-oriented software systems. Refactoring has promised, if applied well, to improve software readability, maintainability and extendibility. In general, to improve software quality, most of existing studies focus on the correction of anti-patterns or enhancing specific quality metrics. However, this may not be sufficient to make the source code easier to understand and modify. The introduction of design patterns that represent good design practices represents an efficient way improve the quality of systems; but very few works consider the use of refactoring to introduce design patterns. We propose, in this paper, an automated multiobjective refactoring recommendation approach to (1) improve design quality (as defined by software quality metrics), (2) fix anti-patterns, and (3) introduce design patterns. To evaluate our approach, we conducted a quantitative and qualitative evaluation using a benchmark composed of four open source systems. The statistical analysis of the results confirms the efficiency of our proposal compared to the state-of-the-art of refactoring approaches.}
}

@article{ouniImprovingMultiobjectiveCodesmells2015,
  title = {Improving Multi-Objective Code-Smells Correction Using Development History},
  author = {Ouni, Ali and Kessentini, M. and Sahraoui, H. and Inoue, Katsuro and Hamdi, M.},
  date = {2015},
  journaltitle = {J. Syst. Softw.},
  volume = {105},
  pages = {18--39},
  doi = {10.1016/J.JSS.2015.03.040},
  url = {https://www.semanticscholar.org/paper/1affdd5708cb13a83e736700a236e3f2d8e8c10d},
  abstract = {S2 TL;DR: This paper proposes a multi-objective optimization-based approach to find good refactoring sequences that minimize the number of code-smells and maximize the use of development history while preserving the construct semantics, using the non-dominated sorting genetic algorithm (NSGA-II) to find the best trade-offs.}
}

@article{ouniImprovingMultiobjectiveCodesmells2015a,
  title = {Improving Multi-Objective Code-Smells Correction Using Development History},
  author = {Ouni, Ali and Kessentini, M. and Sahraoui, H. and Inoue, Katsuro and Hamdi, M.},
  date = {2015},
  journaltitle = {J. Syst. Softw.},
  volume = {105},
  pages = {18--39},
  doi = {10.1016/J.JSS.2015.03.040},
  url = {https://www.semanticscholar.org/paper/1affdd5708cb13a83e736700a236e3f2d8e8c10d},
  abstract = {S2 TL;DR: This paper proposes a multi-objective optimization-based approach to find good refactoring sequences that minimize the number of code-smells and maximize the use of development history while preserving the construct semantics, using the non-dominated sorting genetic algorithm (NSGA-II) to find the best trade-offs.}
}

@article{ouniMonoMultiobjectiveApproach2014,
  title = {A {{Mono-}} and {{Multi-objective Approach}} For},
  author = {Ouni, Ali},
  date = {2014},
  url = {https://www.semanticscholar.org/paper/25a1e21c7af2c77866b6b3b5e762ff7e3246bfc7},
  abstract = {null}
}

@article{ouniMonoMultiobjectiveApproach2014a,
  title = {A {{Mono-}} and {{Multi-objective Approach}} For},
  author = {Ouni, Ali},
  date = {2014},
  url = {https://www.semanticscholar.org/paper/25a1e21c7af2c77866b6b3b5e762ff7e3246bfc7},
  abstract = {null}
}

@article{ouniMOREMultiObjective2017,
  title = {{{MORE}}: {{A}} Multi‐objective Refactoring Recommendation Approach to Introducing Design Patterns and Fixing Code Smells},
  author = {Ouni, Ali and Kessentini, M. and Cinnéide, M. O. and Sahraoui, H. and Deb, K. and Inoue, Katsuro},
  date = {2017},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {29},
  pages = {null},
  doi = {10.1002/smr.1843},
  url = {https://www.semanticscholar.org/paper/4d0d657cae5cbfdc087f1ce0493c05ac6c47e91f},
  abstract = {Refactoring is widely recognized as a crucial technique applied when evolving object‐oriented software systems. If applied well, refactoring can improve different aspects of software quality including readability, maintainability, and extendibility. However, despite its importance and benefits, recent studies report that automated refactoring tools are underused much of the time by software developers. This paper introduces an automated approach for refactoring recommendation, called MORE, driven by 3 objectives: (1) to improve design quality (as defined by software quality metrics), (2) to fix code smells, and (3) to introduce design patterns. To this end, we adopt the recent nondominated sorting genetic algorithm, NSGA‐III, to find the best trade‐off between these 3 objectives. We evaluated the efficacy of our approach using a benchmark of 7 medium and large open‐source systems, 7 commonly occurring code smells (god class, feature envy, data class, spaghetti code, shotgun surgery, lazy class, and long parameter list), and 4 common design pattern types (visitor, factory method, singleton, and strategy). Our approach is empirically evaluated through a quantitative and qualitative study to compare it against 3 different state‐of‐the art approaches, 2 popular multiobjective search algorithms, and random search. The statistical analysis of the results confirms the efficacy of our approach in improving the quality of the studied systems while successfully fixing 84\% of code smells and introducing an average of 6 design patterns. In addition, the qualitative evaluation shows that most of the suggested refactorings (an average of 69\%) are considered by developers to be relevant and meaningful.}
}

@article{ouniMOREMultiObjective2017a,
  title = {{{MORE}}: {{A}} Multi‐objective Refactoring Recommendation Approach to Introducing Design Patterns and Fixing Code Smells},
  author = {Ouni, Ali and Kessentini, M. and Cinnéide, M. O. and Sahraoui, H. and Deb, K. and Inoue, Katsuro},
  date = {2017},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {29},
  pages = {null},
  doi = {10.1002/smr.1843},
  url = {https://www.semanticscholar.org/paper/4d0d657cae5cbfdc087f1ce0493c05ac6c47e91f},
  abstract = {Refactoring is widely recognized as a crucial technique applied when evolving object‐oriented software systems. If applied well, refactoring can improve different aspects of software quality including readability, maintainability, and extendibility. However, despite its importance and benefits, recent studies report that automated refactoring tools are underused much of the time by software developers. This paper introduces an automated approach for refactoring recommendation, called MORE, driven by 3 objectives: (1) to improve design quality (as defined by software quality metrics), (2) to fix code smells, and (3) to introduce design patterns. To this end, we adopt the recent nondominated sorting genetic algorithm, NSGA‐III, to find the best trade‐off between these 3 objectives. We evaluated the efficacy of our approach using a benchmark of 7 medium and large open‐source systems, 7 commonly occurring code smells (god class, feature envy, data class, spaghetti code, shotgun surgery, lazy class, and long parameter list), and 4 common design pattern types (visitor, factory method, singleton, and strategy). Our approach is empirically evaluated through a quantitative and qualitative study to compare it against 3 different state‐of‐the art approaches, 2 popular multiobjective search algorithms, and random search. The statistical analysis of the results confirms the efficacy of our approach in improving the quality of the studied systems while successfully fixing 84\% of code smells and introducing an average of 6 design patterns. In addition, the qualitative evaluation shows that most of the suggested refactorings (an average of 69\%) are considered by developers to be relevant and meaningful.}
}

@article{ouniMultiCriteriaCodeRefactoring2016,
  title = {Multi-{{Criteria Code Refactoring Using Search-Based Software Engineering}}},
  author = {Ouni, Ali and Kessentini, M. and Sahraoui, H. and Inoue, Katsuro and Deb, K.},
  date = {2016},
  journaltitle = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  volume = {25},
  pages = {1--53},
  doi = {10.1145/2932631},
  url = {https://www.semanticscholar.org/paper/87d99e7b928e2f68972019d4e63997667dd93911},
  abstract = {One of the most widely used techniques to improve the quality of existing software systems is refactoring—the process of improving the design of existing code by changing its internal structure without altering its external behavior. While it is important to suggest refactorings that improve the quality and structure of the system, many other criteria are also important to consider, such as reducing the number of code changes, preserving the semantics of the software design and not only its behavior, and maintaining consistency with the previously applied refactorings. In this article, we propose a multi-objective search-based approach for automating the recommendation of refactorings. The process aims at finding the optimal sequence of refactorings that (i) improves the quality by minimizing the number of design defects, (ii) minimizes code changes required to fix those defects, (iii) preserves design semantics, and (iv) maximizes the consistency with the previously code changes. We evaluated the efficiency of our approach using a benchmark of six open-source systems, 11 different types of refactorings (move method, move field, pull up method, pull up field, push down method, push down field, inline class, move class, extract class, extract method, and extract interface) and six commonly occurring design defect types (blob, spaghetti code, functional decomposition, data class, shotgun surgery, and feature envy) through an empirical study conducted with experts. In addition, we performed an industrial validation of our technique, with 10 software engineers, on a large project provided by our industrial partner. We found that the proposed refactorings succeed in preserving the design coherence of the code, with an acceptable level of code change score while reusing knowledge from recorded refactorings applied in the past to similar contexts.}
}

@article{ouniMultiCriteriaCodeRefactoring2016a,
  title = {Multi-{{Criteria Code Refactoring Using Search-Based Software Engineering}}},
  author = {Ouni, Ali and Kessentini, M. and Sahraoui, H. and Inoue, Katsuro and Deb, K.},
  date = {2016},
  journaltitle = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  volume = {25},
  pages = {1--53},
  doi = {10.1145/2932631},
  url = {https://www.semanticscholar.org/paper/87d99e7b928e2f68972019d4e63997667dd93911},
  abstract = {One of the most widely used techniques to improve the quality of existing software systems is refactoring—the process of improving the design of existing code by changing its internal structure without altering its external behavior. While it is important to suggest refactorings that improve the quality and structure of the system, many other criteria are also important to consider, such as reducing the number of code changes, preserving the semantics of the software design and not only its behavior, and maintaining consistency with the previously applied refactorings. In this article, we propose a multi-objective search-based approach for automating the recommendation of refactorings. The process aims at finding the optimal sequence of refactorings that (i) improves the quality by minimizing the number of design defects, (ii) minimizes code changes required to fix those defects, (iii) preserves design semantics, and (iv) maximizes the consistency with the previously code changes. We evaluated the efficiency of our approach using a benchmark of six open-source systems, 11 different types of refactorings (move method, move field, pull up method, pull up field, push down method, push down field, inline class, move class, extract class, extract method, and extract interface) and six commonly occurring design defect types (blob, spaghetti code, functional decomposition, data class, shotgun surgery, and feature envy) through an empirical study conducted with experts. In addition, we performed an industrial validation of our technique, with 10 software engineers, on a large project provided by our industrial partner. We found that the proposed refactorings succeed in preserving the design coherence of the code, with an acceptable level of code change score while reusing knowledge from recorded refactorings applied in the past to similar contexts.}
}

@article{ouniMultiobjectiveOptimizationSoftware2014,
  title = {Multiobjective {{Optimization}} for {{Software Refactoring}} and {{Evolution}}},
  author = {Ouni, Ali and Kessentini, M. and Sahraoui, H.},
  date = {2014},
  journaltitle = {Adv. Comput.},
  volume = {94},
  pages = {103--167},
  doi = {10.1016/B978-0-12-800161-5.00004-9},
  url = {https://www.semanticscholar.org/paper/ee8b90df1dee4d08688fe646aba36da2b7f96560},
  abstract = {S2 TL;DR: This research project targets the automation of two main steps of refactoring, and considers the detection step as a search-based process to find the suitable detection rules for each type of design defect, by means of a genetic algorithm.}
}

@article{ouniMultiobjectiveOptimizationSoftware2014a,
  title = {Multiobjective {{Optimization}} for {{Software Refactoring}} and {{Evolution}}},
  author = {Ouni, Ali and Kessentini, M. and Sahraoui, H.},
  date = {2014},
  journaltitle = {Adv. Comput.},
  volume = {94},
  pages = {103--167},
  doi = {10.1016/B978-0-12-800161-5.00004-9},
  url = {https://www.semanticscholar.org/paper/ee8b90df1dee4d08688fe646aba36da2b7f96560},
  abstract = {S2 TL;DR: This research project targets the automation of two main steps of refactoring, and considers the detection step as a search-based process to find the suitable detection rules for each type of design defect, by means of a genetic algorithm.}
}

@article{ouniPrioritizingCodesmellsCorrection2015,
  title = {Prioritizing Code-Smells Correction Tasks Using Chemical Reaction Optimization},
  author = {Ouni, Ali and Kessentini, M. and Bechikh, Slim and Sahraoui, H.},
  date = {2015},
  journaltitle = {Software Quality Journal},
  volume = {23},
  pages = {323--361},
  doi = {10.1007/s11219-014-9233-7},
  url = {https://www.semanticscholar.org/paper/fb852dba73a36750b0ad53695a0684c84d68ec13},
  abstract = {S2 TL;DR: An approach based on a chemical reaction optimization metaheuristic search to find the suitable refactoring solutions that maximize the number of fixed riskiest code-smells according to the maintainer’s preferences/criteria is proposed.}
}

@article{ouniPrioritizingCodesmellsCorrection2015a,
  title = {Prioritizing Code-Smells Correction Tasks Using Chemical Reaction Optimization},
  author = {Ouni, Ali and Kessentini, M. and Bechikh, Slim and Sahraoui, H.},
  date = {2015},
  journaltitle = {Software Quality Journal},
  volume = {23},
  pages = {323--361},
  doi = {10.1007/s11219-014-9233-7},
  url = {https://www.semanticscholar.org/paper/fb852dba73a36750b0ad53695a0684c84d68ec13},
  abstract = {S2 TL;DR: An approach based on a chemical reaction optimization metaheuristic search to find the suitable refactoring solutions that maximize the number of fixed riskiest code-smells according to the maintainer’s preferences/criteria is proposed.}
}

@article{ouniUseDevelopmentHistory2013,
  title = {The Use of Development History in Software Refactoring Using a Multi-Objective Evolutionary Algorithm},
  author = {Ouni, Ali and Kessentini, M. and Sahraoui, H. and Hamdi, M.},
  date = {2013},
  doi = {10.1145/2463372.2463554},
  url = {https://www.semanticscholar.org/paper/40a08f6f084a07f90620223613440f697d784fe7},
  abstract = {One of the widely used techniques for evolving software systems is refactoring, a maintenance activity that improves design structure while preserving the external behavior. Exploring past maintenance and development history can be an effective way of finding refactoring opportunities. Code elements which undergo changes in the past, at approximately the same time, bear a good probability for being semantically related. Moreover, these elements that experienced a huge number of refactoring in the past have a good chance for refactoring in the future. In addition, the development history can be used to propose new refactoring solutions in similar contexts. In this paper, we propose a multi-objective optimization-based approach to find the best sequence of refactorings that minimizes the number of bad-smells, and maximizes the use of development history and semantic coherence. To this end, we use the non-dominated sorting genetic algorithm (NSGA-II) to find the best trade-off between these three objectives. We report the results of our experiments using different large open source projects.}
}

@article{ouniUseDevelopmentHistory2013a,
  title = {The Use of Development History in Software Refactoring Using a Multi-Objective Evolutionary Algorithm},
  author = {Ouni, Ali and Kessentini, M. and Sahraoui, H. and Hamdi, M.},
  date = {2013},
  doi = {10.1145/2463372.2463554},
  url = {https://www.semanticscholar.org/paper/40a08f6f084a07f90620223613440f697d784fe7},
  abstract = {One of the widely used techniques for evolving software systems is refactoring, a maintenance activity that improves design structure while preserving the external behavior. Exploring past maintenance and development history can be an effective way of finding refactoring opportunities. Code elements which undergo changes in the past, at approximately the same time, bear a good probability for being semantically related. Moreover, these elements that experienced a huge number of refactoring in the past have a good chance for refactoring in the future. In addition, the development history can be used to propose new refactoring solutions in similar contexts. In this paper, we propose a multi-objective optimization-based approach to find the best sequence of refactorings that minimizes the number of bad-smells, and maximizes the use of development history and semantic coherence. To this end, we use the non-dominated sorting genetic algorithm (NSGA-II) to find the best trade-off between these three objectives. We report the results of our experiments using different large open source projects.}
}

@article{palacioComputationalSolutionSoftware2017,
  title = {A Computational Solution for the Software Refactoring Problem: From a Formalism toward an Optimization Approach},
  author = {Palacio, Nader and Alberto, David},
  date = {2017},
  url = {https://www.semanticscholar.org/paper/1fb0199072ce47d68031819bdf9245eedfe0f988},
  abstract = {Magister en Ingenieria de sistemas y computacion; Linea de investigacion: Computacion Evolutiva y Mantenimiento de Software}
}

@article{palacioComputationalSolutionSoftware2017a,
  title = {A Computational Solution for the Software Refactoring Problem: From a Formalism toward an Optimization Approach},
  author = {Palacio, Nader and Alberto, David},
  date = {2017},
  url = {https://www.semanticscholar.org/paper/1fb0199072ce47d68031819bdf9245eedfe0f988},
  abstract = {Magister en Ingenieria de sistemas y computacion; Linea de investigacion: Computacion Evolutiva y Mantenimiento de Software}
}

@article{palombaDiffusenessImpactMaintainability2018,
  title = {On the Diffuseness and the Impact on Maintainability of Code Smells: A Large Scale Empirical Investigation},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Fasano, F. and Oliveto, R. and Lucia, A. D.},
  date = {2018},
  journaltitle = {Empirical Software Engineering},
  volume = {23},
  pages = {1188--1221},
  doi = {10.1007/s10664-017-9535-z},
  url = {https://www.semanticscholar.org/paper/0579003763ed6625a08e8364904f60799f49b10f},
  abstract = {S2 TL;DR: The results show that smells characterized by long and/or complex code (e.g., Complex Class) are highly diffused, and that smelly classes have a higher change- and fault-proneness than smell-free classes.}
}

@article{palombaMiningVersionHistories2015,
  title = {Mining {{Version Histories}} for {{Detecting Code Smells}}},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R. and Poshyvanyk, D. and Lucia, A. D.},
  date = {2015},
  journaltitle = {IEEE Transactions on Software Engineering},
  volume = {41},
  pages = {462--489},
  doi = {10.1109/TSE.2014.2372760},
  url = {https://www.semanticscholar.org/paper/e856495ad5ac7efa49ed671c2856de93d385630a},
  abstract = {Code smells are symptoms of poor design and implementation choices that may hinder code comprehension, and possibly increase changeand fault-proneness. While most of the detection techniques just rely on structural information, many code smells are intrinsically characterized by how code elements change overtime. In this paper, we propose Historical Information for Smell deTection (HIST), an approach exploiting change history information to detect instances of five different code smells, namely Divergent Change, Shotgun Surgery, Parallel Inheritance, Blob, and Feature Envy. We evaluate HIST in two empirical studies. The first, conducted on 20 open source projects, aimed at assessing the accuracy of HIST in detecting instances of the code smells mentioned above. The results indicate that the precision of HIST ranges between 72 and 86 percent, and its recall ranges between 58 and 100 percent. Also, results of the first study indicate that HIST is able to identify code smells that cannot be identified by competitive approaches solely based on code analysis of a single system's snapshot. Then, we conducted a second study aimed at investigating to what extent the code smells detected by HIST (and by competitive code analysis techniques) reflect developers' perception of poor design and implementation choices. We involved 12 developers of four open source projects that recognized more than 75 percent of the code smell instances identified by HIST as actual design/implementation problems.}
}

@article{palombaMiningVersionHistories2015a,
  title = {Mining {{Version Histories}} for {{Detecting Code Smells}}},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R. and Poshyvanyk, D. and Lucia, A. D.},
  date = {2015},
  journaltitle = {IEEE Transactions on Software Engineering},
  volume = {41},
  pages = {462--489},
  doi = {10.1109/TSE.2014.2372760},
  url = {https://www.semanticscholar.org/paper/e856495ad5ac7efa49ed671c2856de93d385630a},
  abstract = {Code smells are symptoms of poor design and implementation choices that may hinder code comprehension, and possibly increase changeand fault-proneness. While most of the detection techniques just rely on structural information, many code smells are intrinsically characterized by how code elements change overtime. In this paper, we propose Historical Information for Smell deTection (HIST), an approach exploiting change history information to detect instances of five different code smells, namely Divergent Change, Shotgun Surgery, Parallel Inheritance, Blob, and Feature Envy. We evaluate HIST in two empirical studies. The first, conducted on 20 open source projects, aimed at assessing the accuracy of HIST in detecting instances of the code smells mentioned above. The results indicate that the precision of HIST ranges between 72 and 86 percent, and its recall ranges between 58 and 100 percent. Also, results of the first study indicate that HIST is able to identify code smells that cannot be identified by competitive approaches solely based on code analysis of a single system's snapshot. Then, we conducted a second study aimed at investigating to what extent the code smells detected by HIST (and by competitive code analysis techniques) reflect developers' perception of poor design and implementation choices. We involved 12 developers of four open source projects that recognized more than 75 percent of the code smell instances identified by HIST as actual design/implementation problems.}
}

@article{palombaMiningVersionHistories2015b,
  title = {Mining {{Version Histories}} for {{Detecting Code Smells}}},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R. and Poshyvanyk, D. and Lucia, A. D.},
  date = {2015},
  journaltitle = {IEEE Transactions on Software Engineering},
  volume = {41},
  pages = {462--489},
  doi = {10.1109/TSE.2014.2372760},
  url = {https://www.semanticscholar.org/paper/e856495ad5ac7efa49ed671c2856de93d385630a},
  abstract = {Code smells are symptoms of poor design and implementation choices that may hinder code comprehension, and possibly increase changeand fault-proneness. While most of the detection techniques just rely on structural information, many code smells are intrinsically characterized by how code elements change overtime. In this paper, we propose Historical Information for Smell deTection (HIST), an approach exploiting change history information to detect instances of five different code smells, namely Divergent Change, Shotgun Surgery, Parallel Inheritance, Blob, and Feature Envy. We evaluate HIST in two empirical studies. The first, conducted on 20 open source projects, aimed at assessing the accuracy of HIST in detecting instances of the code smells mentioned above. The results indicate that the precision of HIST ranges between 72 and 86 percent, and its recall ranges between 58 and 100 percent. Also, results of the first study indicate that HIST is able to identify code smells that cannot be identified by competitive approaches solely based on code analysis of a single system's snapshot. Then, we conducted a second study aimed at investigating to what extent the code smells detected by HIST (and by competitive code analysis techniques) reflect developers' perception of poor design and implementation choices. We involved 12 developers of four open source projects that recognized more than 75 percent of the code smell instances identified by HIST as actual design/implementation problems.}
}

@article{palombaTextualbasedTechniqueSmell2016,
  title = {A Textual-Based Technique for {{Smell Detection}}},
  author = {Palomba, Fabio and Panichella, Annibale and Lucia, A. D. and Oliveto, R. and Zaidman, A.},
  date = {2016},
  journaltitle = {2016 IEEE 24th International Conference on Program Comprehension (ICPC)},
  volume = {null},
  pages = {1--10},
  doi = {10.1109/ICPC.2016.7503704},
  url = {https://www.semanticscholar.org/paper/23b1c3354024453e0d8e8402810893943b891ea2},
  abstract = {In this paper, we present TACO (Textual Analysis for Code Smell Detection), a technique that exploits textual analysis to detect a family of smells of different nature and different levels of granularity. We run TACO on 10 open source projects, comparing its performance with existing smell detectors purely based on structural information extracted from code components. The analysis of the results indicates that TACO's precision ranges between 67\% and 77\%, while its recall ranges between 72\% and 84\%. Also, TACO often outperforms alternative structural approaches confirming, once again, the usefulness of information that can be derived from the textual part of code components.}
}

@article{palombaTextualbasedTechniqueSmell2016a,
  title = {A Textual-Based Technique for {{Smell Detection}}},
  author = {Palomba, Fabio and Panichella, Annibale and Lucia, A. D. and Oliveto, R. and Zaidman, A.},
  date = {2016},
  journaltitle = {2016 IEEE 24th International Conference on Program Comprehension (ICPC)},
  volume = {null},
  pages = {1--10},
  doi = {10.1109/ICPC.2016.7503704},
  url = {https://www.semanticscholar.org/paper/23b1c3354024453e0d8e8402810893943b891ea2},
  abstract = {In this paper, we present TACO (Textual Analysis for Code Smell Detection), a technique that exploits textual analysis to detect a family of smells of different nature and different levels of granularity. We run TACO on 10 open source projects, comparing its performance with existing smell detectors purely based on structural information extracted from code components. The analysis of the results indicates that TACO's precision ranges between 67\% and 77\%, while its recall ranges between 72\% and 84\%. Also, TACO often outperforms alternative structural approaches confirming, once again, the usefulness of information that can be derived from the textual part of code components.}
}

@article{palombaTheyReallySmell2014,
  title = {Do {{They Really Smell Bad}}? {{A Study}} on {{Developers}}' {{Perception}} of {{Bad Code Smells}}},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R. and Lucia, A. D.},
  date = {2014},
  journaltitle = {2014 IEEE International Conference on Software Maintenance and Evolution},
  volume = {null},
  pages = {101--110},
  doi = {10.1109/ICSME.2014.32},
  url = {https://www.semanticscholar.org/paper/cb574d4799f5390161aa80b9e447e5c49351e8f1},
  abstract = {In the last decade several catalogues have been defined to characterize bad code smells, i.e., symptoms of poor design and implementation choices. On top of such catalogues, researchers have defined methods and tools to automatically detect and/or remove bad smells. Nevertheless, there is an ongoing debate regarding the extent to which developers perceive bad smells as serious design problems. Indeed, there seems to be a gap between theory and practice, i.e., what is believed to be a problem (theory) and what is actually a problem (practice). This paper presents a study aimed at providing empirical evidence on how developers perceive bad smells. In this study, we showed to developers code entities – belonging to three systems – affected and not by bad smells, and we asked them to indicate whether the code contains a potential design problem, and if any, the nature and severity of the problem. The study involved both original developers from the three projects and outsiders, namely industrial developers and Master's students. The results provide insights on characteristics of bad smells not yet explored sufficiently. Also, our findings could guide future research on approaches for the detection and removal of bad smells.}
}

@article{palombaTheyReallySmell2014a,
  title = {Do They {{Really Smell Bad}} ? {{A Study}} on {{Developers}} ’ {{Perception}} of {{Code Bad Smells}}},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R.},
  date = {2014},
  url = {https://www.semanticscholar.org/paper/474ff32ff8586f351f4b8f2171c25956136eaa55},
  abstract = {In the last decade several catalogues have been defined to characterize code bad smells, i.e., symptoms of poor design and implementation choices. On top of such catalogues, researchers have defined methods and tools to automatically detect and/or remove bad smells. Nevertheless, there is an ongoing debate regarding the extent to which developers perceive bad smells as serious design problems. Indeed, there seems to be a gap between theory and practice, i.e., what is believed to be a problem (theory) and what is actually a problem (practice). This paper presents a study aimed at providing empirical evidence on how developers perceive bad smells. In this study, we showed to developers code entities—belonging to three systems— affected and not by bad smells, and we asked them to indicate whether the code contains a potential design problem, and if any, the nature and severity of the problem. The study involved both original developers from the three projects and outsiders, namely industrial developers and Master students. The results provide insights on characteristics of bad smells not yet explored sufficiently. Also, our findings could guide future research on approaches for the detection and removal of bad smells.}
}

@article{palombaTheyReallySmell2014b,
  title = {Do {{They Really Smell Bad}}? {{A Study}} on {{Developers}}' {{Perception}} of {{Bad Code Smells}}},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R. and Lucia, A. D.},
  date = {2014},
  journaltitle = {2014 IEEE International Conference on Software Maintenance and Evolution},
  volume = {null},
  pages = {101--110},
  doi = {10.1109/ICSME.2014.32},
  url = {https://www.semanticscholar.org/paper/cb574d4799f5390161aa80b9e447e5c49351e8f1},
  abstract = {In the last decade several catalogues have been defined to characterize bad code smells, i.e., symptoms of poor design and implementation choices. On top of such catalogues, researchers have defined methods and tools to automatically detect and/or remove bad smells. Nevertheless, there is an ongoing debate regarding the extent to which developers perceive bad smells as serious design problems. Indeed, there seems to be a gap between theory and practice, i.e., what is believed to be a problem (theory) and what is actually a problem (practice). This paper presents a study aimed at providing empirical evidence on how developers perceive bad smells. In this study, we showed to developers code entities – belonging to three systems – affected and not by bad smells, and we asked them to indicate whether the code contains a potential design problem, and if any, the nature and severity of the problem. The study involved both original developers from the three projects and outsiders, namely industrial developers and Master's students. The results provide insights on characteristics of bad smells not yet explored sufficiently. Also, our findings could guide future research on approaches for the detection and removal of bad smells.}
}

@article{palombaTheyReallySmell2014c,
  title = {Do They {{Really Smell Bad}} ? {{A Study}} on {{Developers}} ’ {{Perception}} of {{Code Bad Smells}}},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R.},
  date = {2014},
  url = {https://www.semanticscholar.org/paper/474ff32ff8586f351f4b8f2171c25956136eaa55},
  abstract = {In the last decade several catalogues have been defined to characterize code bad smells, i.e., symptoms of poor design and implementation choices. On top of such catalogues, researchers have defined methods and tools to automatically detect and/or remove bad smells. Nevertheless, there is an ongoing debate regarding the extent to which developers perceive bad smells as serious design problems. Indeed, there seems to be a gap between theory and practice, i.e., what is believed to be a problem (theory) and what is actually a problem (practice). This paper presents a study aimed at providing empirical evidence on how developers perceive bad smells. In this study, we showed to developers code entities—belonging to three systems— affected and not by bad smells, and we asked them to indicate whether the code contains a potential design problem, and if any, the nature and severity of the problem. The study involved both original developers from the three projects and outsiders, namely industrial developers and Master students. The results provide insights on characteristics of bad smells not yet explored sufficiently. Also, our findings could guide future research on approaches for the detection and removal of bad smells.}
}

@article{palombaTheyReallySmell2014d,
  title = {Do {{They Really Smell Bad}}? {{A Study}} on {{Developers}}' {{Perception}} of {{Bad Code Smells}}},
  author = {Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R. and Lucia, A. D.},
  date = {2014},
  journaltitle = {2014 IEEE International Conference on Software Maintenance and Evolution},
  volume = {null},
  pages = {101--110},
  doi = {10.1109/ICSME.2014.32},
  url = {https://www.semanticscholar.org/paper/cb574d4799f5390161aa80b9e447e5c49351e8f1},
  abstract = {In the last decade several catalogues have been defined to characterize bad code smells, i.e., symptoms of poor design and implementation choices. On top of such catalogues, researchers have defined methods and tools to automatically detect and/or remove bad smells. Nevertheless, there is an ongoing debate regarding the extent to which developers perceive bad smells as serious design problems. Indeed, there seems to be a gap between theory and practice, i.e., what is believed to be a problem (theory) and what is actually a problem (practice). This paper presents a study aimed at providing empirical evidence on how developers perceive bad smells. In this study, we showed to developers code entities – belonging to three systems – affected and not by bad smells, and we asked them to indicate whether the code contains a potential design problem, and if any, the nature and severity of the problem. The study involved both original developers from the three projects and outsiders, namely industrial developers and Master's students. The results provide insights on characteristics of bad smells not yet explored sufficiently. Also, our findings could guide future research on approaches for the detection and removal of bad smells.}
}

@article{pengExploringHowSoftware2018,
  title = {Exploring How Software Developers Work with Mention Bot in {{GitHub}}},
  author = {Peng, Zhenhui and Ma, Xiaojuan},
  date = {2018},
  journaltitle = {CCF Transactions on Pervasive Computing and Interaction},
  volume = {1},
  pages = {190--203},
  doi = {10.1007/s42486-019-00013-2},
  url = {https://www.semanticscholar.org/paper/75ee69063dc9d8e21708f45fee185f702a179965},
  abstract = {S2 TL;DR: This paper uses a two-stage mixed-methods approach to study how software developers perceive and work with the Facebook mention bot, one of the most popular ARR bots in GitHub.}
}

@article{pengExploringHowSoftware2018a,
  title = {Exploring How Software Developers Work with Mention Bot in {{GitHub}}},
  author = {Peng, Zhenhui and Ma, Xiaojuan},
  date = {2018},
  journaltitle = {CCF Transactions on Pervasive Computing and Interaction},
  volume = {1},
  pages = {190--203},
  doi = {10.1007/s42486-019-00013-2},
  url = {https://www.semanticscholar.org/paper/75ee69063dc9d8e21708f45fee185f702a179965},
  abstract = {S2 TL;DR: This paper uses a two-stage mixed-methods approach to study how software developers perceive and work with the Facebook mention bot, one of the most popular ARR bots in GitHub.}
}

@article{pengoGraspingPrimitiveEnthusiasm2018,
  title = {Grasping {{Primitive Enthusiasm}} - {{Approaching Primitive Obsession}} in {{Steps}}},
  author = {Pengo, Edit and Gál, Péter},
  date = {2018},
  doi = {10.5220/0006918804230430},
  url = {https://www.semanticscholar.org/paper/dbf714c35298bff3ab09486d886cd7d581abdb13},
  abstract = {Primitive Obsession is a type of a code smell that has lacked the attention of the research community. Although, as a code smell it can be a useful indicator of underlying design problems in the source code, there was only one previously presented automated detection method. In this paper, the Primitive Obsession is discussed and multiple variants for Primitive Enthusiasm is defined. Primitive Enthusiasm is a metric designed to highlight possible Primitive Obsession infected code parts. Additionally other supplemental metrics are presented to grasp more aspects of Primitive Obsession as well. The current implementation of the described metrics is for Java and the evaluation was done on three open-source Java systems.}
}

@article{qayumAnalysingRefactoringDependencies2009,
  title = {Analysing Refactoring Dependencies Using Unfolding of Graph Transformation Systems},
  author = {Qayum, Fawad and Heckel, R.},
  date = {2009},
  doi = {10.1145/1838002.1838019},
  url = {https://www.semanticscholar.org/paper/4e086248b73fe09a83fac227999ce9a36379477f},
  abstract = {Refactoring has emerged as a successful technique to reduce complexity of object oriented designs. But due to implicit dependencies not all sequences of refactorings are appropriate. In this paper we model refactoring steps as graph transformation and use the unfolding analysis technique to choose the sequence of refactorings best suited in order to improve the design. We use graphs to represent software architectures at the class level and graph transformation to formally describe their refactoring operations. This makes it possible to use concepts and techniques from the theory of graph transformation, such as unfolding to identify dependencies between refactoring steps.}
}

@article{qayumAnalysingRefactoringDependencies2009a,
  title = {Analysing Refactoring Dependencies Using Unfolding of Graph Transformation Systems},
  author = {Qayum, Fawad and Heckel, R.},
  date = {2009},
  doi = {10.1145/1838002.1838019},
  url = {https://www.semanticscholar.org/paper/4e086248b73fe09a83fac227999ce9a36379477f},
  abstract = {Refactoring has emerged as a successful technique to reduce complexity of object oriented designs. But due to implicit dependencies not all sequences of refactorings are appropriate. In this paper we model refactoring steps as graph transformation and use the unfolding analysis technique to choose the sequence of refactorings best suited in order to improve the design. We use graphs to represent software architectures at the class level and graph transformation to formally describe their refactoring operations. This makes it possible to use concepts and techniques from the theory of graph transformation, such as unfolding to identify dependencies between refactoring steps.}
}

@article{qayumAutomatedAssistanceSearchBased2010,
  title = {Automated {{Assistance}} for {{Search-Based Refactoring Using Unfolding}} of {{Graph Transformation Systems}}},
  author = {Qayum, Fawad},
  date = {2010},
  doi = {10.1007/978-3-642-15928-2_34},
  url = {https://www.semanticscholar.org/paper/71628456e85db223b98451a4924fcd4bc6629694},
  abstract = {S2 TL;DR: Search-based approaches have been suggested in order to provide automation in discovering appropriate refactoring sequences, and the idea is to see the design process as a combinatorial optimization problem, attempting to derive the best solution from a given initial design.}
}

@article{qayumAutomatedAssistanceSearchBased2010a,
  title = {Automated {{Assistance}} for {{Search-Based Refactoring Using Unfolding}} of {{Graph Transformation Systems}}},
  author = {Qayum, Fawad},
  date = {2010},
  doi = {10.1007/978-3-642-15928-2_34},
  url = {https://www.semanticscholar.org/paper/71628456e85db223b98451a4924fcd4bc6629694},
  abstract = {S2 TL;DR: Search-based approaches have been suggested in order to provide automation in discovering appropriate refactoring sequences, and the idea is to see the design process as a combinatorial optimization problem, attempting to derive the best solution from a given initial design.}
}

@article{qayumSearchBasedRefactoringUsing2011,
  title = {Search-{{Based Refactoring}} Using {{Unfolding}} of {{Graph Transformation Systems}}},
  author = {Qayum, Fawad and Heckel, R.},
  date = {2011},
  journaltitle = {Electron. Commun. Eur. Assoc. Softw. Sci. Technol.},
  volume = {38},
  pages = {null},
  doi = {10.14279/tuj.eceasst.38.577},
  url = {https://www.semanticscholar.org/paper/a8e5b98ba92afd68cc4e64dbc93de942ae669adc},
  abstract = {To improve scalability and understandability of search-based refactoring, in this paper, we propose a formulation based on graph transformation which allows us to make use of partial order semantics and an associated analysis technique, the approximated unfolding of graph transformation systems. We use graphs to represent object-oriented software architectures at the class level and graph transformations to describe their refactoring operations. In the unfolding we can identify dependencies and conflicts between refactoring steps leading to an implicit and therefore more scalable representation of the search space. An optimisation algorithm based on the Ant Colony paradigm is used to explore this search space, aiming to find a sequence of refactoring steps that leads to the best design at a minimal costs.}
}

@article{qayumSearchBasedRefactoringUsing2011a,
  title = {Search-{{Based Refactoring}} Using {{Unfolding}} of {{Graph Transformation Systems}}},
  author = {Qayum, Fawad and Heckel, R.},
  date = {2011},
  journaltitle = {Electron. Commun. Eur. Assoc. Softw. Sci. Technol.},
  volume = {38},
  pages = {null},
  doi = {10.14279/tuj.eceasst.38.577},
  url = {https://www.semanticscholar.org/paper/a8e5b98ba92afd68cc4e64dbc93de942ae669adc},
  abstract = {To improve scalability and understandability of search-based refactoring, in this paper, we propose a formulation based on graph transformation which allows us to make use of partial order semantics and an associated analysis technique, the approximated unfolding of graph transformation systems. We use graphs to represent object-oriented software architectures at the class level and graph transformations to describe their refactoring operations. In the unfolding we can identify dependencies and conflicts between refactoring steps leading to an implicit and therefore more scalable representation of the search space. An optimisation algorithm based on the Ant Colony paradigm is used to explore this search space, aiming to find a sequence of refactoring steps that leads to the best design at a minimal costs.}
}

@article{ramosDivideConquerRefactoring2010,
  title = {Divide and Conquer Refactoring: Dealing with the Large, Scattering or Tangling Use Case Model},
  author = {Ramos, R. and Castro, J. and Araújo, J. and Alencar, F. and Penteado, R.},
  date = {2010},
  doi = {10.1145/2581507.2581509},
  url = {https://www.semanticscholar.org/paper/ef16486c6a4edddec5dc8c6122b3eb0d52c0640d},
  abstract = {Problems in use case models such as use cases that are abandoned and no longer relevant, descriptions that are unnecessarily long and complex, information that is duplicated and use case models that are very large and complex may compromise understandability of the requirements and as a result reusability and maintainability are reduced. In this paper, it is proposed a refactoring to assist the requirements engineer to improve use case models. Refactoring opportunities are presented to indicate where and when the refactoring could be used. We also describe how our approach was applied in a real example from an existing organization.}
}

@article{ramosDivideConquerRefactoring2010a,
  title = {Divide and Conquer Refactoring: Dealing with the Large, Scattering or Tangling Use Case Model},
  author = {Ramos, R. and Castro, J. and Araújo, J. and Alencar, F. and Penteado, R.},
  date = {2010},
  doi = {10.1145/2581507.2581509},
  url = {https://www.semanticscholar.org/paper/ef16486c6a4edddec5dc8c6122b3eb0d52c0640d},
  abstract = {Problems in use case models such as use cases that are abandoned and no longer relevant, descriptions that are unnecessarily long and complex, information that is duplicated and use case models that are very large and complex may compromise understandability of the requirements and as a result reusability and maintainability are reduced. In this paper, it is proposed a refactoring to assist the requirements engineer to improve use case models. Refactoring opportunities are presented to indicate where and when the refactoring could be used. We also describe how our approach was applied in a real example from an existing organization.}
}

@article{raniEvolutionCodeSmells2017,
  title = {Evolution of Code Smells over Multiple Versions of Softwares: {{An}} Empirical Investigation},
  author = {Rani, Anshul and Chhabra, J.},
  date = {2017},
  journaltitle = {2017 2nd International Conference for Convergence in Technology (I2CT)},
  volume = {null},
  pages = {1093--1098},
  doi = {10.1109/I2CT.2017.8226297},
  url = {https://www.semanticscholar.org/paper/b683060c7f6da12b481ccbeeb2260c62ffe8e197},
  abstract = {The symptoms which reflect the poor design quality of code are known as code smells. Refactoring is one of the possible ways to remove code smells, but refactoring does not come for free to developer. So there is a need to have efficient refactoring strategies. For this purpose an empirical study on distribution of different code smells over different versions of projects is provided in this paper, so that refactoring strategies can be built keeping in a view that which smell is more effective and at which time during evolution of software. For experiment, different versions of Junit, GCviewer and Gitblit have been taken. To detect the smells and violations in code JDeodorant and PMD tools are used. Study shows that a) Latest version of software has more design issues than that of oldest ones; b) God smell and urgent violations have more contribution than other smells whereas instances having Type Checking smell are very less in all the versions. Study shows that initial version of project can be used as reference architecture for purpose of reverse Engineering. We also found that Gitblit has better code design than that of other two softwares.}
}

@article{raniEvolutionCodeSmells2017a,
  title = {Evolution of Code Smells over Multiple Versions of Softwares: {{An}} Empirical Investigation},
  author = {Rani, Anshul and Chhabra, J.},
  date = {2017},
  journaltitle = {2017 2nd International Conference for Convergence in Technology (I2CT)},
  volume = {null},
  pages = {1093--1098},
  doi = {10.1109/I2CT.2017.8226297},
  url = {https://www.semanticscholar.org/paper/b683060c7f6da12b481ccbeeb2260c62ffe8e197},
  abstract = {The symptoms which reflect the poor design quality of code are known as code smells. Refactoring is one of the possible ways to remove code smells, but refactoring does not come for free to developer. So there is a need to have efficient refactoring strategies. For this purpose an empirical study on distribution of different code smells over different versions of projects is provided in this paper, so that refactoring strategies can be built keeping in a view that which smell is more effective and at which time during evolution of software. For experiment, different versions of Junit, GCviewer and Gitblit have been taken. To detect the smells and violations in code JDeodorant and PMD tools are used. Study shows that a) Latest version of software has more design issues than that of oldest ones; b) God smell and urgent violations have more contribution than other smells whereas instances having Type Checking smell are very less in all the versions. Study shows that initial version of project can be used as reference architecture for purpose of reverse Engineering. We also found that Gitblit has better code design than that of other two softwares.}
}

@article{raniPrioritizationSmellyClasses2017,
  title = {Prioritization of Smelly Classes: {{A}} Two Phase Approach ({{Reducing}} Refactoring Efforts)},
  author = {Rani, Anshul and Chhabra, J.},
  date = {2017},
  journaltitle = {2017 3rd International Conference on Computational Intelligence \& Communication Technology (CICT)},
  volume = {null},
  pages = {1--6},
  doi = {10.1109/CIACT.2017.7977311},
  url = {https://www.semanticscholar.org/paper/f2bbc5d945515f3fef79760e516311e77c810f37},
  abstract = {Frequent changes in an object-oriented software system often result into a poor-quality and less maintainable design and the symptoms (known as Code Smells) causing that degradation, need to be corrected for which refactoring is one of the possible solutions. It is not feasible to refactor/ restructure each and every smelly class due to various constraints such as time and cost. Hence it is desirable to make an efficient approach of refactoring. Proposed scheme aims to save time (and cost) of refactoring by carrying out selective refactoring for high priority smelly classes. Prioritization is proposed to be done according to interaction level of each class with other classes. The proposed methodology works in two phases; first phase detects smelly classes using structural information of source code and second phase mines change history to prioritize smelly classes. This prioritization is used to carry out refactoring of more severe classes. This process helps in reducing efforts of refactoring and at the same time may result in avoiding refactoring chains. The proposed technique has been evaluated over a software consisting of 49 classes and results have been validated. The results clearly indicate that the proposed approach performs better and can be very useful for software maintainers in effective and efficient refactoring.}
}

@article{raniPrioritizationSmellyClasses2017a,
  title = {Prioritization of Smelly Classes: {{A}} Two Phase Approach ({{Reducing}} Refactoring Efforts)},
  author = {Rani, Anshul and Chhabra, J.},
  date = {2017},
  journaltitle = {2017 3rd International Conference on Computational Intelligence \& Communication Technology (CICT)},
  volume = {null},
  pages = {1--6},
  doi = {10.1109/CIACT.2017.7977311},
  url = {https://www.semanticscholar.org/paper/f2bbc5d945515f3fef79760e516311e77c810f37},
  abstract = {Frequent changes in an object-oriented software system often result into a poor-quality and less maintainable design and the symptoms (known as Code Smells) causing that degradation, need to be corrected for which refactoring is one of the possible solutions. It is not feasible to refactor/ restructure each and every smelly class due to various constraints such as time and cost. Hence it is desirable to make an efficient approach of refactoring. Proposed scheme aims to save time (and cost) of refactoring by carrying out selective refactoring for high priority smelly classes. Prioritization is proposed to be done according to interaction level of each class with other classes. The proposed methodology works in two phases; first phase detects smelly classes using structural information of source code and second phase mines change history to prioritize smelly classes. This prioritization is used to carry out refactoring of more severe classes. This process helps in reducing efforts of refactoring and at the same time may result in avoiding refactoring chains. The proposed technique has been evaluated over a software consisting of 49 classes and results have been validated. The results clearly indicate that the proposed approach performs better and can be very useful for software maintainers in effective and efficient refactoring.}
}

@article{rasoolReviewCodeSmell2015,
  title = {A Review of Code Smell Mining Techniques},
  author = {Rasool, G. and Arshad, Z.},
  date = {2015},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {27},
  pages = {867--895},
  doi = {10.1002/smr.1737},
  url = {https://www.semanticscholar.org/paper/85db69aa0ad051300825e5f292e6efc1edab1a41},
  abstract = {Over the past 15 years, researchers presented numerous techniques and tools for mining code smells. It is imperative to classify, compare, and evaluate existing techniques and tools used for the detection of code smells because of their varying features and outcomes. This paper presents an up‐to‐date review on the state‐of‐the‐art techniques and tools used for mining code smells from the source code of different software applications. We classify selected code smell detection techniques and tools based on their detection methods and analyze the results of the selected techniques. We present our observations and recommendations after our critical analysis of existing code smell techniques and tools. Our recommendations may be used by existing and new tool developers working in the field of code smell detection. The scope of this review is limited to research publications in the area of code smells that focus on detection of code smells as compared with previous reviews that cover all aspects of code smells. Copyright © 2015 John Wiley \& Sons, Ltd.}
}

@article{rissettiSetRefactoringsEvolution2016,
  title = {A Set of Refactorings for the Evolution of {{Fortran}} Programs},
  author = {Rissetti, Gustavo and Charão, A. and Piveta, E.},
  date = {2016},
  journaltitle = {Int. J. High Perform. Syst. Archit.},
  volume = {6},
  pages = {98--109},
  doi = {10.1504/IJHPSA.2016.078809},
  url = {https://www.semanticscholar.org/paper/e064e243224ca9a095e9b7630b07a33a05af9121},
  abstract = {The formula translation Fortran language, despite having almost 60 years of existence, is still widely used in scientific applications. The majority of Fortran applications still in use is composed of legacy code, sometimes using obsolete or deprecated language features and, thus, thriving for updates to improve their quality attributes though evolution. Software evolution can be benefited from refactoring which provides well-defined mechanisms to be followed, helping to maintain and to improve the quality of existent systems. We present a set of refactorings for the evolution of Fortran programs and automate a set of them in the Photran framework.}
}

@article{rissettiSetRefactoringsEvolution2016a,
  title = {A Set of Refactorings for the Evolution of {{Fortran}} Programs},
  author = {Rissetti, Gustavo and Charão, A. and Piveta, E.},
  date = {2016},
  journaltitle = {Int. J. High Perform. Syst. Archit.},
  volume = {6},
  pages = {98--109},
  doi = {10.1504/IJHPSA.2016.078809},
  url = {https://www.semanticscholar.org/paper/e064e243224ca9a095e9b7630b07a33a05af9121},
  abstract = {The formula translation Fortran language, despite having almost 60 years of existence, is still widely used in scientific applications. The majority of Fortran applications still in use is composed of legacy code, sometimes using obsolete or deprecated language features and, thus, thriving for updates to improve their quality attributes though evolution. Software evolution can be benefited from refactoring which provides well-defined mechanisms to be followed, helping to maintain and to improve the quality of existent systems. We present a set of refactorings for the evolution of Fortran programs and automate a set of them in the Photran framework.}
}

@article{rodriguesRefactoringsReplacingDynamic2018,
  title = {Refactorings for Replacing Dynamic Instructions with Static Ones: The Case of Ruby},
  author = {Rodrigues, Elder and Durelli, R. and Bettio, R. W. and Montecchi, Leonardo and Terra, Ricardo},
  date = {2018},
  doi = {10.1145/3264637.3264645},
  url = {https://www.semanticscholar.org/paper/f6344e52b79de1d1c3a5b30dbd1b0b49d81a1713},
  abstract = {Dynamic features offered by programming languages provide greater flexibility to the programmer (e.g., dynamic constructions of classes and methods) and reduction of duplicate code snippets. However, the unnecessary use of dynamic features may detract from the code in many ways, such as readability, comprehension, and maintainability of software. Therefore, this paper proposes 20 refactorings that replace dynamic instructions with static ones. In an evaluation on 28 open-source Ruby systems, we could refactor 743 of 1,651 dynamic statements (45\%).}
}

@article{rodriguesRefactoringsReplacingDynamic2018a,
  title = {Refactorings for Replacing Dynamic Instructions with Static Ones: The Case of Ruby},
  author = {Rodrigues, Elder and Durelli, R. and Bettio, R. W. and Montecchi, Leonardo and Terra, Ricardo},
  date = {2018},
  doi = {10.1145/3264637.3264645},
  url = {https://www.semanticscholar.org/paper/f6344e52b79de1d1c3a5b30dbd1b0b49d81a1713},
  abstract = {Dynamic features offered by programming languages provide greater flexibility to the programmer (e.g., dynamic constructions of classes and methods) and reduction of duplicate code snippets. However, the unnecessary use of dynamic features may detract from the code in many ways, such as readability, comprehension, and maintainability of software. Therefore, this paper proposes 20 refactorings that replace dynamic instructions with static ones. In an evaluation on 28 open-source Ruby systems, we could refactor 743 of 1,651 dynamic statements (45\%).}
}

@article{rolimAutomatingRepetitiveCode2016,
  title = {Automating Repetitive Code Changes Using Examples},
  author = {Rolim, Reudismam},
  date = {2016},
  journaltitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/2950290.2983944},
  url = {https://www.semanticscholar.org/paper/8a8ce9f53be0791d8d25ebd14e318adffcd4f015},
  abstract = {While adding features, fixing bugs, or refactoring the code, developers may perform repetitive code edits. Although Integrated Development Environments (IDEs) automate some transformations such as renaming, many repetitive edits are performed manually, which is error-prone and time-consuming. To help developers to apply these edits, we propose a technique to perform repetitive edits using examples. The technique receives as input the source code before and after the developer edits some target locations of the change and produces as output the top-ranked program transformation that can be applied to edit the remaining target locations in the codebase. The technique uses a state-of-the-art program synthesis methodology and has three main components: a) a DSL for describing program transformations; b) synthesis algorithms to learn program transformations in this DSL; c) ranking algorithms to select the program transformation with the higher probability of performing the desired repetitive edit. In our preliminary evaluation, in a dataset of 59 repetitive edit cases taken from real C\# source code repositories, the technique performed, in 83\% of the cases, the intended transformation using only 2.8 examples.}
}

@article{rolimAutomatingRepetitiveCode2016a,
  title = {Automating Repetitive Code Changes Using Examples},
  author = {Rolim, Reudismam},
  date = {2016},
  journaltitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/2950290.2983944},
  url = {https://www.semanticscholar.org/paper/8a8ce9f53be0791d8d25ebd14e318adffcd4f015},
  abstract = {While adding features, fixing bugs, or refactoring the code, developers may perform repetitive code edits. Although Integrated Development Environments (IDEs) automate some transformations such as renaming, many repetitive edits are performed manually, which is error-prone and time-consuming. To help developers to apply these edits, we propose a technique to perform repetitive edits using examples. The technique receives as input the source code before and after the developer edits some target locations of the change and produces as output the top-ranked program transformation that can be applied to edit the remaining target locations in the codebase. The technique uses a state-of-the-art program synthesis methodology and has three main components: a) a DSL for describing program transformations; b) synthesis algorithms to learn program transformations in this DSL; c) ranking algorithms to select the program transformation with the higher probability of performing the desired repetitive edit. In our preliminary evaluation, in a dataset of 59 repetitive edit cases taken from real C\# source code repositories, the technique performed, in 83\% of the cases, the intended transformation using only 2.8 examples.}
}

@article{romanoAnalyzingImpactAntipatterns2012,
  title = {Analyzing the {{Impact}} of {{Antipatterns}} on {{Change-Proneness Using Fine-Grained Source Code Changes}}},
  author = {Romano, Daniele and Raila, P. and Pinzger, M. and Khomh, F.},
  date = {2012},
  journaltitle = {2012 19th Working Conference on Reverse Engineering},
  volume = {null},
  pages = {437--446},
  doi = {10.1109/WCRE.2012.53},
  url = {https://www.semanticscholar.org/paper/6f00ee89250feff2376bf130af86b49d83d67323},
  abstract = {Antipatterns are poor solutions to design and implementation problems which are claimed to make object oriented systems hard to maintain. Our recent studies showed that classes with antipatterns change more frequently than classes without antipatterns. In this paper, we detail these analyses by taking into account fine-grained source code changes (SCC) extracted from 16 Java open source systems. In particular we investigate: whether classes with antipatterns are more change-prone (in terms of SCC) than classes without, (2) whether the type of antipattern impacts the change-proneness of Java classes, and (3) whether certain types of changes are performed more frequently in classes affected by a certain antipattern. Our results show that: 1) the number of SCC performed in classes affected by antipatterns is statistically greater than the number of SCC performed in classes with no antipattern, 2) classes participating in the three antipatterns Complex Class, Spaghetti Code, and SwissArmyKnife are more change-prone than classes affected by other antipatterns, and 3) certain types of changes are more likely to be performed in classes affected by certain antipatterns, such as API changes are likely to be performed in classes affected by the Complex Class, Spaghetti Code, and SwissArmyKnife antipatterns.}
}

@article{saadehRefactoringOrderedCollections2013,
  title = {Refactoring with {{Ordered Collections}} of {{Fine-Grain Transformations}}},
  author = {Saadeh, Emmad and Kourie, D.},
  date = {2013},
  journaltitle = {Int. J. Softw. Eng. Knowl. Eng.},
  volume = {23},
  pages = {309--340},
  doi = {10.1142/S0218194013500095},
  url = {https://www.semanticscholar.org/paper/a80d3ac4abc162a4f8ca0e3225c93b8dd6f6f22c},
  abstract = {The objective of this paper is to explain the notion of fine-grain transformations (FGTs), showing how they can be used as prototypical building blocks for constructing refactorings of a design-level system description. FGT semantics are specified in terms of pre- and postconditions which, in turn, also determines the sequential dependency relationships between them. An algorithm is provided which uses sequential dependency relationships to convert an FGT-list to a set of so-called FGT-DAGs. It is shown how to compute the precondition of such ordered collections of FGTs. The paper introduces a new approach to deal with refactoring pre- and postconditions by defining them at two different levels. To give these concepts syntactical form, we rely on the Prolog formats used by an FGT-based refactoring prototype tool. An example is provided to illustrate the various concepts and to demonstrate that, because of their simplicity, well-defined pre-post semantics and their intuitive nature, FGTs provide a pragmatic basis for building refactorings.}
}

@article{saadehRefactoringOrderedCollections2013a,
  title = {Refactoring with {{Ordered Collections}} of {{Fine-Grain Transformations}}},
  author = {Saadeh, Emmad and Kourie, D.},
  date = {2013},
  journaltitle = {Int. J. Softw. Eng. Knowl. Eng.},
  volume = {23},
  pages = {309--340},
  doi = {10.1142/S0218194013500095},
  url = {https://www.semanticscholar.org/paper/a80d3ac4abc162a4f8ca0e3225c93b8dd6f6f22c},
  abstract = {The objective of this paper is to explain the notion of fine-grain transformations (FGTs), showing how they can be used as prototypical building blocks for constructing refactorings of a design-level system description. FGT semantics are specified in terms of pre- and postconditions which, in turn, also determines the sequential dependency relationships between them. An algorithm is provided which uses sequential dependency relationships to convert an FGT-list to a set of so-called FGT-DAGs. It is shown how to compute the precondition of such ordered collections of FGTs. The paper introduces a new approach to deal with refactoring pre- and postconditions by defining them at two different levels. To give these concepts syntactical form, we rely on the Prolog formats used by an FGT-based refactoring prototype tool. An example is provided to illustrate the various concepts and to demonstrate that, because of their simplicity, well-defined pre-post semantics and their intuitive nature, FGTs provide a pragmatic basis for building refactorings.}
}

@article{sae-limContextBasedApproach2018,
  title = {Context‐based Approach to Prioritize Code Smells for Prefactoring},
  author = {Sae-Lim, Natthawute and Hayashi, Shinpei and Saeki, M.},
  date = {2018},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {30},
  pages = {null},
  doi = {10.1002/smr.1886},
  url = {https://www.semanticscholar.org/paper/d0a56ba9f8f6703afd018e04bd2c1a361c73ed49},
  abstract = {Existing techniques for detecting code smells (indicators of source code problems) do not consider the current context, which renders them unsuitable for developers who have a specific context, such as modules within their focus. Consequently, the developers must spend time identifying relevant smells. We propose a technique to prioritize code smells using the developers' context. Explicit data of the context are obtained using a list of issues extracted from an issue tracking system. We applied impact analysis to the list of issues and used the results to specify the context‐relevant smells. Results show that our approach can provide developers with a list of prioritized code smells related to their current context. We conducted several empirical studies to investigate the characteristics of our technique and factors that might affect the ranking quality. Additionally, we conducted a controlled experiment with professional developers to evaluate our technique. The results demonstrate the effectiveness of our technique.}
}

@article{sahinCodeSmellDetectionBilevel2014,
  title = {Code-{{Smell Detection}} as a {{Bilevel Problem}}},
  author = {Sahin, D. and Kessentini, M. and Bechikh, Slim and Deb, K.},
  date = {2014},
  journaltitle = {ACM Trans. Softw. Eng. Methodol.},
  volume = {24},
  pages = {6:1-6:44},
  doi = {10.1145/2675067},
  url = {https://www.semanticscholar.org/paper/7db629d8c31b505312b4e7096200addf133abdd0},
  abstract = {Code smells represent design situations that can affect the maintenance and evolution of software. They make the system difficult to evolve. Code smells are detected, in general, using quality metrics that represent some symptoms. However, the selection of suitable quality metrics is challenging due to the absence of consensus in identifying some code smells based on a set of symptoms and also the high calibration effort in determining manually the threshold value for each metric. In this article, we propose treating the generation of code-smell detection rules as a bilevel optimization problem. Bilevel optimization problems represent a class of challenging optimization problems, which contain two levels of optimization tasks. In these problems, only the optimal solutions to the lower-level problem become possible feasible candidates to the upper-level problem. In this sense, the code-smell detection problem can be treated as a bilevel optimization problem, but due to lack of suitable solution techniques, it has been attempted to be solved as a single-level optimization problem in the past. In our adaptation here, the upper-level problem generates a set of detection rules, a combination of quality metrics, which maximizes the coverage of the base of code-smell examples and artificial code smells generated by the lower level. The lower level maximizes the number of generated artificial code smells that cannot be detected by the rules produced by the upper level. The main advantage of our bilevel formulation is that the generation of detection rules is not limited to some code-smell examples identified manually by developers that are difficult to collect, but it allows the prediction of new code-smell behavior that is different from those of the base of examples. The statistical analysis of our experiments over 31 runs on nine open-source systems and one industrial project shows that seven types of code smells were detected with an average of more than 86\% in terms of precision and recall. The results confirm the outperformance of our bilevel proposal compared to state-of-art code-smell detection techniques. The evaluation performed by software engineers also confirms the relevance of detected code smells to improve the quality of software systems.}
}

@inproceedings{schmidtCatalogingPromptPatterns2023,
  title = {Cataloging {{Prompt Patterns}} to {{Enhance}} the {{Discipline}} of {{Prompt Engineering}}},
  author = {Schmidt, Douglas C. and Spencer-Smith, Jesse and Fu, Quchen and White, Jules},
  date = {2023},
  url = {https://api.semanticscholar.org/CorpusID:257368147}
}

@inproceedings{schmidtCatalogingPromptPatterns2023a,
  title = {Cataloging {{Prompt Patterns}} to {{Enhance}} the {{Discipline}} of {{Prompt Engineering}}},
  author = {Schmidt, Douglas C. and Spencer-Smith, Jesse and Fu, Quchen and White, Jules},
  date = {2023},
  url = {https://api.semanticscholar.org/CorpusID:257368147}
}

@article{schusterMacroficationRefactoringReverse2016,
  title = {Macrofication: {{Refactoring}} by {{Reverse Macro Expansion}}},
  author = {Schuster, Christopher and Disney, Tim and Flanagan, C.},
  date = {2016},
  doi = {10.1007/978-3-662-49498-1_25},
  url = {https://www.semanticscholar.org/paper/76062dde46541f19f89a9a105b9108985f1f4ed5},
  abstract = {S2 TL;DR: For each pattern-template macro, this paper can automatically generate a corresponding refactoring tool that finds complex code fragments matching the macro template and replaces them with the equivalent but simpler macro invocation pattern; this novelRefactoring process macrofication is called.}
}

@article{schusterMacroficationRefactoringReverse2016a,
  title = {Macrofication: {{Refactoring}} by {{Reverse Macro Expansion}}},
  author = {Schuster, Christopher and Disney, Tim and Flanagan, C.},
  date = {2016},
  doi = {10.1007/978-3-662-49498-1_25},
  url = {https://www.semanticscholar.org/paper/76062dde46541f19f89a9a105b9108985f1f4ed5},
  abstract = {S2 TL;DR: For each pattern-template macro, this paper can automatically generate a corresponding refactoring tool that finds complex code fragments matching the macro template and replaces them with the equivalent but simpler macro invocation pattern; this novelRefactoring process macrofication is called.}
}

@article{selimTestDrivenApproachExtracting2011,
  title = {A {{Test-Driven Approach}} for {{Extracting Libraries}} of {{Reusable Components}} from {{Existing Applications}}},
  author = {Selim, Elaf and Ghanam, Yaser and Burns, C. and Seyed, T. and Maurer, F.},
  date = {2011},
  doi = {10.1007/978-3-642-20677-1_17},
  url = {https://www.semanticscholar.org/paper/1571c7ec82f4b32480aae2b3c40c4e4ff5f8d75d},
  abstract = {S2 TL;DR: An approach that relies on refactoring and testing practices for extracting reusable assets from existing applications that creates reusable APIs in a bottom-up fashion, on demand when a new application might benefit from component in an existing application.}
}

@article{selimTestDrivenApproachExtracting2011a,
  title = {A {{Test-Driven Approach}} for {{Extracting Libraries}} of {{Reusable Components}} from {{Existing Applications}}},
  author = {Selim, Elaf and Ghanam, Yaser and Burns, C. and Seyed, T. and Maurer, F.},
  date = {2011},
  doi = {10.1007/978-3-642-20677-1_17},
  url = {https://www.semanticscholar.org/paper/1571c7ec82f4b32480aae2b3c40c4e4ff5f8d75d},
  abstract = {S2 TL;DR: An approach that relies on refactoring and testing practices for extracting reusable assets from existing applications that creates reusable APIs in a bottom-up fashion, on demand when a new application might benefit from component in an existing application.}
}

@article{simulaExploringImpactIntersmell2012,
  title = {Exploring the Impact of Inter-Smell Relations in the Maintainability of a System : {{An}} Empirical Study},
  author = {Simula, Aiko Yamashita},
  date = {2012},
  url = {https://www.semanticscholar.org/paper/4c3581fe9b320aa59b11d742a52b607bb8969581},
  abstract = {Code smells are indicators of deeper problems in the design that may cause difficulties in the evolution of a system. While previous studies have mainly focused on studying the effects of individual smells on maintainability, we believe that interactions tend to occur between code smells. The research in this paper investigates the potential interactions amongst twelve different code smells, and how those interactions can lead to maintenance problems. Four medium-sized systems with equivalent functionality but dissimilar design were examined for smells. The systems were the object of several change requests for a period of four weeks. During that period, we recorded on a daily basis problems faced by developers and their associated Java files. The first analysis is based on Principal Component Analysis (PCA), to identify components formed by collocated code smells (i.e., smells located in the same file). Analysis on the nature of the problems, as reported by the developers in daily interviews and think-aloud sessions, revealed how some of the collocated smells interacted with each other, causing maintenance problems. Finally, we could observe that some interactions occur across files, for which we suggest integrating dependency analysis when analyzing effects of code smells on maintainability.}
}

@article{sjobergQuantifyingEffectCode2012,
  title = {Quantifying the {{Effect}} of {{Code Smells}} on {{Maintenance Effort}}},
  author = {Sjøberg, Dag I. K. and Yamashita, A. and Anda, Bente and Mockus, A. and Dybå, T.},
  date = {2012},
  doi = {10.1109/tse.2012.89},
  url = {https://www.semanticscholar.org/paper/8b0197d7c528c72c2997ec09091956de29783da6},
  abstract = {Context: Code smells are assumed to indicate bad design that leads to less maintainable code. However, this assumption has not been investigated in controlled studies with professional software developers. Aim: This paper investigates the relationship between code smells and maintenance effort. Method: Six developers were hired to perform three maintenance tasks each on four functionally equivalent Java systems originally implemented by different companies. Each developer spent three to four weeks. In total, they modified 298 Java files in the four systems. An Eclipse IDE plug-in measured the exact amount of time a developer spent maintaining each file. Regression analysis was used to explain the effort using file properties, including the number of smells. Results: None of the 12 investigated smells was significantly associated with increased effort after we adjusted for file size and the number of changes; Refused Bequest was significantly associated with decreased effort. File size and the number of changes explained almost all of the modeled variation in effort. Conclusion: The effects of the 12 smells on maintenance effort were limited. To reduce maintenance effort, a focus on reducing code size and the work practices that limit the number of changes may be more beneficial than refactoring code smells.}
}

@article{souzaPowerBotsUnderstanding2018,
  title = {The {{Power}} of {{Bots}}: {{Understanding Bots}} in {{OSS Projects}}},
  author = {family=Souza, given=Bruno Mendes, prefix=de, useprefix=false and Chaves, A.},
  date = {2018},
  url = {https://www.semanticscholar.org/paper/8790146508d0b1c48e70627dde63f21ccec73d13},
  abstract = {MAIRIELI WESSEL, University of São Paulo, Brazil BRUNO MENDES DE SOUZA, Federal University of Technology, Paraná, Brazil IGOR STEINMACHER, Northern Arizona University, USA and Federal University of Technology, Paraná, Brazil IGOR S. WIESE, Federal University of Technology, Paraná, Brazil IVANILTON POLATO, Federal University of Technology, Paraná, Brazil ANA PAULA CHAVES, Federal University of Technology, Paraná, Brazil and Northern Arizona University, USA MARCO A. GEROSA, Northern Arizona University, USA}
}

@article{souzaPowerBotsUnderstanding2018a,
  title = {The {{Power}} of {{Bots}}: {{Understanding Bots}} in {{OSS Projects}}},
  author = {family=Souza, given=Bruno Mendes, prefix=de, useprefix=false and Chaves, A.},
  date = {2018},
  url = {https://www.semanticscholar.org/paper/8790146508d0b1c48e70627dde63f21ccec73d13},
  abstract = {MAIRIELI WESSEL, University of São Paulo, Brazil BRUNO MENDES DE SOUZA, Federal University of Technology, Paraná, Brazil IGOR STEINMACHER, Northern Arizona University, USA and Federal University of Technology, Paraná, Brazil IGOR S. WIESE, Federal University of Technology, Paraná, Brazil IVANILTON POLATO, Federal University of Technology, Paraná, Brazil ANA PAULA CHAVES, Federal University of Technology, Paraná, Brazil and Northern Arizona University, USA MARCO A. GEROSA, Northern Arizona University, USA}
}

@article{storeyDisruptingDeveloperProductivity2016,
  title = {Disrupting Developer Productivity One Bot at a Time},
  author = {Storey, M. and Zagalsky, A.},
  date = {2016},
  journaltitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/2950290.2983989},
  url = {https://www.semanticscholar.org/paper/fc2ac42a76d5a696c70ae4b64d31988ef46a501e},
  abstract = {Bots are used to support different software development activities, from automating repetitive tasks to bridging knowledge and communication gaps in software teams. We anticipate the use of Bots will increase and lead to improvements in software quality and developer and team productivity, but what if the disruptive effect is not what we expect? Our goal in this paper is to provoke and inspire researchers to study the impact (positive and negative) of Bots on software development. We outline the modern Bot landscape and use examples to describe the common roles Bots occupy in software teams. We propose a preliminary cognitive support framework that can be used to understand these roles and to reflect on the impact of Bots in software development on productivity. Finally, we consider challenges that Bots may bring and propose some directions for future research.}
}

@article{storeyDisruptingDeveloperProductivity2016a,
  title = {Disrupting Developer Productivity One Bot at a Time},
  author = {Storey, M. and Zagalsky, A.},
  date = {2016},
  journaltitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/2950290.2983989},
  url = {https://www.semanticscholar.org/paper/fc2ac42a76d5a696c70ae4b64d31988ef46a501e},
  abstract = {Bots are used to support different software development activities, from automating repetitive tasks to bridging knowledge and communication gaps in software teams. We anticipate the use of Bots will increase and lead to improvements in software quality and developer and team productivity, but what if the disruptive effect is not what we expect? Our goal in this paper is to provoke and inspire researchers to study the impact (positive and negative) of Bots on software development. We outline the modern Bot landscape and use examples to describe the common roles Bots occupy in software teams. We propose a preliminary cognitive support framework that can be used to understand these roles and to reflect on the impact of Bots in software development on productivity. Finally, we consider challenges that Bots may bring and propose some directions for future research.}
}

@article{terraLightweightRemodularizationProcess2016,
  title = {A {{Lightweight Remodularization Process Based}} on {{Structural Similarity}}},
  author = {Terra, Ricardo and Valente, M. T. and Anquetil, N.},
  date = {2016},
  journaltitle = {2016 X Brazilian Symposium on Software Components, Architectures and Reuse (SBCARS)},
  volume = {null},
  pages = {111--120},
  doi = {10.1109/SBCARS.2016.24},
  url = {https://www.semanticscholar.org/paper/fca6aec902b263c8c32f23782d7cdc2ebad91474},
  abstract = {Erosion process, when neglected over long periods, may reduce the concrete architecture to a small set of strongly-coupled and weakly-cohesive components. This nullifies the benefits provided by an architectural design, such as maintainability, scalability, portability, etc. In this scenario, the solution might be only achieved through a complete remodularization process. However, most remodularization approaches are heavyweight and lack tool support. This paper, therefore, proposes a lightweight and tool supported remodularization process based on structural similarity. The process is centered on the observation that the remodularization of a software system can be achieved by successive applications of Move Class, Move Method, and Extract Method refactorings. We evaluate the process in a modified version of an open-source software achieving a recall of 100\% and a precision of 50\%. The design decisions of the proposed process-such as the use of structural similarity, non-implementation of preconditions, and identification of the target entity on demand-were also evaluated obtaining outcome results.}
}

@article{terraLightweightRemodularizationProcess2016a,
  title = {A {{Lightweight Remodularization Process Based}} on {{Structural Similarity}}},
  author = {Terra, Ricardo and Valente, M. T. and Anquetil, N.},
  date = {2016},
  journaltitle = {2016 X Brazilian Symposium on Software Components, Architectures and Reuse (SBCARS)},
  volume = {null},
  pages = {111--120},
  doi = {10.1109/SBCARS.2016.24},
  url = {https://www.semanticscholar.org/paper/fca6aec902b263c8c32f23782d7cdc2ebad91474},
  abstract = {Erosion process, when neglected over long periods, may reduce the concrete architecture to a small set of strongly-coupled and weakly-cohesive components. This nullifies the benefits provided by an architectural design, such as maintainability, scalability, portability, etc. In this scenario, the solution might be only achieved through a complete remodularization process. However, most remodularization approaches are heavyweight and lack tool support. This paper, therefore, proposes a lightweight and tool supported remodularization process based on structural similarity. The process is centered on the observation that the remodularization of a software system can be achieved by successive applications of Move Class, Move Method, and Extract Method refactorings. We evaluate the process in a modified version of an open-source software achieving a recall of 100\% and a precision of 50\%. The design decisions of the proposed process-such as the use of structural similarity, non-implementation of preconditions, and identification of the target entity on demand-were also evaluated obtaining outcome results.}
}

@article{tonderEngineerBotPrinciples2019,
  title = {Towards s/Engineer/Bot: Principles for Program Repair Bots},
  author = {Tonder, R. V. and Goues, Claire Le},
  date = {2019},
  doi = {10.1109/BOTSE.2019.00019},
  url = {https://www.semanticscholar.org/paper/d37fc906a3d0320c3a34372e5baa5f62cb52b98d},
  abstract = {Of the hundreds of billions of dollars spent on developer wages, up to 25\% accounts for fixing bugs. Companies like Google save significant human effort and engineering costs with automatic bug detection tools, yet automatically fixing them is still a nascent endeavour. Very recent work (including our own) demonstrates the feasibility of automatic program repair in practice. As automated repair technology matures, it presents great appeal for integration into developer workflows. We believe software bots are a promising vehicle for realizing this integration, as they bridge the gap between human software development and automated processes. We envision repair bots orchestrating automated refactoring and bug fixing. To this end, we explore what building a repair bot entails. We draw on our understanding of patch generation, validation, and real world software development interactions to identify six principles that bear on engineering repair bots and discuss related design challenges for integrating human workflows. Ultimately, this work aims to foster critical focus and interest for making repair bots a reality.}
}

@article{tonderEngineerBotPrinciples2019a,
  title = {Towards s/Engineer/Bot: Principles for Program Repair Bots},
  author = {Tonder, R. V. and Goues, Claire Le},
  date = {2019},
  doi = {10.1109/BOTSE.2019.00019},
  url = {https://www.semanticscholar.org/paper/d37fc906a3d0320c3a34372e5baa5f62cb52b98d},
  abstract = {Of the hundreds of billions of dollars spent on developer wages, up to 25\% accounts for fixing bugs. Companies like Google save significant human effort and engineering costs with automatic bug detection tools, yet automatically fixing them is still a nascent endeavour. Very recent work (including our own) demonstrates the feasibility of automatic program repair in practice. As automated repair technology matures, it presents great appeal for integration into developer workflows. We believe software bots are a promising vehicle for realizing this integration, as they bridge the gap between human software development and automated processes. We envision repair bots orchestrating automated refactoring and bug fixing. To this end, we explore what building a repair bot entails. We draw on our understanding of patch generation, validation, and real world software development interactions to identify six principles that bear on engineering repair bots and discuss related design challenges for integrating human workflows. Ultimately, this work aims to foster critical focus and interest for making repair bots a reality.}
}

@article{tufanoEmpiricalInvestigationNature2016,
  title = {An Empirical Investigation into the Nature of Test Smells},
  author = {Tufano, Michele and Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R. and Lucia, A. D. and Poshyvanyk, D.},
  date = {2016},
  journaltitle = {2016 31st IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  volume = {null},
  pages = {4--15},
  doi = {10.1145/2970276.2970340},
  url = {https://www.semanticscholar.org/paper/a9198481e7642be53501ff6dbfba6e10dd8ee511},
  abstract = {Test smells have been defined as poorly designed tests and, as reported by recent empirical studies, their presence may negatively affect comprehension and maintenance of test suites. Despite this, there are no available automated tools to support identification and repair of test smells. In this paper, we firstly investigate developers' perception of test smells in a study with 19 participants. The results show that developers generally do not recognize (potentially harmful) test smells, highlighting that automated tools for identifying such smells are much needed. However, to build effective tools, deeper insights into the test smells phenomenon are required. To this aim, we conducted a large-scale empirical investigation aimed at analyzing (i) when test smells occur in source code, (ii) what their survivability is, and (iii) whether their presence is associated with the presence of design problems in production code (code smells). The results indicate that test smells are usually introduced when the corresponding test code is committed in the repository for the first time, and they tend to remain in a system for a long time. Moreover, we found various unexpected relationships between test and code smells. Finally, we show how the results of this study can be used to build effective automated tools for test smell detection and refactoring.}
}

@article{tufanoEmpiricalInvestigationNature2016a,
  title = {An Empirical Investigation into the Nature of Test Smells},
  author = {Tufano, Michele and Palomba, Fabio and Bavota, G. and Penta, M. D. and Oliveto, R. and Lucia, A. D. and Poshyvanyk, D.},
  date = {2016},
  journaltitle = {2016 31st IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  volume = {null},
  pages = {4--15},
  doi = {10.1145/2970276.2970340},
  url = {https://www.semanticscholar.org/paper/a9198481e7642be53501ff6dbfba6e10dd8ee511},
  abstract = {Test smells have been defined as poorly designed tests and, as reported by recent empirical studies, their presence may negatively affect comprehension and maintenance of test suites. Despite this, there are no available automated tools to support identification and repair of test smells. In this paper, we firstly investigate developers' perception of test smells in a study with 19 participants. The results show that developers generally do not recognize (potentially harmful) test smells, highlighting that automated tools for identifying such smells are much needed. However, to build effective tools, deeper insights into the test smells phenomenon are required. To this aim, we conducted a large-scale empirical investigation aimed at analyzing (i) when test smells occur in source code, (ii) what their survivability is, and (iii) whether their presence is associated with the presence of design problems in production code (code smells). The results indicate that test smells are usually introduced when the corresponding test code is committed in the repository for the first time, and they tend to remain in a system for a long time. Moreover, we found various unexpected relationships between test and code smells. Finally, we show how the results of this study can be used to build effective automated tools for test smell detection and refactoring.}
}

@article{tufanoWhenWhyYour2017,
  title = {When and {{Why Your Code Starts}} to {{Smell Bad}}},
  author = {Tufano, Michele and Palomba, Fabio and Bavota, G. and Oliveto, R. and Penta, M. D. and Lucia, A. D. and Poshyvanyk, D.},
  date = {2017},
  journaltitle = {2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
  volume = {1},
  pages = {403--414},
  doi = {10.1109/TSE.2017.2653105},
  url = {https://www.semanticscholar.org/paper/7b783d1a8d96c771bebede44cf11cd3a2e48d288},
  abstract = {In past and recent years, the issues related to managing technical debt received significant attention by researchers from both industry and academia. There are several factors that contribute to technical debt. One of these is represented by code bad smells, i.e., Symptoms of poor design and implementation choices. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced. To fill this gap, we conducted a large empirical study over the change history of 200 open source projects from different software ecosystems and investigated when bad smells are introduced by developers, and the circumstances and reasons behind their introduction. Our study required the development of a strategy to identify smell-introducing commits, the mining of over 0.5M commits, and the manual analysis of 9,164 of them (i.e., Those identified as smell-introducing). Our findings mostly contradict common wisdom stating that smells are being introduced during evolutionary tasks. In the light of our results, we also call for the need to develop a new generation of recommendation systems aimed at properly planning smell refactoring activities.}
}

@article{tufanoWhenWhyYour2017a,
  title = {When and {{Why Your Code Starts}} to {{Smell Bad}}},
  author = {Tufano, Michele and Palomba, Fabio and Bavota, G. and Oliveto, R. and Penta, M. D. and Lucia, A. D. and Poshyvanyk, D.},
  date = {2017},
  journaltitle = {2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
  volume = {1},
  pages = {403--414},
  doi = {10.1109/TSE.2017.2653105},
  url = {https://www.semanticscholar.org/paper/7b783d1a8d96c771bebede44cf11cd3a2e48d288},
  abstract = {In past and recent years, the issues related to managing technical debt received significant attention by researchers from both industry and academia. There are several factors that contribute to technical debt. One of these is represented by code bad smells, i.e., Symptoms of poor design and implementation choices. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced. To fill this gap, we conducted a large empirical study over the change history of 200 open source projects from different software ecosystems and investigated when bad smells are introduced by developers, and the circumstances and reasons behind their introduction. Our study required the development of a strategy to identify smell-introducing commits, the mining of over 0.5M commits, and the manual analysis of 9,164 of them (i.e., Those identified as smell-introducing). Our findings mostly contradict common wisdom stating that smells are being introduced during evolutionary tasks. In the light of our results, we also call for the need to develop a new generation of recommendation systems aimed at properly planning smell refactoring activities.}
}

@article{tufanoWhenWhyYour2017b,
  title = {When and {{Why Your Code Starts}} to {{Smell Bad}}},
  author = {Tufano, Michele and Palomba, Fabio and Bavota, G. and Oliveto, R. and Penta, M. D. and Lucia, A. D. and Poshyvanyk, D.},
  date = {2017},
  journaltitle = {2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
  volume = {1},
  pages = {403--414},
  doi = {10.1109/TSE.2017.2653105},
  url = {https://www.semanticscholar.org/paper/7b783d1a8d96c771bebede44cf11cd3a2e48d288},
  abstract = {In past and recent years, the issues related to managing technical debt received significant attention by researchers from both industry and academia. There are several factors that contribute to technical debt. One of these is represented by code bad smells, i.e., Symptoms of poor design and implementation choices. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced. To fill this gap, we conducted a large empirical study over the change history of 200 open source projects from different software ecosystems and investigated when bad smells are introduced by developers, and the circumstances and reasons behind their introduction. Our study required the development of a strategy to identify smell-introducing commits, the mining of over 0.5M commits, and the manual analysis of 9,164 of them (i.e., Those identified as smell-introducing). Our findings mostly contradict common wisdom stating that smells are being introduced during evolutionary tasks. In the light of our results, we also call for the need to develop a new generation of recommendation systems aimed at properly planning smell refactoring activities.}
}

@article{unterholznerImprovingRefactoringTools2014,
  title = {Improving Refactoring Tools in {{Smalltalk}} Using Static Type Inference},
  author = {Unterholzner, Martin},
  date = {2014},
  journaltitle = {Sci. Comput. Program.},
  volume = {96},
  pages = {70--83},
  doi = {10.1016/j.scico.2013.11.032},
  url = {https://www.semanticscholar.org/paper/6f5be6191e075d4a6fee551af49836594efef9dc},
  abstract = {S2 TL;DR: The challenges in the context of refactoring raised by the dynamic type system of Smalltalk are highlighted and the use of static code analysis for performing type inference to gather information about the dependencies in the program's source code is proposed.}
}

@article{unterholznerImprovingRefactoringTools2014a,
  title = {Improving Refactoring Tools in {{Smalltalk}} Using Static Type Inference},
  author = {Unterholzner, Martin},
  date = {2014},
  journaltitle = {Sci. Comput. Program.},
  volume = {96},
  pages = {70--83},
  doi = {10.1016/j.scico.2013.11.032},
  url = {https://www.semanticscholar.org/paper/6f5be6191e075d4a6fee551af49836594efef9dc},
  abstract = {S2 TL;DR: The challenges in the context of refactoring raised by the dynamic type system of Smalltalk are highlighted and the use of static code analysis for performing type inference to gather information about the dependencies in the program's source code is proposed.}
}

@article{urliHowDesignProgram2017,
  title = {How to {{Design}} a {{Program Repair Bot}}? {{Insights}} from the {{Repairnator Project}}},
  author = {Urli, Simon and Yu, Zhongxing and Seinturier, L. and Martin, Monperrus},
  date = {2017},
  journaltitle = {2018 IEEE/ACM 40th International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP)},
  volume = {null},
  pages = {95--104},
  doi = {10.1145/3183519.3183540},
  url = {https://www.semanticscholar.org/paper/6f1631357252d6145d86b086f17a27e6e7b0eaca},
  abstract = {Program repair research has made tremendous progress over the last few years, and software development bots are now being invented to help developers gain productivity. In this paper, we investigate the concept of a "program repair bot" and present Repairnator. The Repairnator bot is an autonomous agent that constantly monitors test failures, reproduces bugs, and runs program repair tools against each reproduced bug. If a patch is found, Repairnator bot reports it to the developers. At the time of writing, Repairnator uses three different program repair systems and has been operating since February 2017. In total, it has studied 11 523 test failures over 1 609 open-source software projects hosted on GitHub, and has generated patches for 15 different bugs. Over months, we hit a number of hard technical challenges and had to make various design and engineering decisions. This gives us a unique experience in this area. In this paper, we reflect upon Repairnator in order to share this knowledge with the automatic program repair community.}
}

@article{urliHowDesignProgram2017a,
  title = {How to {{Design}} a {{Program Repair Bot}}? {{Insights}} from the {{Repairnator Project}}},
  author = {Urli, Simon and Yu, Zhongxing and Seinturier, L. and Martin, Monperrus},
  date = {2017},
  journaltitle = {2018 IEEE/ACM 40th International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP)},
  volume = {null},
  pages = {95--104},
  doi = {10.1145/3183519.3183540},
  url = {https://www.semanticscholar.org/paper/6f1631357252d6145d86b086f17a27e6e7b0eaca},
  abstract = {Program repair research has made tremendous progress over the last few years, and software development bots are now being invented to help developers gain productivity. In this paper, we investigate the concept of a "program repair bot" and present Repairnator. The Repairnator bot is an autonomous agent that constantly monitors test failures, reproduces bugs, and runs program repair tools against each reproduced bug. If a patch is found, Repairnator bot reports it to the developers. At the time of writing, Repairnator uses three different program repair systems and has been operating since February 2017. In total, it has studied 11 523 test failures over 1 609 open-source software projects hosted on GitHub, and has generated patches for 15 different bugs. Over months, we hit a number of hard technical challenges and had to make various design and engineering decisions. This gives us a unique experience in this area. In this paper, we reflect upon Repairnator in order to share this knowledge with the automatic program repair community.}
}

@article{vacaliucPythonDevelopmentOpenMP2011,
  title = {Python for {{Development}} of {{OpenMP}} and {{CUDA Kernels}} for {{Multidimensional Data}}},
  author = {Vacaliuc, B. and Patlolla, D. and D'Azevedo, E. and Davidson, G. and Jr, John K. Munro and Evans, T. and Joubert, W. and Bell, Z.},
  date = {2011},
  journaltitle = {2011 Symposium on Application Accelerators in High-Performance Computing},
  volume = {null},
  pages = {159--167},
  doi = {10.1109/SAAHPC.2011.26},
  url = {https://www.semanticscholar.org/paper/90ca81c243d8dc800d7066200841fbdcd3804054},
  abstract = {Design of data structures for high performance computing (HPC) is one of the principal challenges facing researchers looking to utilize heterogeneous computing machinery. Heterogeneous systems derive cost, power, and speed efficiency by being composed of the appropriate hardware for the task. Yet, each type of processor requires a specific organization of the application state in order to achieve peak performance. Discovering this and refactoring the code can be a challenging and time-consuming task for the researcher, as the data structures and the computational model must be co-designed. We present a methodology that uses Python as the environment for which to explore tradeoffs in both the data structure design as well as the code executing on the computation accelerator. Our method enables multi-dimensional arrays to be used effectively in any target environment. We have chosen to focus on OpenMP and CUDA environments, thus exploring the development of optimized kernels for the two most common classes of computing hardware available today: multi-core CPU and GPU. Python's large palette of file and network access routines, its associative indexing syntax and support for common HPC environments makes it relevant for diverse hardware ranging from laptops through computing clusters to the highest performance supercomputers. Our work enables researchers to accelerate the development of their codes on the computing hardware of their choice.}
}

@article{vacaliucPythonDevelopmentOpenMP2011a,
  title = {Python for {{Development}} of {{OpenMP}} and {{CUDA Kernels}} for {{Multidimensional Data}}},
  author = {Vacaliuc, B. and Patlolla, D. and D'Azevedo, E. and Davidson, G. and Jr, John K. Munro and Evans, T. and Joubert, W. and Bell, Z.},
  date = {2011},
  journaltitle = {2011 Symposium on Application Accelerators in High-Performance Computing},
  volume = {null},
  pages = {159--167},
  doi = {10.1109/SAAHPC.2011.26},
  url = {https://www.semanticscholar.org/paper/90ca81c243d8dc800d7066200841fbdcd3804054},
  abstract = {Design of data structures for high performance computing (HPC) is one of the principal challenges facing researchers looking to utilize heterogeneous computing machinery. Heterogeneous systems derive cost, power, and speed efficiency by being composed of the appropriate hardware for the task. Yet, each type of processor requires a specific organization of the application state in order to achieve peak performance. Discovering this and refactoring the code can be a challenging and time-consuming task for the researcher, as the data structures and the computational model must be co-designed. We present a methodology that uses Python as the environment for which to explore tradeoffs in both the data structure design as well as the code executing on the computation accelerator. Our method enables multi-dimensional arrays to be used effectively in any target environment. We have chosen to focus on OpenMP and CUDA environments, thus exploring the development of optimized kernels for the two most common classes of computing hardware available today: multi-core CPU and GPU. Python's large palette of file and network access routines, its associative indexing syntax and support for common HPC environments makes it relevant for diverse hardware ranging from laptops through computing clusters to the highest performance supercomputers. Our work enables researchers to accelerate the development of their codes on the computing hardware of their choice.}
}

@article{verebiModelbasedApproachSoftware2015,
  title = {A Model-Based Approach to Software Refactoring},
  author = {Verebi, Ioana},
  date = {2015},
  journaltitle = {2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  volume = {null},
  pages = {606--609},
  doi = {10.1109/ICSM.2015.7332524},
  url = {https://www.semanticscholar.org/paper/8cca97e67c21e55c4d0438396711757e9c593665},
  abstract = {Refactoring is a key activity for any software system, as it ensures that the system is easily maintainable and extensible. However, complex refactorings (restructurings) are largely performed by hand, as there are no automated means of chaining existent basic refactorings. In addition, developers cannot quickly and safely evaluate the effects of a restructuring solution over another. In this context, we introduce a model-based approach to software refactoring, which provides an easy and safe way to explore restructuring alternatives. Restructurings are written as a composition of low-level model transformations, making them reusable in different complex refactorings. In order to support our approach, we implemented a tool named reFactor, which aims to bridge the gap between design flaw detection and correction. It detects design problems and offers a platform to compose model transformations into composite restructurings, while permanently monitoring the overall quality of the code.}
}

@article{verebiModelbasedApproachSoftware2015a,
  title = {A Model-Based Approach to Software Refactoring},
  author = {Verebi, Ioana},
  date = {2015},
  journaltitle = {2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  volume = {null},
  pages = {606--609},
  doi = {10.1109/ICSM.2015.7332524},
  url = {https://www.semanticscholar.org/paper/8cca97e67c21e55c4d0438396711757e9c593665},
  abstract = {Refactoring is a key activity for any software system, as it ensures that the system is easily maintainable and extensible. However, complex refactorings (restructurings) are largely performed by hand, as there are no automated means of chaining existent basic refactorings. In addition, developers cannot quickly and safely evaluate the effects of a restructuring solution over another. In this context, we introduce a model-based approach to software refactoring, which provides an easy and safe way to explore restructuring alternatives. Restructurings are written as a composition of low-level model transformations, making them reusable in different complex refactorings. In order to support our approach, we implemented a tool named reFactor, which aims to bridge the gap between design flaw detection and correction. It detects design problems and offers a platform to compose model transformations into composite restructurings, while permanently monitoring the overall quality of the code.}
}

@article{vidalApproachPrioritizeCode2016,
  title = {An Approach to Prioritize Code Smells for Refactoring},
  author = {Vidal, S. and Marcos, C. and Pace, J. A. D.},
  date = {2016},
  journaltitle = {Automated Software Engineering},
  volume = {23},
  pages = {501--532},
  doi = {10.1007/s10515-014-0175-x},
  url = {https://www.semanticscholar.org/paper/121989b2d9efa64f511effcf031115e159fdcbea},
  abstract = {S2 TL;DR: A tool is developed that suggests a ranking of code smells, based on a combination of three criteria, namely: past component modifications, important modifiability scenarios for the system, and relevance of the kind of smell, which shows that the suggested code smells are useful to developers.}
}

@article{wangAutomaticSoftwareRefactoring2018,
  title = {Automatic {{Software Refactoring}} via {{Weighted Clustering}} in {{Method-Level Networks}}},
  author = {Wang, Ying and Yu, Hai and Zhu, Zhiliang and Zhang, Wei and Zhao, Yuli},
  date = {2018},
  journaltitle = {IEEE Transactions on Software Engineering},
  volume = {44},
  pages = {202--236},
  doi = {10.1109/TSE.2017.2679752},
  url = {https://www.semanticscholar.org/paper/8299e1870c2bfece67729552828d72ab90459261},
  abstract = {In this study, we describe a system-level multiple refactoring algorithm, which can identify the move method, move field, and extract class refactoring opportunities automatically according to the principle of “high cohesion and low coupling.” The algorithm works by merging and splitting related classes to obtain the optimal functionality distribution from the system-level. Furthermore, we present a weighted clustering algorithm for regrouping the entities in a system based on merged method-level networks. Using a series of preprocessing steps and preconditions, the “bad smells” introduced by cohesion and coupling problems can be removed from both the non-inheritance and inheritance hierarchies without changing the code behaviors. We rank the refactoring suggestions based on the anticipated benefits that they bring to the system. Based on comparisons with related research and assessing the refactoring results using quality metrics and empirical evaluation, we show that the proposed approach performs well in different systems and is beneficial from the perspective of the original developers. Finally, an open source tool is implemented to support the proposed approach.}
}

@article{wangAutomaticSoftwareRefactoring2018a,
  title = {Automatic {{Software Refactoring}} via {{Weighted Clustering}} in {{Method-Level Networks}}},
  author = {Wang, Ying and Yu, Hai and Zhu, Zhiliang and Zhang, Wei and Zhao, Yuli},
  date = {2018},
  journaltitle = {IEEE Transactions on Software Engineering},
  volume = {44},
  pages = {202--236},
  doi = {10.1109/TSE.2017.2679752},
  url = {https://www.semanticscholar.org/paper/8299e1870c2bfece67729552828d72ab90459261},
  abstract = {In this study, we describe a system-level multiple refactoring algorithm, which can identify the move method, move field, and extract class refactoring opportunities automatically according to the principle of “high cohesion and low coupling.” The algorithm works by merging and splitting related classes to obtain the optimal functionality distribution from the system-level. Furthermore, we present a weighted clustering algorithm for regrouping the entities in a system based on merged method-level networks. Using a series of preprocessing steps and preconditions, the “bad smells” introduced by cohesion and coupling problems can be removed from both the non-inheritance and inheritance hierarchies without changing the code behaviors. We rank the refactoring suggestions based on the anticipated benefits that they bring to the system. Based on comparisons with related research and assessing the refactoring results using quality metrics and empirical evaluation, we show that the proposed approach performs well in different systems and is beneficial from the perspective of the original developers. Finally, an open source tool is implemented to support the proposed approach.}
}

@article{wangCLEARClassLevel2015,
  title = {{{CLEAR}}: {{Class Level Software Refactoring Using Evolutionary Algorithms}}},
  author = {Wang, Muchou and Pan, Weifeng and Jiang, Bo and Yuan, C.},
  date = {2015},
  journaltitle = {Journal of Intelligent Systems},
  volume = {24},
  pages = {85--97},
  doi = {10.1515/jisys-2013-0058},
  url = {https://www.semanticscholar.org/paper/8ce5cb86d04a560c2299fa293879c639ae815ef1},
  abstract = {Abstract The original design of a software system is rarely prepared for every new requirement. Software systems should be updated frequently, which is usually accompanied by the decline in software modularity and quality. Although many approaches have been proposed to improve the quality of software, a majority of them are guided by metrics defined on the local properties of software. In this article, we propose to use a global metric borrowed from the network science to detect the moving method refactoring. First, our approach uses a bipartite network to represent classes, features (i.e., methods and fields), and their dependencies. Second, a new metric is introduced to quantify the modularity of a software system as a whole. Finally, a crossover-only evolutionary algorithm that uses the metric as its fitness function is introduced to optimize the class structure of a software system and detect the methods that should be moved. Empirical results on the benchmark Java projects show that our approach can find meaningful methods that should be moved with a high stability. The advantages of our approach are illustrated in comparison with some other approaches, specifically one refactoring approach, namely search-based refactoring approach (SBRA), and two community detection algorithms, namely a graph theoretic clustering algorithm (MCODE) and a fast algorithm for community detection (FG). Our approach provides a new way to do refactoring from the perspective of software structure.}
}

@article{wangCLEARClassLevel2015a,
  title = {{{CLEAR}}: {{Class Level Software Refactoring Using Evolutionary Algorithms}}},
  author = {Wang, Muchou and Pan, Weifeng and Jiang, Bo and Yuan, C.},
  date = {2015},
  journaltitle = {Journal of Intelligent Systems},
  volume = {24},
  pages = {85--97},
  doi = {10.1515/jisys-2013-0058},
  url = {https://www.semanticscholar.org/paper/8ce5cb86d04a560c2299fa293879c639ae815ef1},
  abstract = {Abstract The original design of a software system is rarely prepared for every new requirement. Software systems should be updated frequently, which is usually accompanied by the decline in software modularity and quality. Although many approaches have been proposed to improve the quality of software, a majority of them are guided by metrics defined on the local properties of software. In this article, we propose to use a global metric borrowed from the network science to detect the moving method refactoring. First, our approach uses a bipartite network to represent classes, features (i.e., methods and fields), and their dependencies. Second, a new metric is introduced to quantify the modularity of a software system as a whole. Finally, a crossover-only evolutionary algorithm that uses the metric as its fitness function is introduced to optimize the class structure of a software system and detect the methods that should be moved. Empirical results on the benchmark Java projects show that our approach can find meaningful methods that should be moved with a high stability. The advantages of our approach are illustrated in comparison with some other approaches, specifically one refactoring approach, namely search-based refactoring approach (SBRA), and two community detection algorithms, namely a graph theoretic clustering algorithm (MCODE) and a fast algorithm for community detection (FG). Our approach provides a new way to do refactoring from the perspective of software structure.}
}

@article{wenContextAwarePatchGeneration2018,
  title = {Context-{{Aware Patch Generation}} for {{Better Automated Program Repair}}},
  author = {Wen, Ming and Chen, Junjie and Wu, Rongxin and Hao, Dan and Cheung, S.},
  date = {2018},
  journaltitle = {2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)},
  volume = {null},
  pages = {1--11},
  doi = {10.1145/3180155.3180233},
  url = {https://www.semanticscholar.org/paper/df6061b9d3da5865e3385bbcbc7d039b3ef6bb0f},
  abstract = {The effectiveness of search-based automated program repair is limited in the number of correct patches that can be successfully generated. There are two causes of such limitation. First, the search space does not contain the correct patch. Second, the search space is huge and therefore the correct patch cannot be generated (ie correct patches are either generated after incorrect plausible ones or not generated within the time budget). To increase the likelihood of including the correct patches in the search space, we propose to work at a fine granularity in terms of AST nodes. This, however, will further enlarge the search space, increasing the challenge to find the correct patches. We address the challenge by devising a strategy to prioritize the candidate patches based on their likelihood of being correct. Specifically, we study the use of AST nodes' context information to estimate the likelihood. In this paper, we propose CapGen, a context-aware patch generation technique. The novelty which allows CapGen to produce more correct patches lies in three aspects: (1) The fine-granularity design enables it to find more correct fixing ingredients; (2) The context-aware prioritization of mutation operators enables it to constrain the search space; (3) Three context-aware models enable it to rank correct patches at high positions before incorrect plausible ones. We evaluate CapGen on Defects4J and compare it with the state-of-the-art program repair techniques. Our evaluation shows that CapGen outperforms and complements existing techniques. CapGen achieves a high precision of 84.00\% and can prioritize the correct patches before 98.78\% of the incorrect plausible ones.}
}

@article{wenContextAwarePatchGeneration2018a,
  title = {Context-{{Aware Patch Generation}} for {{Better Automated Program Repair}}},
  author = {Wen, Ming and Chen, Junjie and Wu, Rongxin and Hao, Dan and Cheung, S.},
  date = {2018},
  journaltitle = {2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)},
  volume = {null},
  pages = {1--11},
  doi = {10.1145/3180155.3180233},
  url = {https://www.semanticscholar.org/paper/df6061b9d3da5865e3385bbcbc7d039b3ef6bb0f},
  abstract = {The effectiveness of search-based automated program repair is limited in the number of correct patches that can be successfully generated. There are two causes of such limitation. First, the search space does not contain the correct patch. Second, the search space is huge and therefore the correct patch cannot be generated (ie correct patches are either generated after incorrect plausible ones or not generated within the time budget). To increase the likelihood of including the correct patches in the search space, we propose to work at a fine granularity in terms of AST nodes. This, however, will further enlarge the search space, increasing the challenge to find the correct patches. We address the challenge by devising a strategy to prioritize the candidate patches based on their likelihood of being correct. Specifically, we study the use of AST nodes' context information to estimate the likelihood. In this paper, we propose CapGen, a context-aware patch generation technique. The novelty which allows CapGen to produce more correct patches lies in three aspects: (1) The fine-granularity design enables it to find more correct fixing ingredients; (2) The context-aware prioritization of mutation operators enables it to constrain the search space; (3) Three context-aware models enable it to rank correct patches at high positions before incorrect plausible ones. We evaluate CapGen on Defects4J and compare it with the state-of-the-art program repair techniques. Our evaluation shows that CapGen outperforms and complements existing techniques. CapGen achieves a high precision of 84.00\% and can prioritize the correct patches before 98.78\% of the incorrect plausible ones.}
}

@article{wesselDonDisturbMe2021,
  title = {Don't {{Disturb Me}}: {{Challenges}} of {{Interacting}} with {{Software Bots}} on {{Open Source Software Projects}}},
  author = {Wessel, M. and Wiese, I. and Steinmacher, Igor and Gerosa, M.},
  date = {2021},
  journaltitle = {Proceedings of the ACM on Human-Computer Interaction},
  volume = {5},
  pages = {1--21},
  doi = {10.1145/3476042},
  url = {https://www.semanticscholar.org/paper/403fed77c51c95651d608d7db43b81380bb400b7},
  abstract = {Software bots are used to streamline tasks in Open Source Software (OSS) projects' pull requests, saving development cost, time, and effort. However, their presence can be disruptive to the community. We identified several challenges caused by bots in pull request interactions by interviewing 21 practitioners, including project maintainers, contributors, and bot developers. In particular, our findings indicate noise as a recurrent and central problem. Noise affects both human communication and development workflow by overwhelming and distracting developers. Our main contribution is a theory of how human developers perceive annoying bot behaviors as noise on social coding platforms. This contribution may help practitioners understand the effects of adopting a bot, and researchers and tool designers may leverage our results to better support human-bot interaction on social coding platforms.}
}

@article{wesselDonDisturbMe2021a,
  title = {Don't {{Disturb Me}}: {{Challenges}} of {{Interacting}} with {{Software Bots}} on {{Open Source Software Projects}}},
  author = {Wessel, M. and Wiese, I. and Steinmacher, Igor and Gerosa, M.},
  date = {2021},
  journaltitle = {Proceedings of the ACM on Human-Computer Interaction},
  volume = {5},
  pages = {1--21},
  doi = {10.1145/3476042},
  url = {https://www.semanticscholar.org/paper/403fed77c51c95651d608d7db43b81380bb400b7},
  abstract = {Software bots are used to streamline tasks in Open Source Software (OSS) projects' pull requests, saving development cost, time, and effort. However, their presence can be disruptive to the community. We identified several challenges caused by bots in pull request interactions by interviewing 21 practitioners, including project maintainers, contributors, and bot developers. In particular, our findings indicate noise as a recurrent and central problem. Noise affects both human communication and development workflow by overwhelming and distracting developers. Our main contribution is a theory of how human developers perceive annoying bot behaviors as noise on social coding platforms. This contribution may help practitioners understand the effects of adopting a bot, and researchers and tool designers may leverage our results to better support human-bot interaction on social coding platforms.}
}

@article{wesselEffectsAdoptingCode2020,
  title = {Effects of {{Adopting Code Review Bots}} on {{Pull Requests}} to {{OSS Projects}}},
  author = {Wessel, M. and Serebrenik, Alexander and Wiese, I. and Steinmacher, Igor and Gerosa, M.},
  date = {2020},
  journaltitle = {2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  volume = {null},
  pages = {1--11},
  doi = {10.1109/ICSME46990.2020.00011},
  url = {https://www.semanticscholar.org/paper/bcc92e10c4af9d531eb7e1d032c9d9a21a3918c7},
  abstract = {Software bots, which are widely adopted by Open Source Software (OSS) projects, support developers on several activities, including code review. However, as with any new technology adoption, bots may impact group dynamics. Since understanding and anticipating such effects is important for planning and management, we investigate how several activity indicators change after the adoption of a code review bot. We employed a regression discontinuity design on 1,194 software projects from GitHub. Our results indicate that the adoption of code review bots increases the number of monthly merged pull requests, decreases monthly non-merged pull requests, and decreases communication among developers. Practitioners and maintainers may leverage our results to understand, or even predict, bot effects on their projects’ social interactions.}
}

@article{wesselEffectsAdoptingCode2020a,
  title = {Effects of {{Adopting Code Review Bots}} on {{Pull Requests}} to {{OSS Projects}}},
  author = {Wessel, M. and Serebrenik, Alexander and Wiese, I. and Steinmacher, Igor and Gerosa, M.},
  date = {2020},
  journaltitle = {2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  volume = {null},
  pages = {1--11},
  doi = {10.1109/ICSME46990.2020.00011},
  url = {https://www.semanticscholar.org/paper/bcc92e10c4af9d531eb7e1d032c9d9a21a3918c7},
  abstract = {Software bots, which are widely adopted by Open Source Software (OSS) projects, support developers on several activities, including code review. However, as with any new technology adoption, bots may impact group dynamics. Since understanding and anticipating such effects is important for planning and management, we investigate how several activity indicators change after the adoption of a code review bot. We employed a regression discontinuity design on 1,194 software projects from GitHub. Our results indicate that the adoption of code review bots increases the number of monthly merged pull requests, decreases monthly non-merged pull requests, and decreases communication among developers. Practitioners and maintainers may leverage our results to understand, or even predict, bot effects on their projects’ social interactions.}
}

@article{wesselGitHubActionsImpact2022,
  title = {{{GitHub Actions}}: {{The Impact}} on the {{Pull Request Process}}},
  author = {Wessel, M. and Vargovich, Joseph and Gerosa, M. and Treude, Christoph},
  date = {2022},
  journaltitle = {ArXiv},
  volume = {abs/2206.14118},
  pages = {null},
  doi = {10.48550/arXiv.2206.14118},
  url = {https://www.semanticscholar.org/paper/a15dcdede812815df972de7c04df44f12546e6f2},
  abstract = {Software projects frequently use automation tools to perform repetitive activities in the distributed software development process. Recently, GitHub introduced GitHub Actions, a feature providing automated workflows for software projects. Understanding and anticipating the effects of adopting such technology is important for planning and management. Our research investigates how projects use GitHub Actions, what the developers discuss about them, and how project activity indicators change after their adoption. Our results indicate that 1,489 out of 5,000 most popular repositories (almost 30\% of our sample) adopt GitHub Actions and that developers frequently ask for help implementing them. Our findings also suggest that the adoption of GitHub Actions leads to more rejections of pull requests (PRs), more communication in accepted PRs and less communication in rejected PRs, fewer commits in accepted PRs and more commits in rejected PRs, and more time to accept a PR. We found similar results when segmenting our results by categories of GitHub Actions. We suggest practitioners consider these effects when adopting GitHub Actions on their projects.}
}

@article{wesselGitHubActionsImpact2022a,
  title = {{{GitHub Actions}}: {{The Impact}} on the {{Pull Request Process}}},
  author = {Wessel, M. and Vargovich, Joseph and Gerosa, M. and Treude, Christoph},
  date = {2022},
  journaltitle = {ArXiv},
  volume = {abs/2206.14118},
  pages = {null},
  doi = {10.48550/arXiv.2206.14118},
  url = {https://www.semanticscholar.org/paper/a15dcdede812815df972de7c04df44f12546e6f2},
  abstract = {Software projects frequently use automation tools to perform repetitive activities in the distributed software development process. Recently, GitHub introduced GitHub Actions, a feature providing automated workflows for software projects. Understanding and anticipating the effects of adopting such technology is important for planning and management. Our research investigates how projects use GitHub Actions, what the developers discuss about them, and how project activity indicators change after their adoption. Our results indicate that 1,489 out of 5,000 most popular repositories (almost 30\% of our sample) adopt GitHub Actions and that developers frequently ask for help implementing them. Our findings also suggest that the adoption of GitHub Actions leads to more rejections of pull requests (PRs), more communication in accepted PRs and less communication in rejected PRs, fewer commits in accepted PRs and more commits in rejected PRs, and more time to accept a PR. We found similar results when segmenting our results by categories of GitHub Actions. We suggest practitioners consider these effects when adopting GitHub Actions on their projects.}
}

@article{wesselInconvenientSideSoftware2020,
  title = {The {{Inconvenient Side}} of {{Software Bots}} on {{Pull Requests}}},
  author = {Wessel, M. and Steinmacher, Igor},
  date = {2020},
  journaltitle = {Proceedings of the IEEE/ACM 42nd International Conference on Software Engineering Workshops},
  volume = {null},
  pages = {null},
  doi = {10.1145/3387940.3391504},
  url = {https://www.semanticscholar.org/paper/fee3a7e9acaee78f3466ac27d9153f1012150019},
  abstract = {Software bots are applications that integrate their work with humans' tasks, serving as conduits between users and other tools. Due to their ability to automate tasks, bots have been widely adopted by Open Source Software (OSS) projects hosted on GitHub. Commonly, OSS projects use bots to automate a variety of routine tasks to save time from maintainers and contributors. Although bots can be useful for supporting maintainers' work, sometimes their comments are seen as spams, and are quickly ignored by contributors. In fact, the way that these bots interact on pull requests can be disruptive and perceived as unwelcoming. In this paper, we propose the concept of a meta-bot to deal with current problems on the human-bot interaction on pull requests. Besides providing additional value to this interaction, meta-bot will reduce interruptions and help maintainers and contributors stay aware of important information.}
}

@article{wesselInconvenientSideSoftware2020a,
  title = {The {{Inconvenient Side}} of {{Software Bots}} on {{Pull Requests}}},
  author = {Wessel, M. and Steinmacher, Igor},
  date = {2020},
  journaltitle = {Proceedings of the IEEE/ACM 42nd International Conference on Software Engineering Workshops},
  volume = {null},
  pages = {null},
  doi = {10.1145/3387940.3391504},
  url = {https://www.semanticscholar.org/paper/fee3a7e9acaee78f3466ac27d9153f1012150019},
  abstract = {Software bots are applications that integrate their work with humans' tasks, serving as conduits between users and other tools. Due to their ability to automate tasks, bots have been widely adopted by Open Source Software (OSS) projects hosted on GitHub. Commonly, OSS projects use bots to automate a variety of routine tasks to save time from maintainers and contributors. Although bots can be useful for supporting maintainers' work, sometimes their comments are seen as spams, and are quickly ignored by contributors. In fact, the way that these bots interact on pull requests can be disruptive and perceived as unwelcoming. In this paper, we propose the concept of a meta-bot to deal with current problems on the human-bot interaction on pull requests. Besides providing additional value to this interaction, meta-bot will reduce interruptions and help maintainers and contributors stay aware of important information.}
}

@article{wesselPowerBots2018,
  title = {The {{Power}} of {{Bots}}},
  author = {Wessel, M. and family=Souza, given=Bruno Mendes, prefix=de, useprefix=false and Steinmacher, Igor and Wiese, I. and Polato, Ivanilton and Chaves, A. and Gerosa, M.},
  date = {2018},
  journaltitle = {Proceedings of the ACM on Human-Computer Interaction},
  volume = {2},
  pages = {1--19},
  doi = {10.1145/3274451},
  url = {https://www.semanticscholar.org/paper/b6f22749b1b5494376b56ca44f80e4c4af6d8acb},
  abstract = {Leveraging the pull request model of social coding platforms, Open Source Software (OSS) integrators review developers' contributions, checking aspects like license, code quality, and testability. Some projects use bots to automate predefined, sometimes repetitive tasks, thereby assisting integrators' and contributors' work. Our research investigates the usage and impact of such bots. We sampled 351 popular projects from GitHub and found that 93 (26\%) use bots. We classified the bots, collected metrics from before and after bot adoption, and surveyed 228 developers and integrators. Our results indicate that bots perform numerous tasks. Although integrators reported that bots are useful for maintenance tasks, we did not find a consistent, statistically significant difference between before and after bot adoption across the analyzed projects in terms of number of comments, commits, changed files, and time to close pull requests. Our survey respondents deem the current bots as not smart enough and provided insights into the bots' relevance for specific tasks, challenges, and potential new features. We discuss some of the raised suggestions and challenges in light of the literature in order to help GitHub bot designers reuse and test ideas and technologies already investigated in other contexts.}
}

@article{wesselPowerBots2018a,
  title = {The {{Power}} of {{Bots}}},
  author = {Wessel, M. and family=Souza, given=Bruno Mendes, prefix=de, useprefix=false and Steinmacher, Igor and Wiese, I. and Polato, Ivanilton and Chaves, A. and Gerosa, M.},
  date = {2018},
  journaltitle = {Proceedings of the ACM on Human-Computer Interaction},
  volume = {2},
  pages = {1--19},
  doi = {10.1145/3274451},
  url = {https://www.semanticscholar.org/paper/b6f22749b1b5494376b56ca44f80e4c4af6d8acb},
  abstract = {Leveraging the pull request model of social coding platforms, Open Source Software (OSS) integrators review developers' contributions, checking aspects like license, code quality, and testability. Some projects use bots to automate predefined, sometimes repetitive tasks, thereby assisting integrators' and contributors' work. Our research investigates the usage and impact of such bots. We sampled 351 popular projects from GitHub and found that 93 (26\%) use bots. We classified the bots, collected metrics from before and after bot adoption, and surveyed 228 developers and integrators. Our results indicate that bots perform numerous tasks. Although integrators reported that bots are useful for maintenance tasks, we did not find a consistent, statistically significant difference between before and after bot adoption across the analyzed projects in terms of number of comments, commits, changed files, and time to close pull requests. Our survey respondents deem the current bots as not smart enough and provided insights into the bots' relevance for specific tasks, challenges, and potential new features. We discuss some of the raised suggestions and challenges in light of the literature in order to help GitHub bot designers reuse and test ideas and technologies already investigated in other contexts.}
}

@article{wesselQualityGatekeepersInvestigating2021,
  title = {Quality Gatekeepers: Investigating the Effects of Code Review Bots on Pull Request Activities},
  author = {Wessel, M. and Serebrenik, Alexander and Wiese, I. and Steinmacher, Igor and Gerosa, M.},
  date = {2021},
  journaltitle = {Empirical Software Engineering},
  volume = {27},
  pages = {null},
  doi = {10.1007/s10664-022-10130-9},
  url = {https://www.semanticscholar.org/paper/10dfb518f04550110bcdaa2b6704f0198411ff12},
  abstract = {S2 TL;DR: The results indicate that the adoption of code review bots increases the number of monthly merged pull requests, decreases monthly non-mergedPull requests, and decreases communication among developers.}
}

@article{wesselQualityGatekeepersInvestigating2021a,
  title = {Quality Gatekeepers: Investigating the Effects of Code Review Bots on Pull Request Activities},
  author = {Wessel, M. and Serebrenik, Alexander and Wiese, I. and Steinmacher, Igor and Gerosa, M.},
  date = {2021},
  journaltitle = {Empirical Software Engineering},
  volume = {27},
  pages = {null},
  doi = {10.1007/s10664-022-10130-9},
  url = {https://www.semanticscholar.org/paper/10dfb518f04550110bcdaa2b6704f0198411ff12},
  abstract = {S2 TL;DR: The results indicate that the adoption of code review bots increases the number of monthly merged pull requests, decreases monthly non-mergedPull requests, and decreases communication among developers.}
}

@article{wesselShouldStaleShould2019,
  title = {Should {{I Stale}} or {{Should I Close}}? {{An Analysis}} of a {{Bot That Closes Abandoned Issues}} and {{Pull Requests}}},
  author = {Wessel, M. and Steinmacher, Igor and Wiese, I. and Gerosa, M.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {38--42},
  doi = {10.1109/BotSE.2019.00018},
  url = {https://www.semanticscholar.org/paper/e39ae375a305c9cf3924006d0c506f0529748d56},
  abstract = {On GitHub, projects use bots to automate predefined and repetitive tasks related to issues and pull requests. Our research investigates the adoption of the stale bot, which helps maintainers triaging abandoned issues and pull requests. We analyzed the bots' configuration settings and their modifications over time. These settings define the time for tagging issues and pull request as stale and closing them. We collected data from 765 OSS projects hosted on GitHub. Our results indicate that most of the studied projects made no more than three modifications in the configurations file, issues tagged as bug reports are exempt from being considered stale, while the same occurs with pull requests that need some input to be processed.}
}



@article{wesselWhatExpectCode2020,
  title = {What to {{Expect}} from {{Code Review Bots}} on {{GitHub}}?: {{A Survey}} with {{OSS Maintainers}}},
  author = {Wessel, M. and Serebrenik, Alexander and Wiese, I. and Steinmacher, Igor and Gerosa, M.},
  date = {2020},
  journaltitle = {Proceedings of the XXXIV Brazilian Symposium on Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/3422392.3422459},
  url = {https://www.semanticscholar.org/paper/7ce77150cbd056acf8cdbee8d634053213b2ed53},
  abstract = {Software bots are used by Open Source Software (OSS) projects to streamline the code review process. Interfacing between developers and automated services, code review bots report continuous integration failures, code quality checks, and code coverage. However, the impact of such bots on maintenance tasks is still neglected. In this paper, we study how project maintainers experience code review bots. We surveyed 127 maintainers and asked about their expectations and perception of changes incurred by code review bots. Our findings reveal that the most frequent expectations include enhancing the feedback bots provide to developers, reducing the maintenance burden for developers, and enforcing code coverage. While maintainers report that bots satisfied their expectations, they also perceived unexpected effects, such as communication noise and newcomers' dropout. Based on these results, we provide a series of implications for bot developers, as well as insights for future research.}
}

@article{wesselWhatExpectCode2020a,
  title = {What to {{Expect}} from {{Code Review Bots}} on {{GitHub}}?: {{A Survey}} with {{OSS Maintainers}}},
  author = {Wessel, M. and Serebrenik, Alexander and Wiese, I. and Steinmacher, Igor and Gerosa, M.},
  date = {2020},
  journaltitle = {Proceedings of the XXXIV Brazilian Symposium on Software Engineering},
  volume = {null},
  pages = {null},
  doi = {10.1145/3422392.3422459},
  url = {https://www.semanticscholar.org/paper/7ce77150cbd056acf8cdbee8d634053213b2ed53},
  abstract = {Software bots are used by Open Source Software (OSS) projects to streamline the code review process. Interfacing between developers and automated services, code review bots report continuous integration failures, code quality checks, and code coverage. However, the impact of such bots on maintenance tasks is still neglected. In this paper, we study how project maintainers experience code review bots. We surveyed 127 maintainers and asked about their expectations and perception of changes incurred by code review bots. Our findings reveal that the most frequent expectations include enhancing the feedback bots provide to developers, reducing the maintenance burden for developers, and enforcing code coverage. While maintainers report that bots satisfied their expectations, they also perceived unexpected effects, such as communication noise and newcomers' dropout. Based on these results, we provide a series of implications for bot developers, as well as insights for future research.}
}

@article{wyrichAutonomousBotAutomatic2019,
  title = {Towards an {{Autonomous Bot}} for {{Automatic Source Code Refactoring}}},
  author = {Wyrich, Marvin and Bogner, J.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {24--28},
  doi = {10.1109/BotSE.2019.00015},
  url = {https://www.semanticscholar.org/paper/a174ce902f6f2f102d5a4572d6d86c57932f419b},
  abstract = {Continuous refactoring is necessary to maintain source code quality and to cope with technical debt. Since manual refactoring is inefficient and error-prone, various solutions for automated refactoring have been proposed in the past. However, empirical studies have shown that these solutions are not widely accepted by software developers and most refactorings are still performed manually. For example, developers reported that refactoring tools should support functionality for reviewing changes. They also criticized that introducing such tools would require substantial effort for configuration and integration into the current development environment. In this paper, we present our work towards the Refactoring-Bot, an autonomous bot that integrates into the team like a human developer via the existing version control platform. The bot automatically performs refactorings to resolve code smells and presents the changes to a developer for asynchronous review via pull requests. This way, developers are not interrupted in their workflow and can review the changes at any time with familiar tools. Proposed refactorings can then be integrated into the code base via the push of a button. We elaborate on our vision, discuss design decisions, describe the current state of development, and give an outlook on planned development and research activities.}
}

@article{wyrichAutonomousBotAutomatic2019a,
  title = {Towards an {{Autonomous Bot}} for {{Automatic Source Code Refactoring}}},
  author = {Wyrich, Marvin and Bogner, J.},
  date = {2019},
  journaltitle = {2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {24--28},
  doi = {10.1109/BotSE.2019.00015},
  url = {https://www.semanticscholar.org/paper/a174ce902f6f2f102d5a4572d6d86c57932f419b},
  abstract = {Continuous refactoring is necessary to maintain source code quality and to cope with technical debt. Since manual refactoring is inefficient and error-prone, various solutions for automated refactoring have been proposed in the past. However, empirical studies have shown that these solutions are not widely accepted by software developers and most refactorings are still performed manually. For example, developers reported that refactoring tools should support functionality for reviewing changes. They also criticized that introducing such tools would require substantial effort for configuration and integration into the current development environment. In this paper, we present our work towards the Refactoring-Bot, an autonomous bot that integrates into the team like a human developer via the existing version control platform. The bot automatically performs refactorings to resolve code smells and presents the changes to a developer for asynchronous review via pull requests. This way, developers are not interrupted in their workflow and can review the changes at any time with familiar tools. Proposed refactorings can then be integrated into the code base via the push of a button. We elaborate on our vision, discuss design decisions, describe the current state of development, and give an outlook on planned development and research activities.}
}

@article{wyrichBotsDonMind2021,
  title = {Bots {{Don}}’t {{Mind Waiting}}, {{Do They}}? {{Comparing}} the {{Interaction With Automatically}} and {{Manually Created Pull Requests}}},
  author = {Wyrich, Marvin and Ghit, Raoul and Haller, T. and Müller, Christiana},
  date = {2021},
  journaltitle = {2021 IEEE/ACM Third International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {6--10},
  doi = {10.1109/BotSE52550.2021.00009},
  url = {https://www.semanticscholar.org/paper/232b5ab7726a5c4f1f686b0eb09889e3932a81b7},
  abstract = {As a maintainer of an open source software project, you are usually happy about contributions in the form of pull requests that bring the project a step forward. Past studies have shown that when reviewing a pull request, not only its content is taken into account, but also, for example, the social characteristics of the contributor. Whether a contribution is accepted and how long this takes therefore depends not only on the content of the contribution. What we only have indications for so far, however, is that pull requests from bots may be prioritized lower, even if the bots are explicitly deployed by the development team and are considered useful. One goal of the bot research and development community is to design helpful bots to effectively support software development in a variety of ways. To get closer to this goal, in this GitHub mining study, we examine the measurable differences in how maintainers interact with manually created pull requests from humans compared to those created automatically by bots. About one third of all pull requests on GitHub currently come from bots. While pull requests from humans are accepted and merged in 72.53\% of all cases, this applies to only 37.38\% of bot pull requests. Furthermore, it takes significantly longer for a bot pull request to be interacted with and for it to be merged, even though they contain fewer changes on average than human pull requests. These results suggest that bots have yet to realize their full potential.}
}

@article{wyrichBotsDonMind2021a,
  title = {Bots {{Don}}’t {{Mind Waiting}}, {{Do They}}? {{Comparing}} the {{Interaction With Automatically}} and {{Manually Created Pull Requests}}},
  author = {Wyrich, Marvin and Ghit, Raoul and Haller, T. and Müller, Christiana},
  date = {2021},
  journaltitle = {2021 IEEE/ACM Third International Workshop on Bots in Software Engineering (BotSE)},
  volume = {null},
  pages = {6--10},
  doi = {10.1109/BotSE52550.2021.00009},
  url = {https://www.semanticscholar.org/paper/232b5ab7726a5c4f1f686b0eb09889e3932a81b7},
  abstract = {As a maintainer of an open source software project, you are usually happy about contributions in the form of pull requests that bring the project a step forward. Past studies have shown that when reviewing a pull request, not only its content is taken into account, but also, for example, the social characteristics of the contributor. Whether a contribution is accepted and how long this takes therefore depends not only on the content of the contribution. What we only have indications for so far, however, is that pull requests from bots may be prioritized lower, even if the bots are explicitly deployed by the development team and are considered useful. One goal of the bot research and development community is to design helpful bots to effectively support software development in a variety of ways. To get closer to this goal, in this GitHub mining study, we examine the measurable differences in how maintainers interact with manually created pull requests from humans compared to those created automatically by bots. About one third of all pull requests on GitHub currently come from bots. While pull requests from humans are accepted and merged in 72.53\% of all cases, this applies to only 37.38\% of bot pull requests. Furthermore, it takes significantly longer for a bot pull request to be interacted with and for it to be merged, even though they contain fewer changes on average than human pull requests. These results suggest that bots have yet to realize their full potential.}
}

@article{wyrichPerceptionAcceptanceAutonomous2020,
  title = {Perception and {{Acceptance}} of an {{Autonomous Refactoring Bot}}},
  author = {Wyrich, Marvin and Hebig, R. and Wagner, S. and Scandariato, R.},
  date = {2020},
  journaltitle = {ArXiv},
  volume = {abs/2001.02553},
  pages = {null},
  doi = {10.5220/0009168803030310},
  url = {https://www.semanticscholar.org/paper/051b0a545f2504c167ee3cabd084a55208c4bd40},
  abstract = {The use of autonomous bots for automatic support in software development tasks is increasing. In the past, however, they were not always perceived positively and sometimes experienced a negative bias compared to their human counterparts. We conducted a qualitative study in which we deployed an autonomous refactoring bot for 41 days in a student software development project. In between and at the end, we conducted semi-structured interviews to find out how developers perceive the bot and whether they are more or less critical when reviewing the contributions of a bot compared to human contributions. Our findings show that the bot was perceived as a useful and unobtrusive contributor, and developers were no more critical of it than they were about their human colleagues, but only a few team members felt responsible for the bot.}
}

@article{wyrichPerceptionAcceptanceAutonomous2020a,
  title = {Perception and {{Acceptance}} of an {{Autonomous Refactoring Bot}}},
  author = {Wyrich, Marvin and Hebig, R. and Wagner, S. and Scandariato, R.},
  date = {2020},
  journaltitle = {ArXiv},
  volume = {abs/2001.02553},
  pages = {null},
  doi = {10.5220/0009168803030310},
  url = {https://www.semanticscholar.org/paper/051b0a545f2504c167ee3cabd084a55208c4bd40},
  abstract = {The use of autonomous bots for automatic support in software development tasks is increasing. In the past, however, they were not always perceived positively and sometimes experienced a negative bias compared to their human counterparts. We conducted a qualitative study in which we deployed an autonomous refactoring bot for 41 days in a student software development project. In between and at the end, we conducted semi-structured interviews to find out how developers perceive the bot and whether they are more or less critical when reviewing the contributions of a bot compared to human contributions. Our findings show that the bot was perceived as a useful and unobtrusive contributor, and developers were no more critical of it than they were about their human colleagues, but only a few team members felt responsible for the bot.}
}

@article{xinIdentifyingTestsuiteoverfittedPatches2017,
  title = {Identifying Test-Suite-Overfitted Patches through Test Case Generation},
  author = {Xin, Qi and Reiss, S.},
  date = {2017},
  journaltitle = {Proceedings of the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  volume = {null},
  pages = {null},
  doi = {10.1145/3092703.3092718},
  url = {https://www.semanticscholar.org/paper/9f56ee102f4e6a8530b64c5d33fd007f288d305d},
  abstract = {A typical automatic program repair technique that uses a test suite as the correct criterion can produce a patched program that is test-suite-overfitted, or overfitting, which passes the test suite but does not actually repair the bug. In this paper, we propose DiffTGen which identifies a patched program to be overfitting by first generating new test inputs that uncover semantic differences between the original faulty program and the patched program, then testing the patched program based on the semantic differences, and finally generating test cases. Such a test case could be added to the original test suite to make it stronger and could prevent the repair technique from generating a similar overfitting patch again. We evaluated DiffTGen on 89 patches generated by four automatic repair techniques for Java with 79 of them being likely to be overfitting and incorrect. DiffTGen identifies in total 39 (49.4\%) overfitting patches and yields the corresponding test cases. We further show that an automatic repair technique, if configured with DiffTGen, could avoid yielding overfitting patches and potentially produce correct ones.}
}

@article{xinIdentifyingTestsuiteoverfittedPatches2017a,
  title = {Identifying Test-Suite-Overfitted Patches through Test Case Generation},
  author = {Xin, Qi and Reiss, S.},
  date = {2017},
  journaltitle = {Proceedings of the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  volume = {null},
  pages = {null},
  doi = {10.1145/3092703.3092718},
  url = {https://www.semanticscholar.org/paper/9f56ee102f4e6a8530b64c5d33fd007f288d305d},
  abstract = {A typical automatic program repair technique that uses a test suite as the correct criterion can produce a patched program that is test-suite-overfitted, or overfitting, which passes the test suite but does not actually repair the bug. In this paper, we propose DiffTGen which identifies a patched program to be overfitting by first generating new test inputs that uncover semantic differences between the original faulty program and the patched program, then testing the patched program based on the semantic differences, and finally generating test cases. Such a test case could be added to the original test suite to make it stronger and could prevent the repair technique from generating a similar overfitting patch again. We evaluated DiffTGen on 89 patches generated by four automatic repair techniques for Java with 79 of them being likely to be overfitting and incorrect. DiffTGen identifies in total 39 (49.4\%) overfitting patches and yields the corresponding test cases. We further show that an automatic repair technique, if configured with DiffTGen, could avoid yielding overfitting patches and potentially produce correct ones.}
}

@article{xinLeveragingSyntaxrelatedCode2017,
  title = {Leveraging Syntax-Related Code for Automated Program Repair},
  author = {Xin, Qi and Reiss, S.},
  date = {2017},
  journaltitle = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  volume = {null},
  pages = {660--670},
  doi = {10.1109/ASE.2017.8115676},
  url = {https://www.semanticscholar.org/paper/388f8fcb6456ca33ae3e861c06e8b978ba5914cd},
  abstract = {We present our automated program repair technique ssFix which leverages existing code (from a code database) that is syntax-related to the context of a bug to produce patches for its repair. Given a faulty program and a fault-exposing test suite, ssFix does fault localization to identify suspicious statements that are likely to be faulty. For each such statement, ssFix identifies a code chunk (or target chunk) including the statement and its local context. ssFix works on the target chunk to produce patches. To do so, it first performs syntactic code search to find candidate code chunks that are syntax-related, i.e., structurally similar and conceptually related, to the target chunk from a code database (or codebase) consisting of the local faulty program and an external code repository. ssFix assumes the correct fix to be contained in the candidate chunks, and it leverages each candidate chunk to produce patches for the target chunk. To do so, ssFix translates the candidate chunk by unifying the names used in the candidate chunk with those in the target chunk; matches the chunk components (expressions and statements) between the translated candidate chunk and the target chunk; and produces patches for the target chunk based on the syntactic differences that exist between the matched components and in the unmatched components. ssFix finally validates the patched programs generated against the test suite and reports the first one that passes the test suite. We evaluated ssFix on 357 bugs in the Defects4J bug dataset. Our results show that ssFix successfully repaired 20 bugs with valid patches generated and that it outperformed five other repair techniques for Java.}
}

@article{xinLeveragingSyntaxrelatedCode2017a,
  title = {Leveraging Syntax-Related Code for Automated Program Repair},
  author = {Xin, Qi and Reiss, S.},
  date = {2017},
  journaltitle = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  volume = {null},
  pages = {660--670},
  doi = {10.1109/ASE.2017.8115676},
  url = {https://www.semanticscholar.org/paper/388f8fcb6456ca33ae3e861c06e8b978ba5914cd},
  abstract = {We present our automated program repair technique ssFix which leverages existing code (from a code database) that is syntax-related to the context of a bug to produce patches for its repair. Given a faulty program and a fault-exposing test suite, ssFix does fault localization to identify suspicious statements that are likely to be faulty. For each such statement, ssFix identifies a code chunk (or target chunk) including the statement and its local context. ssFix works on the target chunk to produce patches. To do so, it first performs syntactic code search to find candidate code chunks that are syntax-related, i.e., structurally similar and conceptually related, to the target chunk from a code database (or codebase) consisting of the local faulty program and an external code repository. ssFix assumes the correct fix to be contained in the candidate chunks, and it leverages each candidate chunk to produce patches for the target chunk. To do so, ssFix translates the candidate chunk by unifying the names used in the candidate chunk with those in the target chunk; matches the chunk components (expressions and statements) between the translated candidate chunk and the target chunk; and produces patches for the target chunk based on the syntactic differences that exist between the matched components and in the unmatched components. ssFix finally validates the patched programs generated against the test suite and reports the first one that passes the test suite. We evaluated ssFix on 357 bugs in the Defects4J bug dataset. Our results show that ssFix successfully repaired 20 bugs with valid patches generated and that it outperformed five other repair techniques for Java.}
}

@article{yamashitaAssessingCapabilityCode2014,
  title = {Assessing the Capability of Code Smells to Explain Maintenance Problems: An Empirical Study Combining Quantitative and Qualitative Data},
  author = {Yamashita, A.},
  date = {2014},
  journaltitle = {Empirical Software Engineering},
  volume = {19},
  pages = {1111--1143},
  doi = {10.1007/s10664-013-9250-3},
  url = {https://www.semanticscholar.org/paper/34bff591b50c9562f014f755ce47a45425a468ec},
  abstract = {S2 TL;DR: Investigating the capability of twelve code smells to reflect actual maintenance problems found that violation of the Interface Segregation Principle (a.k.a. ISP violation) displayed the strongest connection with maintenance problems.}
}

@article{yamashitaCodeSmellsReflect2012,
  title = {Do Code Smells Reflect Important Maintainability Aspects?},
  author = {Yamashita, A. and Moonen, L.},
  date = {2012},
  journaltitle = {2012 28th IEEE International Conference on Software Maintenance (ICSM)},
  volume = {null},
  pages = {306--315},
  doi = {10.1109/ICSM.2012.6405287},
  url = {https://www.semanticscholar.org/paper/579272b3e502457cff0f6bc72579ab0a5334a628},
  abstract = {Code smells are manifestations of design flaws that can degrade code maintainability. As such, the existence of code smells seems an ideal indicator for maintainability assessments. However, to achieve comprehensive and accurate evaluations based on code smells, we need to know how well they reflect factors affecting maintainability. After identifying which maintainability factors are reflected by code smells and which not, we can use complementary means to assess the factors that are not addressed by smells. This paper reports on an empirical study that investigates the extent to which code smells reflect factors affecting maintainability that have been identified as important by programmers. We consider two sources for our analysis: (1) expert-based maintainability assessments of four Java systems before they entered a maintenance project, and (2) observations and interviews with professional developers who maintained these systems during 14 working days and implemented a number of change requests.}
}

@article{yamashitaCodeSmellsSystemlevel2013,
  title = {Code Smells as System-Level Indicators of Maintainability: {{An}} Empirical Study},
  author = {Yamashita, A. and Counsell, S.},
  date = {2013},
  journaltitle = {J. Syst. Softw.},
  volume = {86},
  pages = {2639--2653},
  doi = {10.1016/J.JSS.2013.05.007},
  url = {https://www.semanticscholar.org/paper/bee7b2bf042bbe1c82aa07b8776d26a5522426d1},
  abstract = {null}
}

@article{yamashitaDevelopersCareCode2013,
  title = {Do Developers Care about Code Smells? {{An}} Exploratory Survey},
  author = {Yamashita, A. and Moonen, L.},
  date = {2013},
  journaltitle = {2013 20th Working Conference on Reverse Engineering (WCRE)},
  volume = {null},
  pages = {242--251},
  doi = {10.1109/WCRE.2013.6671299},
  url = {https://www.semanticscholar.org/paper/98e812395664b440ed79e8512835c348812f34d4},
  abstract = {Code smells are a well-known metaphor to describe symptoms of code decay or other issues with code quality which can lead to a variety of maintenance problems. Even though code smell detection and removal has been well-researched over the last decade, it remains open to debate whether or not code smells should be considered meaningful conceptualizations of code quality issues from the developer's perspective. To some extent, this question applies as well to the results provided by current code smell detection tools. Are code smells really important for developers? If they are not, is this due to the lack of relevance of the underlying concepts, due to the lack of awareness about code smells on the developers' side, or due to the lack of appropriate tools for code smell analysis or removal? In order to align and direct research efforts to address actual needs and problems of professional developers, we need to better understand the knowledge about, and interest in code smells, together with their perceived criticality. This paper reports on the results obtained from an exploratory survey involving 85 professional software developers.}
}

@article{yamashitaDevelopersCareCode2013a,
  title = {Do Developers Care about Code Smells? {{An}} Exploratory Survey},
  author = {Yamashita, A. and Moonen, L.},
  date = {2013},
  journaltitle = {2013 20th Working Conference on Reverse Engineering (WCRE)},
  volume = {null},
  pages = {242--251},
  doi = {10.1109/WCRE.2013.6671299},
  url = {https://www.semanticscholar.org/paper/98e812395664b440ed79e8512835c348812f34d4},
  abstract = {Code smells are a well-known metaphor to describe symptoms of code decay or other issues with code quality which can lead to a variety of maintenance problems. Even though code smell detection and removal has been well-researched over the last decade, it remains open to debate whether or not code smells should be considered meaningful conceptualizations of code quality issues from the developer's perspective. To some extent, this question applies as well to the results provided by current code smell detection tools. Are code smells really important for developers? If they are not, is this due to the lack of relevance of the underlying concepts, due to the lack of awareness about code smells on the developers' side, or due to the lack of appropriate tools for code smell analysis or removal? In order to align and direct research efforts to address actual needs and problems of professional developers, we need to better understand the knowledge about, and interest in code smells, together with their perceived criticality. This paper reports on the results obtained from an exploratory survey involving 85 professional software developers.}
}

@article{yamashitaDevelopersCareCode2013b,
  title = {Do Developers Care about Code Smells? {{An}} Exploratory Survey},
  author = {Yamashita, A. and Moonen, L.},
  date = {2013},
  journaltitle = {2013 20th Working Conference on Reverse Engineering (WCRE)},
  volume = {null},
  pages = {242--251},
  doi = {10.1109/WCRE.2013.6671299},
  url = {https://www.semanticscholar.org/paper/98e812395664b440ed79e8512835c348812f34d4},
  abstract = {Code smells are a well-known metaphor to describe symptoms of code decay or other issues with code quality which can lead to a variety of maintenance problems. Even though code smell detection and removal has been well-researched over the last decade, it remains open to debate whether or not code smells should be considered meaningful conceptualizations of code quality issues from the developer's perspective. To some extent, this question applies as well to the results provided by current code smell detection tools. Are code smells really important for developers? If they are not, is this due to the lack of relevance of the underlying concepts, due to the lack of awareness about code smells on the developers' side, or due to the lack of appropriate tools for code smell analysis or removal? In order to align and direct research efforts to address actual needs and problems of professional developers, we need to better understand the knowledge about, and interest in code smells, together with their perceived criticality. This paper reports on the results obtained from an exploratory survey involving 85 professional software developers.}
}

@article{yamashitaExploringImpactIntersmell2013,
  title = {Exploring the Impact of Inter-Smell Relations on Software Maintainability: {{An}} Empirical Study},
  author = {Yamashita, A. and Moonen, L.},
  date = {2013},
  journaltitle = {2013 35th International Conference on Software Engineering (ICSE)},
  volume = {null},
  pages = {682--691},
  doi = {10.1109/ICSE.2013.6606614},
  url = {https://www.semanticscholar.org/paper/e18944245819cfc6905af89dd4bc93268f7e5558},
  abstract = {Code smells are indicators of issues with source code quality that may hinder evolution. While previous studies mainly focused on the effects of individual code smells on maintainability, we conjecture that not only the individual code smells but also the interactions between code smells affect maintenance. We empirically investigate the interactions amongst 12 code smells and analyze how those interactions relate to maintenance problems. Professional developers were hired for a period of four weeks to implement change requests on four medium-sized Java systems with known smells. On a daily basis, we recorded what specific problems they faced and which artifacts were associated with them. Code smells were automatically detected in the pre-maintenance versions of the systems and analyzed using Principal Component Analysis (PCA) to identify patterns of co-located code smells. Analysis of these factors with the observed maintenance problems revealed how smells that were co-located in the same artifact interacted with each other, and affected maintainability. Moreover, we found that code smell interactions occurred across coupled artifacts, with comparable negative effects as same-artifact co-location. We argue that future studies into the effects of code smells on maintainability should integrate dependency analysis in their process so that they can obtain a more complete understanding by including such coupled interactions.}
}

@article{yamashitaIntersmellRelationsIndustrial2015,
  title = {Inter-Smell Relations in Industrial and Open Source Systems: {{A}} Replication and Comparative Analysis},
  author = {Yamashita, A. and Zanoni, M. and Fontana, F. and Walter, Bartosz},
  date = {2015},
  journaltitle = {2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  volume = {null},
  pages = {121--130},
  doi = {10.1109/ICSM.2015.7332458},
  url = {https://www.semanticscholar.org/paper/c7ac74648dd95c3e7f02f120b0b3b11e9b72d482},
  abstract = {The presence of anti-patterns and code smells can affect adversely software evolution and quality. Recent work has shown that code smells that appear together in the same file (i.e., collocated smells) can interact with each other, leading to various types of maintenance issues and/or to the intensification of negative effects. It has also been found that code smell interactions can occur across coupled files (i.e., coupled smells), with comparable negative effects as the interaction of same-file (collocated) smells. Different inter-smell relations have been described in previous work, yet only few studies have evaluated them empirically. This study attempts to replicate the findings from previous work on inter-smell relations by analyzing larger systems, and by including both industrial and open source ones. We also include the analysis of coupled smells in addition to collocated smells, to achieve a more complete picture of inter-smell relations. Our results suggest that if coupled smells are not considered, one may risk increasing the number of false negatives when analysing inter-smells. A major finding is that patterns of inter-smell relations vary between open source and industrial systems, suggesting that contextual variables should be considered in further studies on code smells.}
}

@article{yamashitaWhatExtentCan2013,
  title = {To What Extent Can Maintenance Problems Be Predicted by Code Smell Detection? - {{An}} Empirical Study},
  author = {Yamashita, A. and Moonen, L.},
  date = {2013},
  journaltitle = {Inf. Softw. Technol.},
  volume = {55},
  pages = {2223--2242},
  doi = {10.1016/J.INFSOF.2013.08.002},
  url = {https://www.semanticscholar.org/paper/895bdcb6a8035ddb9b09588c0084587c7cf2b214},
  abstract = {S2 TL;DR: The role of code smells on the overall system maintainability is relatively minor, thus complementary approaches are needed to achieve more comprehensive assessments of maintainability.}
}

@article{yetistirenEvaluatingCodeQuality2023,
  title = {Evaluating the {{Code Quality}} of {{AI-Assisted Code Generation Tools}}: {{An Empirical Study}} on {{GitHub Copilot}}, {{Amazon CodeWhisperer}}, and {{ChatGPT}}},
  author = {Yetistiren, Burak and Özsoy, Isik and Ayerdem, Miray and Tüzün, Eray},
  date = {2023},
  journaltitle = {ArXiv},
  volume = {abs/2304.10778},
  url = {https://api.semanticscholar.org/CorpusID:258291698}
}

@article{yetistirenEvaluatingCodeQuality2023a,
  title = {Evaluating the {{Code Quality}} of {{AI-Assisted Code Generation Tools}}: {{An Empirical Study}} on {{GitHub Copilot}}, {{Amazon CodeWhisperer}}, and {{ChatGPT}}},
  author = {Yetistiren, Burak and Özsoy, Isik and Ayerdem, Miray and Tüzün, Eray},
  date = {2023},
  journaltitle = {ArXiv},
  volume = {abs/2304.10778},
  url = {https://api.semanticscholar.org/CorpusID:258291698}
}

@article{yuAlleviatingPatchOverfitting2018,
  title = {Alleviating Patch Overfitting with Automatic Test Generation: A Study of Feasibility and Effectiveness for the {{Nopol}} Repair System},
  author = {Yu, Zhongxing and Martinez, Matias and Danglot, Benjamin and Durieux, Thomas and Martin, Monperrus},
  date = {2018},
  journaltitle = {Empirical Software Engineering},
  volume = {24},
  pages = {33--67},
  doi = {10.1007/s10664-018-9619-4},
  url = {https://www.semanticscholar.org/paper/6cc59dd2d0b2d84960ac8111380c557323ee1318},
  abstract = {S2 TL;DR: The main result is that automatic test generation is effective in alleviating one kind of overfitting, issue–regression introduction, but due to oracle problem, has minimal positive impact on alleviating the other kind ofoverfitting issue–incomplete fixing.}
}

@article{yuAlleviatingPatchOverfitting2018a,
  title = {Alleviating Patch Overfitting with Automatic Test Generation: A Study of Feasibility and Effectiveness for the {{Nopol}} Repair System},
  author = {Yu, Zhongxing and Martinez, Matias and Danglot, Benjamin and Durieux, Thomas and Martin, Monperrus},
  date = {2018},
  journaltitle = {Empirical Software Engineering},
  volume = {24},
  pages = {33--67},
  doi = {10.1007/s10664-018-9619-4},
  url = {https://www.semanticscholar.org/paper/6cc59dd2d0b2d84960ac8111380c557323ee1318},
  abstract = {S2 TL;DR: The main result is that automatic test generation is effective in alleviating one kind of overfitting, issue–regression introduction, but due to oracle problem, has minimal positive impact on alleviating the other kind ofoverfitting issue–incomplete fixing.}
}

@article{yuTestCaseGeneration2017,
  title = {Test {{Case Generation}} for {{Program Repair}}: {{A Study}} of {{Feasibility}} and {{Effectiveness}}},
  author = {Yu, Zhongxing and Martinez, Matias and Danglot, Benjamin and Durieux, Thomas and Martin, Monperrus},
  date = {2017},
  journaltitle = {ArXiv},
  volume = {abs/1703.00198},
  pages = {null},
  url = {https://www.semanticscholar.org/paper/96ae164242853becba6cf6125b4843758eed72bc},
  abstract = {Among the many different kinds of program repair techniques, one widely studied family of techniques is called test suite based repair. Test-suites are in essence input-output specifications and are therefore typically inadequate for completely specifying the expected behavior of the program under repair. Consequently, the patches generated by test suite based program repair techniques pass the test suite, yet may be incorrect. Patches that are overly specific to the used test suite and fail to generalize to other test cases are called overfitting patches. In this paper, we investigate the feasibility and effectiveness of test case generation in alleviating the overfitting issue. We propose two approaches for using test case generation to improve test suite based repair, and perform an extensive evaluation of the effectiveness of the proposed approaches in enabling better test suite based repair on 224 bugs of the Defects4J repository. The results indicate that test case generation can change the resulting patch, but is not effective at turning incorrect patches into correct ones. We identify the problems related with the ineffectiveness, and anticipate that our results and findings will lead to future research to build test-case generation techniques that are tailored to automatic repair systems.}
}

@article{yuTestCaseGeneration2017a,
  title = {Test {{Case Generation}} for {{Program Repair}}: {{A Study}} of {{Feasibility}} and {{Effectiveness}}},
  author = {Yu, Zhongxing and Martinez, Matias and Danglot, Benjamin and Durieux, Thomas and Martin, Monperrus},
  date = {2017},
  journaltitle = {ArXiv},
  volume = {abs/1703.00198},
  pages = {null},
  url = {https://www.semanticscholar.org/paper/96ae164242853becba6cf6125b4843758eed72bc},
  abstract = {Among the many different kinds of program repair techniques, one widely studied family of techniques is called test suite based repair. Test-suites are in essence input-output specifications and are therefore typically inadequate for completely specifying the expected behavior of the program under repair. Consequently, the patches generated by test suite based program repair techniques pass the test suite, yet may be incorrect. Patches that are overly specific to the used test suite and fail to generalize to other test cases are called overfitting patches. In this paper, we investigate the feasibility and effectiveness of test case generation in alleviating the overfitting issue. We propose two approaches for using test case generation to improve test suite based repair, and perform an extensive evaluation of the effectiveness of the proposed approaches in enabling better test suite based repair on 224 bugs of the Defects4J repository. The results indicate that test case generation can change the resulting patch, but is not effective at turning incorrect patches into correct ones. We identify the problems related with the ineffectiveness, and anticipate that our results and findings will lead to future research to build test-case generation techniques that are tailored to automatic repair systems.}
}

@article{zhangBadSmellsIndicate2008,
  title = {Do Bad Smells Indicate "Trouble" in Code?},
  author = {Zhang, Min and Hall, T. and Baddoo, Nathan and Wernick, P.},
  date = {2008},
  doi = {10.1145/1390817.1390831},
  url = {https://www.semanticscholar.org/paper/f5a73b66fbde928aad4ae80fb25d18dd58419fff},
  abstract = {In 1999 Fowler et al. identified 22 Bad Smells in code to direct the effective refactoring. These are increasingly being used by software engineers. However, the empirical basis of using Bad Smells to direct refactoring and to address 'trouble' in code is not clear. Our project aims to empirically investigate the impact of Bad Smells on software in terms of their relationship to faults.}
}

@article{zhangImprovingPrecisionFowler2008,
  title = {Improving the {{Precision}} of {{Fowler}}'s {{Definitions}} of {{Bad Smells}}},
  author = {Zhang, Min and Baddoo, Nathan and Wernick, P. and Hall, T.},
  date = {2008},
  journaltitle = {2008 32nd Annual IEEE Software Engineering Workshop},
  volume = {null},
  pages = {161--166},
  doi = {10.1109/SEW.2008.26},
  url = {https://www.semanticscholar.org/paper/c6956685bd22ae6dd983cd3087ba8313c235cf96},
  abstract = {Current approaches to detecting bad smells in code are mainly based on software metrics. We suggest that these methods lack precision in detecting bad smells, and we propose a code pattern-based approach to detecting bad smells. However before such a pattern-based approach can be implemented, Fowler's original definitions of bad smells need to be made more precise. Currently Fowler's definitions are too informal to implement in a pattern-searching tool. In this paper we use an expert panel to evaluate our enhanced definitions for five of Fowler's bad smells. We use a questionnaire to survey four experts' opinions of our bad smell definitions. Our results show that the experts basically agree with our enhanced definitions of the message chains, middle man and speculative generality bad smells. However, there are strong disagreements on our definitions of the data clumps and switch statements bad smells. We present enhanced definitions on the basis of these expert opinions.}
}
@inproceedings{BaumgartnerAP23,
  title = {Live Code Smell Detection of Data Clumps in an Integrated Development Environment},
  author = {Nils Baumgartner and Firas Adleh and Elke Pulvermüller},
  year = {2023},
  doi = {10.5220/0011727500003464},
  url = {https://doi.org/10.5220/0011727500003464},
  researchr = {https://researchr.org/publication/BaumgartnerAP23},
  cites = {0},
  citedby = {0},
  pages = {64-76},
  booktitle = {Proceedings of the 18th International Conference on Evaluation of Novel Approaches to Software Engineering, ENASE 2023, Prague, Czech Republic, April 24-25, 2023},
  editor = {Hermann Kaindl and Mike Mannion and Leszek A. Maciaszek},
  publisher = {SCITEPRESS},
  isbn = {978-989-758-647-7},
}
@article{zhangPrioritisingRefactoringUsing2011,
  title = {Prioritising {{Refactoring Using Code Bad Smells}}},
  author = {Zhang, Min and Baddoo, Nathan and Wernick, P. and Hall, T.},
  date = {2011},
  journaltitle = {2011 IEEE Fourth International Conference on Software Testing, Verification and Validation Workshops},
  volume = {null},
  pages = {458--464},
  doi = {10.1109/ICSTW.2011.69},
  url = {https://www.semanticscholar.org/paper/de0f73151aea57aff4f2d4c6e7875a7a790877ec},
  abstract = {We investigated the relationship between six of Fowler et al.'s Code Bad Smells (Duplicated Code, Data Clumps, Switch Statements, Speculative Generality, Message Chains, and Middle Man) and software faults. In this paper we discuss how our results can be used by software developers to prioritise refactoring. In particular we suggest that source code containing Duplicated Code is likely to be associated with more faults than source code containing the other five Code Bad Smells. As a consequence, Duplicated Code should be prioritised for refactoring. Source code containing Message Chains seems to be associated with a high number of faults in some situations. Consequently it is another Code Bad Smell which should be prioritised for refactoring. Source code containing only one of the Data Clumps, Switch Statements, Speculative Generality, or Middle Man Bad Smell is not likely to be fault-prone. As a result these Code Bad Smells could be put into a lower refactoring priority.}
}
@www{ChatGPT_url,
	title        = {ChatGPT},
	url          = {https://chat.openai.com/auth/login},
	urldate      = {2023-09-20},
	priority     = {prio1}
}
@www{dataclump_type_context,
	title        = {Datac Clumps Type Context GitHub page},
	url          = {https://github.com/FireboltCasters/data-clumps-type-context/tree/main},
	urldate      = {2023-11-24},
	priority     = {prio1}
}
@www{ChatGPT_image,
	title        = {ChatGPT},
    author={ David Pierce},
	url          = {https://www.theverge.com/2023/9/25/23886699/chatgpt-pictures-voice-commands-ai-chatbot-openai},
	urldate      = {2023-10-24},
	date     = {2023-09-25}
}
@book{fowler2019refactoring,
	title        = {Refactoring: Improving the Design of Existing Code},
	author       = {Fowler, M. and Beck, K.},
	publisher    = {Addison-Wesley},
	series       = {A Martin Fowler signature book},
	isbn         = {978-0-13-475759-9},
	date         = 2019,
	lccn         = 2018950015,
	priority     = {prio1}
}


@ARTICLE{5680918,
  author={Liu, Hui and Ma, Zhiyi and Shao, Weizhong and Niu, Zhendong},
  journal={IEEE Transactions on Software Engineering}, 
  title={Schedule of Bad Smell Detection and Resolution: A New Way to Save Effort}, 
  year={2012},
  volume={38},
  number={1},
  pages={220-235},
  doi={10.1109/TSE.2011.9}}

@INPROCEEDINGS{5076631,
  author={Tempero, Ewan},
  booktitle={2009 Australian Software Engineering Conference}, 
  title={How Fields are Used in Java: An Empirical Study}, 
  year={2009},
  volume={},
  number={},
  pages={91-100},
  doi={10.1109/ASWEC.2009.19}}

@inproceedings{10.1145/1352678.1352681,
author = {Denker, Marcus and G\^{\i}rba, Tudor and Lienhard, Adrian and Nierstrasz, Oscar and Renggli, Lukas and Zumkehr, Pascal},
title = {Encapsulating and Exploiting Change with Changeboxes},
year = {2007},
isbn = {9781605580845},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1352678.1352681},
doi = {10.1145/1352678.1352681},
abstract = {Real world software systems change continuously to meet new demands. Most programming languages and development environments, however, are more concerned with limiting the effects of change rather than enabling and exploiting change. Various techniques and technologies to exploit change have been developed over the years, but there exists no common support for these approaches. We propose Changeboxes as a general-purpose mechanism for encapsulating change as a first-class entity in a running software system. Changeboxes support multiple, concurrent and possibly inconsistent views of software artifacts within the same running system. Since Changeboxes are first-class, they can be manipulated to control the scope of change in a running system. Furthermore, Changeboxes capture the semantics of change. Changeboxes can be used, for example, to encapsulate refactorings, or to replay or analyze the history of changes. In this paper we introduce Changeboxes by means of a prototype implementation. We illustrate the benefits that Changeboxes offer for evolving software systems, and we present the results of a preliminary performance evaluation that assesses the costs associated with Changeboxes while suggesting possible strategies for improvement.},
booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages: In Conjunction with the 15th International Smalltalk Joint Conference 2007},
pages = {25–49},
numpages = {25},
location = {Lugano, Switzerland},
series = {ICDL '07}
}
@article{White2023ChatGPTPP,
  title={ChatGPT Prompt Patterns for Improving Code Quality, Refactoring, Requirements Elicitation, and Software Design},
  author={Jules White and Sam Hays and Quchen Fu and Jesse Spencer-Smith and Douglas C. Schmidt},
  journal={ArXiv},
  year={2023},
  volume={abs/2303.07839},
  url={https://api.semanticscholar.org/CorpusID:257505363}
}
@misc{cao2023study,
      title={A study on Prompt Design, Advantages and Limitations of ChatGPT for Deep Learning Program Repair}, 
      author={Jialun Cao and Meiziniu Li and Ming Wen and Shing-chi Cheung},
      year={2023},
      eprint={2304.08191},
      archivePrefix={arXiv},
      primaryClass={cs.SE}
}
@www{data_clumps_refactoring_guru,
	title        = {Data Clumps},
	url          = {https://refactoring.guru/smells/data-clumps},
	urldate      = {2023-09-26},
	priority     = {prio1}
}
@www{join_data_items,
	title        = {Join data items that want to go together – code smells series},
	url          = {https://blog.jetbrains.com/dotnet/2018/07/02/join-data-items-want-go-together-code-smells-series/},
	urldate      = {2023-09-26},
	priority     = {prio1}
}
@inproceedings{10.1145/2393596.2393655,
	title        = {A Field Study of Refactoring Challenges and Benefits},
	author       = {Kim, Miryung and Zimmermann, Thomas and Nagappan, Nachiappan},
	year         = 2012,
	booktitle    = {Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering},
	location     = {Cary, North Carolina},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {FSE '12},
	doi          = {10.1145/2393596.2393655},
	isbn         = 9781450316149,
	abstract     = {It is widely believed that refactoring improves software quality and developer productivity. However, few empirical studies quantitatively assess refactoring benefits or investigate developers' perception towards these benefits. This paper presents a field study of refactoring benefits and challenges at Microsoft through three complementary study methods: a survey, semi-structured interviews with professional software engineers, and quantitative analysis of version history data. Our survey finds that the refactoring definition in practice is not confined to a rigorous definition of semantics-preserving code transformations and that developers perceive that refactoring involves substantial cost and risks. We also report on interviews with a designated refactoring team that has led a multi-year, centralized effort on refactoring Windows. The quantitative analysis of Windows 7 version history finds that the binary modules refactored by this team experienced significant reduction in the number of inter-module dependencies and post-release defects, indicating a visible benefit of refactoring.},
	articleno    = 50,
	numpages     = 11,
	keywords     = {defects, empirical study, refactoring, software evolution, churn, component dependencies}
}
@inproceedings{9796303,
	title        = {Is Refactoring Always a Good Egg? Exploring the Interconnection Between Bugs and Refactorings},
	author       = {Bagheri, Amirreza and Hegedűs, Péter},
	year         = 2022,
	booktitle    = {2022 IEEE/ACM 19th International Conference on Mining Software Repositories (MSR)},
	volume       = {},
	number       = {},
	pages        = {117--121},
	doi          = {10.1145/3524842.3528034}
}
@inproceedings{data_clumps_baumgartner,
	title        = {The life-
cycle of data clumps: A longitudinal case study in
open-source projects},
	author       = {Baumgartner, Nils and  Pulvermüller, Erika},
	year         = 2024,
	booktitle    = {nternational Conference
on Model-Bases Software and Systems Engineering},
	
	
}

@misc{sobania2023analysis,
	title        = {An Analysis of the Automatic Bug Fixing Performance of ChatGPT},
	author       = {Dominik Sobania and Martin Briesch and Carol Hanna and Justyna Petke},
	year         = 2023,
	eprint       = {2301.08653},
	archiveprefix = {arXiv},
	primaryclass = {cs.SE}
}
@misc{sadik2023analysis,
	title        = {Analysis of ChatGPT on Source Code},
	author       = {Ahmed R. Sadik and Antonello Ceravola and Frank Joublin and Jibesh Patra},
	year         = 2023,
	eprint       = {2306.00597},
	archiveprefix = {arXiv},
	primaryclass = {cs.SE}
}
@misc{guo2023exploring,
	title        = {Exploring the Potential of ChatGPT in Automated Code Refinement: An Empirical Study},
	author       = {Qi Guo and Junming Cao and Xiaofei Xie and Shangqing Liu and Xiaohong Li and Bihuan Chen and Xin Peng},
	year         = 2023,
	eprint       = {2309.08221},
	archiveprefix = {arXiv},
	primaryclass = {cs.SE}
}
@misc{xia2023conversation,
	title        = {Keep the Conversation Going: Fixing 162 out of 337 bugs for \$0.42 each using ChatGPT},
	author       = {Chunqiu Steven Xia and Lingming Zhang},
	year         = 2023,
	eprint       = {2304.00385},
	archiveprefix = {arXiv},
	primaryclass = {cs.SE}
}
@article{4ef0b456377aafb68884e643779dffb36b8e7cc1,
	title        = {C-3PR: A Bot for Fixing Static Analysis Violations via Pull Requests},
	author       = {Antonio Carvalho and W. Luz and Diego Marcilio and R. Bonifácio and G. Pinto and E. D. Canedo},
	year         = 2020,
	journal      = {2020 IEEE 27th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
	volume       = {null},
	pages        = {161--171},
	doi          = {10.1109/SANER48275.2020.9054842},
	url          = {https://www.semanticscholar.org/paper/4ef0b456377aafb68884e643779dffb36b8e7cc1},
	abstract     = {Static analysis tools are frequently used to detect common programming mistakes or bad practices. Yet, the existing literature reports that these tools are still underused in the industry, which is partly due to (1) the frequent high number of false positives generated, (2) the lack of automated repairing solutions, and (3) the possible mismatches between tools and workflows of development teams. In this study we explored the question: “How could a bot-based approach allow seamless integration of static analysis tools into developers' workflows?” To this end we introduce C-3PR, an event-based bot infrastructure that automatically proposes fixes to static analysis violations through pull requests (PRs). We have been using C-3PR in an industrial setting for a period of eight months. To evaluate C-3PR usefulness, we monitored its operation in response to 2179 commits to the code base of the tracked projects. The bot autonomously executed 201346 analyses, yielding 610 pull requests. Among them, 346 (57\%) were merged into the projects' code bases. We observed that, on average, these PRs are evaluated faster than general-purpose PRs (2.58 and 5.78 business days, respectively). Accepted transformations take even shorter time (1.56 days). Among the reasons for rejection, bugs in C-3PR and in the tools it uses are the most common ones. PRs that require the resolution of a merge conflict are almost always rejected as well. We also conducted a focus group to assess how C-3PR affected the development workflow. We observed that developers perceived C-3PR as efficient, reliable, and useful. For instance, the participants mentioned that, given the chance, they would keep using C-3PR. Our findings bring new evidence that a bot-based infrastructure could mitigate some challenges that hinder the wide adoption of static analysis tools.}
}
@www{lsp_website,
	title        = {Language Server Protocol: Overview},
	url          = {https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/},
	urldate      = {2023-09-26},
	priority     = {prio1}
}
@www{json_rpc,
	title        = {RCP Specification},
	url          = {https://www.jsonrpc.org/specification/},
	urldate      = {2023-09-26},
	priority     = {prio1}
}
@www{turing_test,
	title        = {ChatGPt Turing Test},
	url          = {https://t3n.de/news/turing-test-openais-chatgpt-verliert-gegen-sprachmodell-aus-den-60ern-1594130/},
	urldate      = {2023-09-26},
	priority     = {prio1}
}

@article{Wei2022ChainOT,
  title={Chain of Thought Prompting Elicits Reasoning in Large Language Models},
  author={Jason Wei and Xuezhi Wang and Dale Schuurmans and Maarten Bosma and Ed Huai-hsin Chi and F. Xia and Quoc Le and Denny Zhou},
  journal={ArXiv},
  year={2022},
  volume={abs/2201.11903},
  url={https://api.semanticscholar.org/CorpusID:246411621}
}
@INPROCEEDINGS{10062688,
  author={Abdullah, Malak and Madain, Alia and Jararweh, Yaser},
  booktitle={2022 Ninth International Conference on Social Networks Analysis, Management and Security (SNAMS)}, 
  title={ChatGPT: Fundamentals, Applications and Social Impacts}, 
  year={2022},
  volume={},
  number={},
  pages={1-8},
  doi={10.1109/SNAMS58071.2022.10062688}}
@www{separate_code_data,
	title        = {The Data Science Checklist: Best Practices for Maintainable Data Science Projects},
	date      = {2022-05-18},
	priority     = {prio1},
urldate={2024-01-11},
author={Eduardo Blancas},
url={https://ploomber.io/blog/checklist/}
}
@www{prompt_engineering_jonathan,
	title        = {ChatGPT Guide: Use these prompt strategies to maximize your results},
	date      = {2024-01-01},
	priority     = {prio1},
urldate={2024-01-11},
author={Jonathan Kemper},
url={https://the-decoder.com/chatgpt-guide-prompt-strategies/}
}

@article{bsharat2023principled,
  title={Principled Instructions Are All You Need for Questioning LLaMA-1/2, GPT-3.5/4},
  author={Sondos Mahmoud Bsharat, Aidar Myrzakhan, Zhiqiang Shen},
  journal={arXiv preprint arXiv:2312.16171},
  year={2023}
}

@www{orchestration_choreography,
	title        = {Orchestration vs Choreography},
	date      = {2023-02-01},
	priority     = {prio1},
urldate={2024-01-11},
author={Jonathan Kemper},
url={https://camunda.com/blog/2023/02/orchestration-vs-choreography/}
}
@www{chatgpt_new_models,
	title        = {Bigger, better, faster, more: OpenAI zündet den GPT-4 Turbo},
	date      = {2023-11-07},
	priority     = {prio1},
urldate={2024-01-11},
author={Daniel AJ Sokolov},
url={https://www.heise.de/news/Bigger-better-faster-more-OpenAI-zuendet-den-GPT-Turbo-9354898.html}
}
@www{ollama,
	title        = {Ollama Website},
	priority     = {prio1},
urldate={2024-01-11},
url={https://ollama.com/}
}


@www{chatgpt_limits,
	title        = {Rate Limits},
	priority     = {prio1},
urldate={2024-01-11},
url={https://platform.openai.com/docs/guides/rate-limits/usage-tiers?context=tier-one}
}
@inproceedings{stench_blossom,
author = {Murphy-Hill, Emerson and Black, Andrew P.},
title = {An interactive ambient visualization for code smells},
year = {2010},
isbn = {9781450300285},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1879211.1879216},
doi = {10.1145/1879211.1879216},
abstract = {Code smells are characteristics of software that indicate that code may have a design problem. Code smells have been proposed as a way for programmers to recognize the need for restructuring their software. Because code smells can go unnoticed while programmers are working, tools called smell detectors have been developed to alert programmers to the presence of smells in their code, and to help them understand the cause of those smells. In this paper, we propose a novel smell detector called Stench Blossom that provides an interactive ambient visualization designed to first give programmers a quick, high-level overview of the smells in their code, and then, if they wish, to help in understanding the sources of those code smells. We also describe a laboratory experiment with 12 programmers that tests several hypotheses about our tool. Our findings suggest that programmers can use our tool effectively to identify smells and to make refactoring judgements. This is partly because the tool serves as a memory aid, and partly because it is more reliable and easier to use than heuristics for analyzing smells.},
booktitle = {Proceedings of the 5th International Symposium on Software Visualization},
pages = {5–14},
numpages = {10},
keywords = {code smells, refactoring, software, usability},
location = {Salt Lake City, Utah, USA},
series = {SOFTVIS '10}
}

@misc{shirafuji2023refactoring,
      title={Refactoring Programs Using Large Language Models with Few-Shot Examples}, 
      author={Atsushi Shirafuji and Yusuke Oda and Jun Suzuki and Makoto Morishita and Yutaka Watanobe},
      year={2023},
      eprint={2311.11690},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}
@misc{pearce2021asleep,
      title={Asleep at the Keyboard? Assessing the Security of GitHub Copilot's Code Contributions}, 
      author={Hammond Pearce and Baleegh Ahmad and Benjamin Tan and Brendan Dolan-Gavitt and Ramesh Karri},
      year={2021},
      eprint={2108.09293},
      archivePrefix={arXiv},
      primaryClass={cs.CR}
}
@inproceedings{not_what_you_signed_for,
author = {Greshake, Kai and Abdelnabi, Sahar and Mishra, Shailesh and Endres, Christoph and Holz, Thorsten and Fritz, Mario},
title = {Not What You've Signed Up For: Compromising Real-World LLM-Integrated Applications with Indirect Prompt Injection},
year = {2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3605764.3623985},
doi = {10.1145/3605764.3623985},
abstract = {Large Language Models (LLMs) are increasingly being integrated into applications, with versatile functionalities that can be easily modulated via natural language prompts. So far, it was assumed that the user is directly prompting the LLM. But, what if it is not the user prompting? We show that LLM-Integrated Applications blur the line between data and instructions and reveal several new attack vectors, using Indirect Prompt Injection, that enable adversaries to remotely (i.e., without a direct interface) exploit LLM-integrated applications by strategically injecting prompts into data likely to be retrieved at inference time. We derive a comprehensive taxonomy from a computer security perspective to broadly investigate impacts and vulnerabilities, including data theft, worming, information ecosystem contamination, and other novel security risks. We then demonstrate the practical viability of our attacks against both real-world systems, such as Bing Chat and code-completion engines, and GPT-4 synthetic applications. We show how processing retrieved prompts can act as arbitrary code execution, manipulate the application's functionality, and control how and if other APIs are called. Despite the increasing reliance on LLMs, effective mitigations of these emerging threats are lacking. By raising awareness of these vulnerabilities, we aim to promote the safe and responsible deployment of these powerful models and the development of robust defenses that protect users from potential attacks.},
booktitle = {Proceedings of the 16th ACM Workshop on Artificial Intelligence and Security},
pages = {79–90},
numpages = {12},
keywords = {indirect prompt injection, large language models},
location = {<conf-loc>, <city>Copenhagen</city>, <country>Denmark</country>, </conf-loc>},
series = {AISec '23}
}
@misc{chen2023frugalgpt,
      title={FrugalGPT: How to Use Large Language Models While Reducing Cost and Improving Performance}, 
      author={Lingjiao Chen and Matei Zaharia and James Zou},
      year={2023},
      eprint={2305.05176},
      archivePrefix={arXiv},
      primaryClass={cs.LG}
}
@misc{azaria2023internal,
      title={The Internal State of an LLM Knows When It's Lying}, 
      author={Amos Azaria and Tom Mitchell},
      year={2023},
      eprint={2304.13734},
      archivePrefix={arXiv},
      primaryClass={cs.CL}
}
@misc{hu2023large,
      title={Large Language Model-Powered Smart Contract Vulnerability Detection: New Perspectives}, 
      author={Sihao Hu and Tiansheng Huang and Fatih İlhan and Selim Furkan Tekin and Ling Liu},
      year={2023},
      eprint={2310.01152},
      archivePrefix={arXiv},
      primaryClass={cs.CR}
}
@misc{chen2023instructzero,
      title={InstructZero: Efficient Instruction Optimization for Black-Box Large Language Models}, 
      author={Lichang Chen and Jiuhai Chen and Tom Goldstein and Heng Huang and Tianyi Zhou},
      year={2023},
      eprint={2306.03082},
      archivePrefix={arXiv},
      primaryClass={cs.AI}
}
@book{Amaratunga2023,
  title = {Understanding Large Language Models: Learning Their Underlying Concepts and Technologies},
  ISBN = {979-8-8688-0017-7},
  DOI = {https://doi.org/10.1007/979-8-8688-0017-7},
  publisher = {Apress},
  author = {Amaratunga,  Thimira},
  year = {2023}
}

@www{eu-ai-act,
	title        = {Regulation (EU) 2024/1689},
	priority     = {prio1},
urldate={2024-08-08},
url={https://eur-lex.europa.eu/eli/reg/2024/1689/oj},
date      = {2024-07-12},
}

@www{dry,
	title        = {Please do repeat yourself (DRY is dead)},
	priority     = {prio1},
urldate= {2024-08-30},
author={Rafal Stozek},
url={https://dev.to/ralphcone/please-do-repeat-yourself-dry-is-dead-1jbg},
date      ={2022-10-26},
}
@InProceedings{10.1007/978-981-13-8300-7_21,
author="Guggulothu, Thirupathi
and Moiz, Salman Abdul",
editor="Somani, Arun K.
and Ramakrishna, Seeram
and Chaudhary, Anil
and Choudhary, Chothmal
and Agarwal, Basant",
title="An Approach to Suggest Code Smell Order for Refactoring",
booktitle="Emerging Technologies in Computer Engineering: Microservices in Big Data Analytics",
year="2019",
publisher="Springer Singapore",
address="Singapore",
pages="250--260",
abstract="Code smell is an indicator of issues in source code qualities that may hinder maintenance, and evolution. Source code metrics are used to measure the quality of the code. In the literature, there are many code smells, refactoring techniques, and refactoring tools. However, a software project often contains thousands of code smells and many of them have no relation with design quality. It is a challenge for developers to decide which kind of code smell should be refactored first. We have proposed an approach that suggests a code smell order based on two aspects: (1) finding relevant metrics for each code smell dataset with the help of feature selection technique (2) analyzing the internal relation among the code smells with those relevant metrics. With this analysis, we are suggesting code smell order for developers to save their effort in the refactoring stage. The suggested order is evaluated on simple java source code.",
isbn="978-981-13-8300-7"
}
@InProceedings{10.1007/978-3-030-29238-6_19,
author="Rio, Am{\'e}rico
and Brito e Abreu, Fernando",
editor="Piattini, Mario
and Rupino da Cunha, Paulo
and Garc{\'i}a Rodr{\'i}guez de Guzm{\'a}n, Ignacio
and P{\'e}rez-Castillo, Ricardo",
title="Code Smells Survival Analysis in Web Apps",
booktitle="Quality of Information and Communications Technology",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="263--271",
abstract="Web applications are heterogeneous, both in their target platform (split across client and server sides) and on the formalisms they are built with, usually a mixture of programming and formatting languages. This heterogeneity is perhaps an explanation why software evolution of web applications (apps) is a poorly addressed topic in the literature. In this paper we focus on web apps built with PHP, the most widely used server-side programming language.",
isbn="978-3-030-29238-6"
}
@article{10.1145/3597208,
author = {Batoun, Mohamed Amine and Yung, Ka Lai and Tian, Yuan and Sayagh, Mohammed},
title = {An Empirical Study on GitHub Pull Requests’ Reactions},
year = {2023},
issue_date = {November 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {32},
number = {6},
issn = {1049-331X},
url = {https://doi.org/10.1145/3597208},
doi = {10.1145/3597208},
abstract = {The pull request mechanism is commonly used to propose source code modifications and get feedback from the community before merging them into a software repository. On GitHub, practitioners can provide feedback on a pull request by either commenting on the pull request or simply reacting to it using a set of pre-defined GitHub reactions, i.e., “Thumbs-up”, “Laugh”, “Hooray”, “Heart”, “Rocket”, “Thumbs-down”, “Confused”, and “Eyes”. While a large number of prior studies investigated how to improve different software engineering activities (e.g., code review and integration) by investigating the feedback on pull requests, they focused only on pull requests’ comments as a source of feedback. However, the GitHub reactions, according to our preliminary study, contain feedback that is not manifested within the comments of pull requests. In fact, our preliminary analysis of six popular projects shows that a median of 100\% of the practitioners who reacted to a pull request did not leave any comment suggesting that reactions can be a unique source of feedback to further improve the code review and integration process.To help future studies better leverage reactions as a feedback mechanism, we conduct an empirical study to understand the usage of GitHub reactions and understand their promises and limitations. We investigate in this article how reactions are used, when and who use them on what types of pull requests, and for what purposes. Our study considers a quantitative analysis on a set of 380 k reactions on 63 k pull requests of six popular open-source projects on GitHub and three qualitative analyses on a total number of 989 reactions from the same six projects. We find that the most common used GitHub reactions are the positive ones (i.e., “Thumbs-up”, “Hooray”, “Heart”, “Rocket”, and “Laugh”). We observe that reactors use positive reactions to express positive attitude (e.g., approval, appreciation, and excitement) on the proposed changes in pull requests. A median of just 1.95\% of the used reactions are negative ones, which are used by reactors who disagree with the proposed changes for six reasons, such as feature modifications that might have more downsides than upsides or the use of the wrong approach to address certain problems. Most (a median of 78.40\%) reactions on a pull request come before the closing of the corresponding pull requests. Interestingly, we observe that non-contributors (i.e., outsiders who potentially are the “end-users” of the software) are also active on reacting to pull requests. On top of that, we observe that core contributors, peripheral contributors, casual contributors and outsiders have different behaviors when reacting to pull requests. For instance, most core contributors react in the early stages of a pull request, while peripheral contributors, casual contributors and outsiders react around the closing time or, in some cases, after a pull request is merged. Contributors tend to react to the pull request’s source code, while outsiders are more concerned about the impact of the pull request on the end-user experience. Our findings shed light on common patterns of GitHub reactions usage on pull requests and provide taxonomies about the intention of reactors, which can inspire future studies better leverage pull requests’ reactions.},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {11},
articleno = {146},
numpages = {35},
keywords = {feedback, software collaboration, pull requests, GitHub reactions}
}
@inproceedings{edmondson2005likert,
  title={Likert scales: A history},
  author={Edmondson, Diane},
  booktitle={Proceedings of the Conference on Historical Analysis and Research in Marketing},
  volume={12},
  pages={127--133},
  year={2005}
}
@www{lamapoll,
	priority     = {prio1},
urldate={2024-08-13},
url={https://www.lamapoll.de/},
date      = {2024-08-13},
}


@inproceedings{10.1145/3366423.3380272,
author = {Maldeniya, Danaja and Budak, Ceren and Robert Jr., Lionel P. and Romero, Daniel M.},
title = {Herding a Deluge of Good Samaritans: How GitHub Projects Respond to Increased Attention},
year = {2020},
isbn = {9781450370233},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3366423.3380272},
doi = {10.1145/3366423.3380272},
abstract = {Collaborative crowdsourcing is a well-established model of work, especially in the case of open source software development. The structure and operation of these virtual and loosely-knit teams differ from traditional organizations. As such, little is known about how their behavior may change in response to an increase in external attention. To understand these dynamics, we analyze millions of actions of thousands of contributors in over 1100 open source software projects that topped the GitHub Trending Projects page and thus experienced a large increase in attention, in comparison to a control group of projects identified through propensity score matching. In carrying out our research, we use the lens of organizational change, which considers the challenges teams face during rapid growth and how they adapt their work routines, organizational structure, and management style. We show that trending results in an explosive growth in the effective team size. However, most newcomers make only shallow and transient contributions. In response, the original team transitions towards administrative roles, responding to requests and reviewing work done by newcomers. Projects evolve towards a more distributed coordination model with newcomers becoming more central, albeit in limited ways. Additionally, teams become more modular with subgroups specializing in different aspects of the project. We discuss broader implications for collaborative crowdsourcing teams that face attention shocks.},
booktitle = {Proceedings of The Web Conference 2020},
pages = {2055–2065},
numpages = {11},
keywords = {crowdsourcing, coordination, attention shocks, PSM, GitHub},
location = {Taipei, Taiwan},
series = {WWW '20}
}
@inproceedings{detecting_emotional,
author = {Dhakad, Rashmi and Benedicenti, Luigi},
year = {2021},
month = {08},
pages = {},
title = {Detecting Emotional Contagion in OSS Projects},
doi = {10.11159/cist21.301}
}
@article{Madaan2023SelfRefineIR,
  title={Self-Refine: Iterative Refinement with Self-Feedback},
  author={Aman Madaan and Niket Tandon and Prakhar Gupta and Skyler Hallinan and Luyu Gao and Sarah Wiegreffe and Uri Alon and Nouha Dziri and Shrimai Prabhumoye and Yiming Yang and Sean Welleck and Bodhisattwa Prasad Majumder and Shashank Gupta and Amir Yazdanbakhsh and Peter Clark},
  journal={ArXiv},
  year={2023},
volume={abs/2303.17651},
doi={10.48550/arXiv.2303.17651},
  url={https://api.semanticscholar.org/CorpusID:257900871}
}